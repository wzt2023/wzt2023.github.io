<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32X32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16X16.png">
  <link rel="mask-icon" href="/images/mylogo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Hack:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wzt2022.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":18,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideLeftBigIn","post_body":"slideRightBigIn","coll_header":"slideLeftIn","sidebar":"slideLeftBigIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="stay hungry stay foolish！">
<meta property="og:type" content="website">
<meta property="og:title" content="TT の 博客">
<meta property="og:url" content="https://wzt2022.github.io/index.html">
<meta property="og:site_name" content="TT の 博客">
<meta property="og:description" content="stay hungry stay foolish！">
<meta property="article:author" content="Jony J">
<meta property="article:tag" content="while true { code() }">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wzt2022.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>TT の 博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6f41e725d94bfbcea62c56e046b8a37a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="TT の 博客" type="application/atom+xml">
</head>
<!-- 页面点击小红心 -->
 <script async src="/js/fireworks.js"></script>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TT の 博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">远方除了遥远，一无所有。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-heart fa-fw"></i>生活中的美好</a>

  </li>
        <li class="menu-item menu-item-photo">

    <a href="/photo/" rel="section"><i class="fa fa-image fa-fw"></i>照片</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/lf2021" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/02/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">前端进击笔记总结</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-26T00:00:00+08:00">2021-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">把一个数组旋转k步 例如[1,2,3,4,5,6，7]=&gt;[5,6,7,1,2,3,4]</span><br><span class="line"></span><br><span class="line">第一种方法</span><br><span class="line">第二个思路</span><br><span class="line">function rotate(arr,k)&#123;</span><br><span class="line">     const length = arr.length</span><br><span class="line">	if(!k||length===0)return arr</span><br><span class="line">	const step = Math.abs(k%length)</span><br><span class="line">	const arr1 = arr.slice(-step)  //O(1)因为原数组没有发生改变</span><br><span class="line">	const arr2 = arr.slice(0,length-step)</span><br><span class="line">	const arr3 = arr1.concat(arr2)</span><br><span class="line">	return arr3                              </span><br><span class="line">&#125;   </span><br><span class="line">时间复杂度为O(1) 空间复杂度为为O(n) 因为定义了3个还是为O(n)</span><br><span class="line"></span><br><span class="line">第二种方法</span><br><span class="line">function rotate1(arr)&#123;</span><br><span class="line">	const length = arr.length</span><br><span class="line">	if(!k||length===0) return arr</span><br><span class="line">	const step = Math.abs(k%length)</span><br><span class="line">	for(let i = 0;i<span class="tag">&lt;<span class="name">length;i++)&#123;</span>    <span class="attr">O</span>(<span class="attr">n</span>) 空间复杂度为<span class="attr">O</span>(<span class="attr">1</span>),因为没有定义和其它数组相关的变量</span></span><br><span class="line"><span class="tag">    	<span class="attr">const</span> <span class="attr">n</span> = <span class="string">arr.pop()</span></span></span><br><span class="line"><span class="tag">        <span class="attr">if</span>(<span class="attr">n</span>!=<span class="string">null)&#123;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">arr.unshift</span>(<span class="attr">n</span>)//数组是一个有序结构，<span class="attr">unshift</span>操作非常慢 你把最后一个元素添加到第一位需要移动所有元素 因此为<span class="attr">O</span>(<span class="attr">n</span>)            	//可以想象成在教室上课 最后一个学生移动第一排所有的学生都要移动</span></span><br><span class="line"><span class="tag">        &#125;                         </span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  <span class="attr">return</span> <span class="attr">arr</span></span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、匹配括号  栈</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchLetter</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">const</span> left = <span class="string">'(&#123;['</span></span><br><span class="line">    <span class="keyword">const</span> right = <span class="string">')&#125;]'</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> q = s[i]</span><br><span class="line">        <span class="keyword">if</span>(left.includes(q))&#123;</span><br><span class="line">            stack.push(q)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right.includes(q)) &#123;</span><br><span class="line">            <span class="keyword">const</span> top = stack[stack.length<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span>((top===<span class="string">'('</span>&amp;&amp;q===<span class="string">')'</span>)||(top===<span class="string">'&#123;'</span>&amp;&amp;q===<span class="string">'&#125;'</span>)||(top===<span class="string">'['</span>&amp;&amp;q===<span class="string">']'</span>))&#123;</span><br><span class="line">                stack.pop()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length===<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">队列 链表和数组可以实现队列  链表和数组都是有序结构 <span class="built_in">Set</span>是无序结构</span><br><span class="line">链表查询慢O(n) ，新增和删除快O(<span class="number">1</span>) </span><br><span class="line">数组查询快O(<span class="number">1</span>) ，新增和删除慢O(n) </span><br><span class="line">入队的时间复杂度是O(<span class="number">1</span>) </span><br><span class="line">但是出队（是使用栈来时间队列 两个栈首先先入栈然后出栈到另外一个栈之后移除栈顶元素再归还第一个栈）的时间复杂度为O(n)</span><br><span class="line">用两个栈来实现队列</span><br><span class="line">反转链表</span><br><span class="line"><span class="number">1</span>、反转两个节点只需要把n+<span class="number">1</span>个节点的next指针指向n</span><br><span class="line"><span class="number">2</span>、反转多个节点：双指针遍历链表，重复上述操作</span><br><span class="line">	输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">	输出：<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">	双指针一前一后遍历链表</span><br><span class="line">    反转双指针</span><br><span class="line">    <span class="keyword">let</span> p1=head;</span><br><span class="line">	<span class="keyword">let</span> p2=NULL;</span><br><span class="line">	<span class="keyword">while</span>(p1)&#123;</span><br><span class="line">       <span class="comment">//后写</span></span><br><span class="line">        <span class="keyword">const</span> temp = p1.next</span><br><span class="line">        p1.next = p2</span><br><span class="line">        <span class="comment">//先写双指针的遍历</span></span><br><span class="line">        p2=p1</span><br><span class="line">        p1=temp</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> p2 <span class="comment">//最后p1指向NULL p2才是那个头节点</span></span><br><span class="line"></span><br><span class="line">连环问 链表和数组，哪个实现队列更快？  空间复杂度都是O(n)</span><br><span class="line">数组是连续存储，push很快，shift 很慢 （删除第一个元素O(n)）</span><br><span class="line">链表是非连续存储，add和<span class="keyword">delete</span>都很快（但查找很慢)</span><br><span class="line">结论∶链表实现队列更快</span><br><span class="line"></span><br><span class="line">用链表实现队列</span><br><span class="line">单向链表 但要同时记录head和tail</span><br><span class="line">从tail(尾部入队) head(头部出队)</span><br><span class="line">length 要实时记录，不能遍历链表获取</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202202242107675.png" alt="image-20220224210751586"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">用JS实现二分查找</span><br><span class="line">递归-代码逻辑更加清晰</span><br><span class="line">非递归-性能更好</span><br><span class="line">时间复杂度是O(logn)</span><br><span class="line">	binarySearch=function(arr,item)&#123;</span><br><span class="line">		const length = arr.length</span><br><span class="line">		if(lengtg===0)return -1 </span><br><span class="line">        let left = 0</span><br><span class="line">        let right = arr.length-1</span><br><span class="line">        while(left<span class="tag">&lt;<span class="name">=right)&#123;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">const</span> <span class="attr">mid</span> = <span class="string">Math.floor((left+right)/2)</span></span></span><br><span class="line"><span class="tag">            <span class="attr">const</span> <span class="attr">element</span> = <span class="string">arr[mid]</span></span></span><br><span class="line">            if(element&lt;item)&#123;</span><br><span class="line">                left = mid+1</span><br><span class="line">            &#125;else if(element&gt;item)&#123;</span><br><span class="line">                right = mid-1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">如果使用递归就需要把left和right加到function的参数里</span><br><span class="line"></span><br><span class="line">找到一个数组中为n的两个数 =&gt;嵌套循环</span><br><span class="line">function sum(arr,n)&#123;</span><br><span class="line">const res = []</span><br><span class="line">for(let i=0;i<span class="tag">&lt;<span class="name">arr.length-1;i++)&#123;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">const</span> <span class="attr">n1</span> = <span class="string">arr[i]</span>     </span></span><br><span class="line"><span class="tag">       <span class="attr">let</span> <span class="attr">flag</span> = <span class="string">false</span></span></span><br><span class="line">   for(let j=i+1;j&lt;arr.length;j++)&#123;  //O(n^2)</span><br><span class="line">		const n2 =arr[j]</span><br><span class="line">		if(n1+n2===n)&#123;</span><br><span class="line">		  res.push(n1)</span><br><span class="line">		  res.push(n2)</span><br><span class="line">       	  flag = true</span><br><span class="line">		  break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(flag)break;</span><br><span class="line"> &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用双指针来解决 =&gt;利用递增的特性</span><br><span class="line">第一个指针在开头 第二个指针在结尾 如果两个数之和大于目标是 就第二个指针左移 如果小于就第一个指针右移</span><br><span class="line">function sum(arr,n)&#123;</span><br><span class="line">    const length= arr.length</span><br><span class="line">    const res = []</span><br><span class="line">	let i = 0</span><br><span class="line">	let j = length-1</span><br><span class="line">//O(n)</span><br><span class="line">	while(i<span class="tag">&lt;<span class="name">j)&#123;</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">const</span> <span class="attr">n1</span> = <span class="string">arr[i]</span>            </span></span><br><span class="line"><span class="tag">    	<span class="attr">const</span> <span class="attr">n2</span> = <span class="string">arr[j]</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">const</span> <span class="attr">n3</span> = <span class="string">n1+n2</span></span></span><br><span class="line">              if(n3&lt;sum)&#123;</span><br><span class="line">				i++</span><br><span class="line">        &#125;else if(n3&gt;sum)&#123;</span><br><span class="line">        		j--</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                res.push(n1)</span><br><span class="line">                res.push(n2)</span><br><span class="line">                break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索数 左边小于根小于右边</span><br><span class="line">第k小就相当于中序遍历后的数组 arr[k<span class="number">-1</span>] 因为下标从<span class="number">0</span>开始</span><br><span class="line">二叉搜索数BST的价值可使用二分法进行快速查找</span><br><span class="line">平衡二叉树为BBST 增删查时间复杂度都是O(logn) ，即树的高度 让整体最优</span><br><span class="line"></span><br><span class="line">堆栈模型 值类型变量存储在栈   引用类型变量存储在堆</span><br><span class="line">堆物理上是一个数组 逻辑上是一个二叉树</span><br><span class="line">查询慢 删除快 时间复杂度为O(logn)</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202202242223000.png" alt="image-20220224222323816"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">斐波那契函数</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(n===<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">return</span> fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202202242228488.png" alt="image-20220224222858341"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度不过关就要优化 不用递归用循环 记录中间结果</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(n===<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> n1 = <span class="number">1</span> <span class="comment">//记录n-1的结果</span></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="number">0</span> <span class="comment">//记录n-2的结果</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span> ;i&lt;=n,i++)&#123;</span><br><span class="line">    res = n1+n2</span><br><span class="line">    n1=n2</span><br><span class="line">    n2=res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">此方法引出动态规划 =&gt;大问题</span><br><span class="line">连环问 青蛙跳台阶和斐波那契数列完全一样</span><br><span class="line"></span><br><span class="line">将数组中的<span class="number">0</span>移动末尾</span><br><span class="line">splice 的时间复杂度就是O(n) 外加遍历O(n) 总的为O(n^<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveZero</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = arr.length</span><br><span class="line">    <span class="keyword">if</span>(length===<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> zerolength = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length-zerolength;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]===<span class="number">0</span>)&#123;</span><br><span class="line">            arr.push(<span class="number">0</span>) </span><br><span class="line">            arr.splice(i,<span class="number">1</span>)  <span class="comment">//本身就O(n)</span></span><br><span class="line">            i--  <span class="comment">//数组截取了一个元素，i就要递减，否则连续0就会有错误</span></span><br><span class="line">            zerolength++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr= [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">0</span>]</span><br><span class="line">moveZero(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line">时间复杂度为O(n^<span class="number">2</span>) 算法不可用</span><br><span class="line"></span><br><span class="line">优化:双指针</span><br><span class="line">定义j指向第一个<span class="number">0</span>，i指向j后面的第一个非O</span><br><span class="line">交换i和j的值，继续向后移动</span><br><span class="line">只遍历一次，所以时间复杂度是O(n)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveZero</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = arr.length</span><br><span class="line">    <span class="keyword">if</span>(length===<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">-1</span> <span class="comment">//指向第一个0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(arr[i]===<span class="number">0</span>)&#123; <span class="comment">//第一个0</span></span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123; <span class="comment">//j还没开始赋值</span></span><br><span class="line">                j = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span>(arr[i]!==<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">const</span> n =arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j]=n</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr= [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">0</span>]</span><br><span class="line">moveZero(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line">总结 数组是连续存储，要慎用splice unshift等API</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202202251956360.png" alt="image-20220225195645925"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">字符创中连续最多的字符以及次数</span><br><span class="line">只需要输出最多字符的次数</span><br><span class="line"><span class="keyword">var</span> maxPower = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.length===<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow&lt;s.length&amp;&amp;fast&lt;s.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[slow]!==s[fast])&#123;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max,fats-slow) <span class="comment">//赋值</span></span><br><span class="line">            slow++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fast++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">Math</span>.max(max,fats-slow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用双指针</span><br><span class="line">定义指针i和j。j不动，i继续移动</span><br><span class="line">如果i和j的值一直相等，则i继续移动</span><br><span class="line">直到i和j的值不相等，记录处理，让j追上i。继续第一步</span><br><span class="line">时间复杂度为O(n)</span><br><span class="line"><span class="keyword">var</span> maxPower = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> res =&#123;<span class="attr">char</span>:<span class="string">''</span>,<span class="attr">max</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> length = s.length</span><br><span class="line">    <span class="keyword">if</span>(length===<span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">let</span> tempLength = <span class="number">0</span>  <span class="comment">//临时记录当前连续字符的长度</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">            tempLength++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!==s[j] || i === length<span class="number">-1</span>)&#123;  <span class="comment">//不相等或者i到了字符串的末尾</span></span><br><span class="line">            <span class="keyword">if</span>(tempLength&gt;res.max)&#123;</span><br><span class="line">                res.char = s[j]  <span class="comment">//i是往前跑的 等于j</span></span><br><span class="line">                res.max = tempLength</span><br><span class="line">            &#125;</span><br><span class="line">            tempLength = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>)&#123;  <span class="comment">//没有到末尾</span></span><br><span class="line">                j=i  <span class="comment">//让j追上i</span></span><br><span class="line">                i--  <span class="comment">//因为for循环里有一个i++  细节</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">'aabbcccddeeeee'</span></span><br><span class="line"><span class="built_in">console</span>.log(maxPower(s)) <span class="comment">//&#123; char: 'e', max: 5 &#125;</span></span><br><span class="line"></span><br><span class="line">第二种方法 正则表达式 效率低 慎用</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202202252039092.png" alt="image-20220225203958930"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">对称数 求<span class="number">1</span><span class="number">-10000</span>之间的所有对称数</span><br><span class="line">**数组反转**</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPalindrome</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">if</span>(max&lt;=<span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=max;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> s = i.toString() <span class="comment">//转换为字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s===s.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))&#123;<span class="comment">//转换为数组 再反转 比较  看似是O(n) 但是转换也需要时间</span></span><br><span class="line">            res.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**字符串前后比较**</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findPalindrome</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">if</span>(max&lt;=<span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=max;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> s = i.toString() <span class="comment">//转换为字符串</span></span><br><span class="line">        <span class="keyword">const</span> length= s.length</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> star = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> end = length<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(star&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[star]!==s[end])&#123;</span><br><span class="line">                flag = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                star++</span><br><span class="line">                end--</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) res.push(i)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">**生成翻转数**</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPalindrome</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">if</span>(max&lt;=<span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=max;i++)&#123;</span><br><span class="line">    	<span class="keyword">let</span> n = i</span><br><span class="line">        <span class="keyword">let</span> rev =<span class="number">0</span> <span class="comment">//存储翻转数</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;  <span class="comment">//带一个数进去验证</span></span><br><span class="line">            rev = rev*<span class="number">10</span>+n%<span class="number">10</span></span><br><span class="line">            n = <span class="built_in">Math</span>.floor(n/<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i = nav)res.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">高效的字符串前缀匹配</span><br><span class="line">第一，遍历单词库数组</span><br><span class="line">第二，indexOf 判断前缀</span><br><span class="line">实际时间复杂度超过了O(n)，因为要考虑indexOf的计算量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入一个字符串，切换其中字母的大小写</span><br><span class="line">如，输入字符传<span class="number">12</span>aBc34，输出字符串<span class="number">12</span>AbC34</span><br><span class="line">正则表达式</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">switchLetterCase</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">'.</span></span><br><span class="line"><span class="string">    const length = s.length</span></span><br><span class="line"><span class="string">    if ( length === 0)return res</span></span><br><span class="line"><span class="string">    const reg1 = /[a-z]/</span></span><br><span class="line"><span class="string">    const reg2 =/[A-Z]/</span></span><br><span class="line"><span class="string">    for (let i= 0;i&lt; length; i++)&#123;</span></span><br><span class="line"><span class="string">    	const c = s[i]</span></span><br><span class="line"><span class="string">    	if (reg1.test(c))&#123;</span></span><br><span class="line"><span class="string">    		res += c.toUpperCase()</span></span><br><span class="line"><span class="string">        &#125;else if (reg2.test(c))&#123;</span></span><br><span class="line"><span class="string">            res t= c.toLowerCase()</span></span><br><span class="line"><span class="string">        &#125;else</span></span><br><span class="line"><span class="string">    		res += c</span></span><br><span class="line"><span class="string">    	&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">return res</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">ASCII 编码来做</span></span><br><span class="line"><span class="string">export function switchLetterCase(a) &#123;</span></span><br><span class="line"><span class="string">    let res = '</span>.</span><br><span class="line">    <span class="keyword">const</span> length = s.length</span><br><span class="line">    <span class="keyword">if</span> ( length === <span class="number">0</span>)<span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i= <span class="number">0</span>;i&lt; length; i++)&#123;</span><br><span class="line">    	<span class="keyword">const</span> c = s[i]</span><br><span class="line">        <span class="keyword">const</span> code = c.charCodeAt(<span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">if</span> (code&gt;=<span class="number">65</span>&amp;&amp;code&lt;=<span class="number">90</span>)&#123; <span class="comment">//大写</span></span><br><span class="line">    		res += c.toLowerCase()</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (code&gt;=<span class="number">97</span>&amp;&amp;code&lt;=<span class="number">122</span>)&#123;</span><br><span class="line">            res t= c.toUpperCase()</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">    		res += c</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">使用正则表达式，性能较差</span><br><span class="line">使用ASCII 码判断，性能较好——推荐答案</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么<span class="number">0.1</span>+<span class="number">0.2</span>!==<span class="number">0.3</span> <span class="literal">false</span></span><br><span class="line">是因为小数存储二进制进行转换的时候 没法准备表达造成的</span><br></pre></td></tr></table></figure>
<h3 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、Ajax Fetch Axios的区别？</span><br><span class="line"> 三者都用于网络请求、但是不同维度</span><br><span class="line"> Ajax一种技术统称   使用XMLHttpRequest实现简易ajax</span><br><span class="line"> Fetch是一个原生API 浏览器原生API 用于网络请求 和XMLHttpRequest一个级别 语法更加简洁易用，支持<span class="built_in">Promise</span></span><br><span class="line"> Axios是第三方库 库是第三方工具  </span><br><span class="line"> 第三方库需要API来实现  实际项目中，使用现成的lib(第三方库)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax2</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">res</span> =&gt;</span>res.json())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、节流和防抖</span><br><span class="line">防抖:一个搜索输入框，等输入停止之后，再触发搜索</span><br><span class="line"><span class="keyword">const</span> input1 = <span class="built_in">document</span>.getElementById(<span class="string">'input1'</span>)</span><br><span class="line">input1.addEventListener(<span class="string">'keyup'</span> , debounce(() =→&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'发起搜索",input1.value)</span></span><br><span class="line"><span class="string">&#125;))</span></span><br><span class="line"><span class="string">节流:节省交互沟通 按节奏来 插队无效 拖拽drag 和scroll滚动 期间触发某个回调 要设置一个时间间隔</span></span><br><span class="line"><span class="string">隔一段时间执行一次</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">节流︰限制执行频率，有节奏的执行</span></span><br><span class="line"><span class="string">防抖∶限制执行次数，多次密集的触发只执行一次</span></span><br><span class="line"><span class="string">节流关注“过程”，防抖关注“结果”</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3、 </span></span><br><span class="line"><span class="string">vw屏幕宽度的1%</span></span><br><span class="line"><span class="string">vh屏幕高度的1%</span></span><br><span class="line"><span class="string">vmin两者的最小值，vmax两者的最大值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4、箭头函数的缺点 ，哪里不能用箭头函数？</span></span><br><span class="line"><span class="string">缺点:</span></span><br><span class="line"><span class="string">	1、没有arguments</span></span><br><span class="line"><span class="string">        const fn1 =()=&gt;&#123;</span></span><br><span class="line"><span class="string">            console.log( '</span><span class="built_in">arguments</span><span class="string">', arguments)//arguments is not defined</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        function fn1()&#123;</span></span><br><span class="line"><span class="string">         console.log( '</span><span class="built_in">arguments</span><span class="string">' , arguments)  100 200 </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        fn1(100,200)</span></span><br><span class="line"><span class="string">	2、无法通过apply call bind改变this</span></span><br><span class="line"><span class="string">    不适用对象方法 原型方法 this不会指向当前对象也不会指向对象原型，指向父作用域window</span></span><br><span class="line"><span class="string">    箭头函数不能当构造函数</span></span><br><span class="line"><span class="string">	要熟练应用箭头函数，也要对函数 this arguments敏感</span></span><br><span class="line"><span class="string">5、TCP三次握手和四次挥手(原理)</span></span><br><span class="line"><span class="string">	握手是连接</span></span><br><span class="line"><span class="string">    挥手是断开</span></span><br><span class="line"><span class="string">    连接和断开都是我发起的</span></span><br><span class="line"><span class="string">握手:</span></span><br><span class="line"><span class="string">    先建立连接（确保双方都有收发消息的能力)</span></span><br><span class="line"><span class="string">    再传输内容（如发送给一个get请求)</span></span><br><span class="line"><span class="string">    网络连接是TCP协议，传输内容是HTTP协议</span></span><br><span class="line"><span class="string">    三次握手就相当于客户端和服务端 客户端问你在家嘛 服务端回答在家 客户端说那你等我我去找你 这3次相当于3次握手</span></span><br><span class="line"><span class="string">    Client 发包，Server接收。Server:有Client要找我</span></span><br><span class="line"><span class="string">    Server发包，Client 接收。Client : Server已经收到信息了</span></span><br><span class="line"><span class="string">    Client发包，Server 接收。Server : Client 要准备发送了</span></span><br><span class="line"><span class="string">中间建立连接数据集传输</span></span><br><span class="line"><span class="string">挥手:</span></span><br><span class="line"><span class="string">	 Client 发包，Server接收。Server : Client已请求结束</span></span><br><span class="line"><span class="string">     Server 发包，Client接收。Client : Server已收到，我等待它关闭</span></span><br><span class="line"><span class="string">     Server 发包，Client接收。Client : Server此时可以关闭连接了</span></span><br><span class="line"><span class="string">     Client发包，Server接收。Server :可以关闭了（然后关闭连接)</span></span><br><span class="line"><span class="string">6、for...in和for...of的区别</span></span><br><span class="line"><span class="string">	 for..in遍历得到key</span></span><br><span class="line"><span class="string">	 for...of 遍历得到value</span></span><br><span class="line"><span class="string"> 	const arr = [10,20,30]</span></span><br><span class="line"><span class="string">     	for (let key in arr) &#123;</span></span><br><span class="line"><span class="string">		console.log( key)//0 1 2 </span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	for...of 遍历得到value</span></span><br><span class="line"><span class="string">	const arr = [10,20,30]</span></span><br><span class="line"><span class="string">    	for ( let val of arr)&#123;</span></span><br><span class="line"><span class="string">		console. log(val)//10 20 30 </span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">适用于不同的数据类型</span></span><br><span class="line"><span class="string">    遍历对象: for...in 可以，for...of 不可以</span></span><br><span class="line"><span class="string">    遍历Map Set : for...of可以，for...in不可以</span></span><br><span class="line"><span class="string">    遍历generator : for...of可以，for...in不可以</span></span><br><span class="line"><span class="string">for...in用于可枚举数据，如对象、数组、字符串 得到key</span></span><br><span class="line"><span class="string">for...of用于可迭代数据、如数组、字符串、Map、Set 得到value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7、for await...of有什么作用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">就是promise.all的替代品 只不过promise.all是一个API的形式.then去获取所有的结果</span></span><br><span class="line"><span class="string">for await...of循环的形式快速的在列表把所有结果取出来</span></span><br><span class="line"><span class="string">for await...of作用能够遍历多个promise，遍历多个异步</span></span><br><span class="line"><span class="string">(async function()&#123;</span></span><br><span class="line"><span class="string">    const p1 = createPromise( 100)</span></span><br><span class="line"><span class="string">    const p2 = createPromise( 200)</span></span><br><span class="line"><span class="string">    const p3 = createPromise( 300)</span></span><br><span class="line"><span class="string">    //const res1 = await p1</span></span><br><span class="line"><span class="string">    //console.log(res1)  100</span></span><br><span class="line"><span class="string">    // const res2 = await p2</span></span><br><span class="line"><span class="string">    //console.log( res2)  200 </span></span><br><span class="line"><span class="string">    //const res3 = await p3</span></span><br><span class="line"><span class="string">    // console.log(res3)  300</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    const list = [p1,p2，p3]</span></span><br><span class="line"><span class="string">    // Promise.all(list).then(res =&gt; console.log(res))  100 200 300 </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // for await ( let res of list) &#123;</span></span><br><span class="line"><span class="string">    // console.log(res)  100 200 300</span></span><br><span class="line"><span class="string">    // &#125;</span></span><br><span class="line"><span class="string">-----------------------分割线-------------------------</span></span><br><span class="line"><span class="string">如果是按顺序慢慢的出来</span></span><br><span class="line"><span class="string">    //const res1 = await createPromise( 100)</span></span><br><span class="line"><span class="string">    //console.log(res1)  100</span></span><br><span class="line"><span class="string">    // const res2 = await createPromise( 200)</span></span><br><span class="line"><span class="string">    //console.log( res2)  200 </span></span><br><span class="line"><span class="string">    //const res3 = await createPromise( 300)</span></span><br><span class="line"><span class="string">    // console.log(res3)  300</span></span><br><span class="line"><span class="string">	循环 和上面一样</span></span><br><span class="line"><span class="string">    // const arr = [10,20,30]</span></span><br><span class="line"><span class="string">    // for ( let res of arr) &#123;</span></span><br><span class="line"><span class="string">	//  	const res = await createPromise(num)</span></span><br><span class="line"><span class="string">    // 		console.log(res) </span></span><br><span class="line"><span class="string">    // &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">8、 offsetHeight scrollHeight clientHeight区别</span></span><br><span class="line"><span class="string">    offsetHeight offsetWidth : border + padding + content</span></span><br><span class="line"><span class="string">    clientHeight clientWidth : padding + content</span></span><br><span class="line"><span class="string">    scrollHeight scrollWidth : padding +实际内容尺寸  //例如父盒子里有子盒子且有内容</span></span><br><span class="line"><span class="string">    scrollTo就是滚动条滑动的距离</span></span><br><span class="line"><span class="string">9、HTMLCollection和NodeList区别  （是类数组）</span></span><br><span class="line"><span class="string">	Node和Element DOM是一棵树，所有节点都是Node //Node是Element的基类  </span></span><br><span class="line"><span class="string">    HTMLCollection是Element的集合</span></span><br><span class="line"><span class="string">	NodeList是Node集合</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">	p标签里有em和b标签 也有文字</span></span><br><span class="line"><span class="string">    console.log(p1.children instapceof HTMLCollection) //true</span></span><br><span class="line"><span class="string">    console.log(p1.children instapceof NodeList) //false</span></span><br><span class="line"><span class="string">	如果用childNodes 就相反</span></span><br><span class="line"><span class="string">    console.log(p1.childNodes instapceof HTMLCollection) //false</span></span><br><span class="line"><span class="string">    console.log(p1.childNodes instapceof NodeList) //true</span></span><br><span class="line"><span class="string">10、JS严格模式有什么特点</span></span><br><span class="line"><span class="string">	"use strict"</span></span><br><span class="line"><span class="string">    全局变量必须先声明  var n = 10</span></span><br><span class="line"><span class="string">    禁止使用with </span></span><br><span class="line"><span class="string">    创建eval作用域</span></span><br><span class="line"><span class="string">    禁止this指向window 就是undefined</span></span><br><span class="line"><span class="string">    '</span>use strict<span class="string">'function fn() &#123;</span></span><br><span class="line"><span class="string">        console.log( '</span><span class="keyword">this</span> <span class="string">', this) //undefined</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        fn.call(&#123;x: 100&#125;) //可以使用call来改变this的指向</span></span><br><span class="line"><span class="string">	函数参数不能重名</span></span><br><span class="line"><span class="string">11、HTTP跨域请求时为何发送options请求</span></span><br><span class="line"><span class="string">	跨域请求:；浏览器同源策略  JSONP解决跨域</span></span><br><span class="line"><span class="string">    					   CORS配置允许跨域(服务端)</span></span><br><span class="line"><span class="string">    答案:</span></span><br><span class="line"><span class="string">    options请求，是跨域请求之前的预检查</span></span><br><span class="line"><span class="string">    浏览器自行发起的，无需我们干预</span></span><br><span class="line"><span class="string">    不会影响实际的功能</span></span><br><span class="line"><span class="string">12、如何检测JS内存泄漏?JS内存泄漏场景有哪些?</span></span><br><span class="line"><span class="string">	垃圾回收:JS引擎要做的事 </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">13、闭包是内存泄露</span></span><br><span class="line"><span class="string">     早期的 V8 中，由于闭包引用的变量被挂载了全局的大对象 windows 中，所以这一变量由老生代区采用标记清除算法进行回收。频繁的	垃圾回收会生成大量的内存碎片，所以也会导致内存泄漏问题。后来 v8 又采用了标记清除整理算法，以及增量回收、并行回收、并发回收等	垃圾回收技术，所以在新一代浏览器中，使用闭包几乎不会出现内存泄漏问题。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">14、浏览器和nodejs的事件循环有什么区别?</span></span><br><span class="line"><span class="string">	JS是单线程的</span></span><br><span class="line"><span class="string">	浏览器中JS执行和DOM渲染共用一个线程</span></span><br><span class="line"><span class="string">	异步分为:</span></span><br><span class="line"><span class="string">		宏任务，如setTimeout setInterval 网络请求</span></span><br><span class="line"><span class="string">        微任务，如promiseasyn.cLawait</span></span><br><span class="line"><span class="string">        微任务在下一轮DOM渲染（内容绘制到页面让用户看到）之前执行，宏任务在之后执行</span></span><br><span class="line"><span class="string">	先执行微任务的异步 再执行宏任务的异步</span></span><br><span class="line"><span class="string">15、Node.js异步</span></span><br><span class="line"><span class="string">    Nodejs 同样使用ES语法，也是单线程，也需要异步</span></span><br><span class="line"><span class="string">    异步任务也分∶宏任务＋微任务</span></span><br><span class="line"><span class="string">    但是，它的宏任务和微任务，分不同类型，有不同优先级</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">    执行同步代码</span></span><br><span class="line"><span class="string">    执行微任务( process.nextTick 优先级更高)</span></span><br><span class="line"><span class="string">    按顺序执行6个类型的宏任务（每个结束时都执行当前的微任务）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">答案:</span></span><br><span class="line"><span class="string">    浏览器和nodejs的event loop流程基本相同</span></span><br><span class="line"><span class="string">    nodejs宏任务和微任务分类型，有优先级</span></span><br><span class="line"><span class="string">16、vodm</span></span><br><span class="line"><span class="string">	用JS对象模拟DOM节点数据 由React最新推出</span></span><br><span class="line"><span class="string">    Vue Reacct框架的价值:1、组件化  2、数据视图分离，数据驱动视图 ---核心</span></span><br><span class="line"><span class="string">	vdom并不快，JS直接操作DOM才是最快的</span></span><br><span class="line"><span class="string">    但是是为了服务与“数据驱动视图”的开发思路，要有合适的技术方案，不能全部 DOM重建</span></span><br><span class="line"><span class="string">    vdom 就是目前最合适的技术方案（并不是因为它快，而是合适)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">vdom是数据驱动视图技术方案的技术实现而已</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/01/15/%E6%A0%A1%E6%8B%9B%E7%9B%B4%E9%80%9A%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/%E6%A0%A1%E6%8B%9B%E7%9B%B4%E9%80%9A%E8%BD%A6/" class="post-title-link" itemprop="url">前端知识强化总结</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-15T00:00:00+08:00">2021-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-20 00:00:00" itemprop="dateModified" datetime="2022-02-20T00:00:00+08:00">2022-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/15/%E6%A0%A1%E6%8B%9B%E7%9B%B4%E9%80%9A%E8%BD%A6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/15/%E6%A0%A1%E6%8B%9B%E7%9B%B4%E9%80%9A%E8%BD%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>什么是CSS继承 .CSS选泽器是什么?</span><br><span class="line">就是父级设置了一些属性，子级继承了父级的该属性	<span class="comment">//  CSS选择器用来对选定的页面元素进行样式修改。</span></span><br><span class="line"> 选择器有哪些？</span><br><span class="line">    类型选择器 </span><br><span class="line">    通配选择器  <span class="number">1</span></span><br><span class="line">    类选择器</span><br><span class="line">    id选择器</span><br><span class="line">    标签属性选择器</span><br><span class="line">    伪类选择器：a:link  :fist-child  <span class="number">10</span></span><br><span class="line">    伪元素选择器:placeholder ::before，::after  <span class="number">1</span></span><br><span class="line">    后代选择器</span><br><span class="line">    子代选择器</span><br><span class="line">  伪元素选择器添加了一个页面中没有的元素（只是从视觉效果上添加了，不是在文档树中添加），伪类是给页面中已经存在的元素添加一个类。</span><br><span class="line"><span class="number">2.</span>面试口诀:一绝三香(相)</span><br><span class="line">    px:		 绝对单位，网页开发基本长度单位</span><br><span class="line">    em:		 相对单位，相对当前盒子字体大小进行计算</span><br><span class="line">    rem:	 相对单位，相对根元素html字体大小进行计算</span><br><span class="line">    vw+vh:   相对单位，相对当前网页视口宽度和高度进行计算</span><br><span class="line">    </span><br><span class="line">    px em rem之间的转换关系</span><br><span class="line">        默认情况下<span class="number">1</span>rem = <span class="number">1</span>em = <span class="number">16</span>px</span><br><span class="line">        根元素字体修改情况下<span class="number">1</span>rem = 根元素字体大小</span><br><span class="line">		当前盒子字体修改情况下<span class="number">1</span>em = 当前盒子字体大小</span><br><span class="line">    em和rem的使用场景</span><br><span class="line">    o em:通常用于字体缩进  </span><br><span class="line">    o rem:配合媒体查询处理移动端适配问题   ***</span><br><span class="line"><span class="number">3.</span>css如何实现左边定宽，右边自适应</span><br><span class="line">    <span class="number">1</span>、将盒子外面的容器设为flex布局，右边盒子设置flex属性值为<span class="number">1</span> 这样就会自动撑满</span><br><span class="line">    <span class="number">2</span>、将盒子外面的容器设为table布局，将左右盒子的display都设置为table-cell</span><br><span class="line"><span class="number">4.</span>css实现绝对居中</span><br><span class="line">	<span class="number">1</span>、盒子容器设置相对定位，盒子设置绝对定位 top和left都设置<span class="number">50</span>% 之后再设置margin-left和margin-top为盒子大小的一半</span><br><span class="line">	<span class="number">2</span>、盒子容器设置相对定位，盒子设置绝对定位 四个方向（top、left、bottom、right都设置为<span class="number">0</span>），margin设置为auto即可</span><br><span class="line">    <span class="number">3</span>、盒子容器设置相对定位，盒子设置绝对定位 top和left都设置<span class="number">50</span>%  设置transform属性，属性值为translate(<span class="number">-50</span>%,<span class="number">-50</span>%)</span><br><span class="line">	<span class="number">4</span>、盒子容器flex布局，设置justify-content属性和align-items属性，属性值都设为center（内部盒子水平，垂直方向居中）</span><br><span class="line">justify-content设置主轴上的子元素排列方式</span><br><span class="line">align-items 设置侧轴上的子元素排列方式（单行）</span><br><span class="line">总结：前两种内部的盒子定宽高，后两种不定宽高</span><br><span class="line"><span class="number">5</span>、清除浮动的方法有哪些，各有什么缺点？</span><br><span class="line">	如下图  添加clear属性</span><br><span class="line">    原理: 设置清除浮动以后，浏览器会自动为元素添加一个上外边距， 以使其位置不受其他元素的影响。</span><br><span class="line">    清除浮动布局场景下的知识深度和广度? 深度：我们不仅可以实现清除浮动，还可以知道他们的优点和缺点，广度就是可以使用多种方式实现</span><br><span class="line"><span class="number">6</span>、如何用CSS画一个三角形？</span><br><span class="line">    css实现三角形的核心是用无宽高盒子的border</span><br><span class="line">    透明边框第一步四个方向全部透明边框，</span><br><span class="line">	箭头方向:第二步选择箭头方向,箭头指向和有色边框方向相反</span><br><span class="line">    border: <span class="number">10</span>px solid transparent;</span><br><span class="line">	border-left: 10px solid #f40;使用border去画三角形</span><br><span class="line">    场景就是淘宝上方导航栏的标题右上角都有一个小三角</span><br><span class="line">    border-bottom 代表箭头向上</span><br><span class="line">    border-top    代表箭头向下</span><br><span class="line">    border-left   代表箭头向右</span><br><span class="line">    border-right  代表箭头向左</span><br><span class="line">    第二种方法是创建一个盒子 将其设置为相对定位，盒子前添加一个伪元素设置成绝对定位，将其绕着左下顶点进行顺时针旋转<span class="number">45</span>度，父元素设置overflow:hidden属性将超出盒子外的部分进行裁剪就能形成一个三角形</span><br><span class="line">    说出为什么要用css画三角形的原因(出于页面性能考虑,避免发送过多的http请求,节省带宽)</span><br><span class="line"><span class="number">7</span>、css提高页面性能的方法有哪些?</span><br><span class="line">	<span class="number">1.</span>属性设置使用简写  （给margin设置四个方向的时候可以简写为 margin:上右下左）</span><br><span class="line">	<span class="number">2.</span>用CSS替换图片比如用css画一个三角形来替换图片   （避免发送过多的http请求,节省带宽）</span><br><span class="line">	<span class="number">3.</span>删除不必要的零和单位 （<span class="number">0.2</span>写成<span class="number">.2</span>   <span class="number">20.0</span>写成<span class="number">20</span>）</span><br><span class="line">	<span class="number">4.</span>用CSS精灵图替代单个文件加载（利用背景定位在CSS精灵图拿到自己想要的图标（一个请求） ，项目加载的时候就要发送http请求，）</span><br><span class="line">    </span><br><span class="line">    <span class="number">1.</span>属性简写目的:减小生产包体积</span><br><span class="line">    <span class="number">2.</span>图标替换目的:减少http请求/节约带宽</span><br><span class="line">    <span class="number">3.</span>删除零和单位目的:减小生产包体积</span><br><span class="line">    <span class="number">4.</span>背景图使用雪碧图目的:减少http请求/节约带宽</span><br><span class="line"><span class="number">8</span>、BFC解决了哪些问题(BFC:一块独立渲染区域，内部元素的渲染不会影响边界以外的元素)</span><br><span class="line">    <span class="number">1.</span>垂直方向外边距重叠的问题。</span><br><span class="line">    <span class="number">2.</span>子元素浮动，父元素高度塌陷问题。</span><br><span class="line">    触发BFC:</span><br><span class="line">        浮动元素：float 除 none 以外的值  有局限性：高度不塌了但是脱离文档流了，宽度也就丢失了，对应特点的第三条 -不推荐</span><br><span class="line">        绝对定位元素：position (absolute、fixed)</span><br><span class="line">        display 为 inline-block、table-cells、flex -不推荐  设置弹性布局</span><br><span class="line">        overflow 除了 visible 以外的值 (hidden、auto、scroll) -推荐</span><br><span class="line">    开启BFC后的特点：</span><br><span class="line">        <span class="number">1.</span>开启BFC的元素不会被浮动元素所覆盖</span><br><span class="line">        <span class="number">2.</span>开启BFC的元素子元素和父元素外边距不会重叠 </span><br><span class="line">        <span class="number">3.</span>开启BFC的元素可以包含浮动的子元素</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112211616905.png" alt="image-20211221161602539"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112211623284.png" alt="img"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112211955650.png" alt="image-20211221195541177"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112212000481.png" alt="image-20211221200057153"></p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>、为什么把bind，call，apply放在一起？有什么区别（相同点，不同点）  干什么的?:用来改变<span class="keyword">this</span>的指向的</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'fff'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">'ddd'</span></span><br><span class="line">        log(<span class="string">'this.name'</span>,<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">	say() <span class="comment">//输出的是fff  因为say相当于window.say()</span></span><br><span class="line">	相同点:bind，call，apply都可以改变<span class="keyword">this</span>指向</span><br><span class="line">	不同点:call和apply的传参方式不同(前者挨个传，后者传入一个数组)/bind(返回的是绑定<span class="keyword">this</span>一个函数)和call，apply的返回值不同</span><br><span class="line">    																		apply、call 则是返回函数调用立即执行</span><br><span class="line">#三、实现</span><br><span class="line">call的应用场景   </span><br><span class="line">*判断数据类型 </span><br><span class="line">	<span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">const</span> type = <span class="number">0</span>bject.prototype.toString.call(array);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'type'</span>, type)<span class="comment">//[object,Array]</span></span><br><span class="line">*类数组转数组</span><br><span class="line">	<span class="keyword">const</span> arrayLike=&#123;</span><br><span class="line">        <span class="number">0</span>:<span class="string">'name'</span>,</span><br><span class="line">        <span class="number">1</span>:<span class="string">'age'</span>,</span><br><span class="line">        <span class="number">2</span>:<span class="string">'gender'</span>,</span><br><span class="line">        length:<span class="number">3</span></span><br><span class="line">    &#125;<span class="comment">//以上就是类数组 看似数组，本身不是数组</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Array</span>.prototype.slice.call(arrayLike) <span class="comment">//['name','age','gender']</span></span><br><span class="line"></span><br><span class="line">apply 应用场景</span><br><span class="line">对给定数组求最大值/最小值</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,array)<span class="comment">//null为this的指向  输出结果为5  min为最小值</span></span><br><span class="line"></span><br><span class="line">bind应用场景</span><br><span class="line">通常用在react项目的组件中</span><br><span class="line">利用bind函数将<span class="keyword">this</span>的指向指向组件的实例 </span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、如何使用多种方式实现数组去重  分普通数组和对象数组</span><br><span class="line">	array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">	indexOf 查找项的下标 没找到<span class="number">-1</span></span><br><span class="line">	filter 返回值[]</span><br><span class="line">	sort   返回值[]  接收两个参数 返回a-b 从小到大排序</span><br><span class="line">	reduce 返回值[] <span class="keyword">const</span> res = array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,current</span>)</span>&#123;<span class="keyword">return</span> prev+current&#125;)<span class="comment">//不断更新prev 输出15</span></span><br><span class="line">	push   返回值length</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">过滤解决</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">Array</span>.isArray(array))&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"unique function params is not Array"</span>)&#125;	</span><br><span class="line">	<span class="keyword">return</span> array.filter(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> array.index0f(item)===index <span class="comment">//当拿到倒数第二个2的时候获取的下标是第二个2的下标，就会将其过滤</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = unique(array) <span class="comment">//输出的是[1,2,3,4,5] 实现去重</span></span><br><span class="line"></span><br><span class="line">排序解决</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(array))&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"unique function params is not Array"</span>)&#125;	</span><br><span class="line">	array = array.sort()  <span class="comment">//先进行排序</span></span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]!==array[i<span class="number">-1</span>])&#123;</span><br><span class="line">            res.push(array[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = unique(array) <span class="comment">//输出的是[1,2,3,4,5] 实现去重</span></span><br><span class="line"></span><br><span class="line">解构赋值解决 (先转化为集合 集合里的元素就已经是唯一的了 然后再解构赋值)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(array))&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"unique function params is not Array"</span>)&#125;	</span><br><span class="line">	<span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)]</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = unique(array) <span class="comment">//输出的是[1,2,3,4,5] 实现去重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span>怎么对给定数组求最大值</span><br><span class="line">应用场景:数据处理的时候可以用到给定数组求最大值</span><br><span class="line"><span class="built_in">Math</span>.max()方法</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] </span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Math</span>.max(...array)  ***</span><br><span class="line">或者借用这个函数  <span class="keyword">const</span> res = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,array)</span><br><span class="line"></span><br><span class="line">reduce函数方法</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMax</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">prev,current</span>)=&gt;</span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> current&gt;prev?current : prev	</span><br><span class="line">        或者<span class="keyword">return</span>  <span class="built_in">Math</span>.max(prev,current)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = getMax(array)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort()排序方法</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">getMax</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = array.sort()</span><br><span class="line">    <span class="keyword">return</span> result[result.length<span class="number">-1</span>] <span class="comment">//数组的最后一项</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = getMax(array)</span><br><span class="line">考察的是对基本的数据处理能力</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span>JS中判断数据类型的方式有哪些？</span><br><span class="line"><span class="keyword">typeof</span></span><br><span class="line">优点:使用简单  也不精确 比如 <span class="keyword">typeof</span> [] 会输出<span class="built_in">Object</span>(数组本身就)</span><br><span class="line">缺点:功能残缺，只能用来判断<span class="number">6</span>种数据类型:string,number,boolean,<span class="literal">undefined</span>,symbol,<span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">of</span> <span class="title">null</span>  <span class="title">symbol</span> 的值是通过 <span class="title">Symbol</span>(<span class="params"></span>) 函数生成，每一个 <span class="title">symbol</span> 的值都是唯一的</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Object</span>.<span class="title">prototype</span>.<span class="title">toString</span>.<span class="title">call</span></span></span><br><span class="line"><span class="function">优点:适用于判断所有数据类型</span></span><br><span class="line"><span class="function">缺点:使用上相对<span class="title">typeof</span>而言比较繁琐</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">instanceof</span>(<span class="params">排除</span>):<span class="title">instanceof</span>运算符用于检测构造函数的<span class="title">prototype</span>属性是否出现在某个实例对象的原型链上</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">js</span>中判断数据类型的场景?</span></span><br><span class="line"><span class="function">根据接口/返回参数类型/做区别处理。</span></span><br><span class="line"><span class="function"><span class="title">js</span>中的数据类型有些哪些?</span></span><br><span class="line"><span class="function">基本数据类型:<span class="title">String</span>、<span class="title">Number</span>、<span class="title">Boolean</span>、<span class="title">Symbol</span>、<span class="title">undefined</span>、<span class="title">Null</span></span></span><br><span class="line"><span class="function">引用数据类型:<span class="title">Object</span>、<span class="title">Array</span>、<span class="title">Function</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">13.如何实现函数节流 （项目优化）</span></span><br><span class="line"><span class="function">	函数节流:规定在一个单位时间内，事件响应函数只能被触发一次。如果这个单位时间内触发多次函数，只有一次生效</span></span><br><span class="line"><span class="function">	使用场景:<span class="title">window</span>.<span class="title">onresize</span>事件  该事件是浏览器的视口不断被放大缩小的时候触发的</span></span><br><span class="line"><span class="function">    		<span class="title">mousemove</span>事件，鼠标拖动事件  </span></span><br><span class="line"><span class="function">            这两个事件不断别触发 导致性能开销过大 因此要使用函数节流</span></span><br><span class="line"><span class="function"><span class="title">window</span>.<span class="title">onresize</span>(<span class="params"></span>):函数节流</span></span><br><span class="line"><span class="function">  单位时间内触发一次</span></span><br><span class="line"><span class="function">  1.返回值是一个函数</span></span><br><span class="line"><span class="function">  2.开启定时器</span></span><br><span class="line"><span class="function">  3.如果定时器存在，直接返回<span class="title">false</span></span></span><br><span class="line"><span class="function">  4.定时器内部清空定时器，并且把<span class="title">timer</span>置为<span class="title">null</span> 然后执行我们的事件响应函数</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">throttle</span>(<span class="params">fn,interval</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timer;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">        	<span class="keyword">if</span> (timer)&#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">           		 clearTimeout(timer);</span><br><span class="line">        		 timer = <span class="literal">null</span>;</span><br><span class="line">        		fn(event)&#125;, </span><br><span class="line">            interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>))</span>&#123;</span><br><span class="line">    log(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的fn 指的就是(function(event))&#123;log(event)&#125; 本身没有返回值 所以上面调用的时候要return一个函数 把fn放在函数里执行的话就是输出log</span></span><br><span class="line"></span><br><span class="line"><span class="number">14.</span>如何实现函数防抖	</span><br><span class="line">事件防抖:事件被触发n秒后再执行回调，如果在这n秒执行过程中又被触发，则会把之前的事件响应清除掉，事件函数只执行一次。</span><br><span class="line">使用场景：网站商品搜索框</span><br><span class="line"><span class="number">1.</span>返回值是一个函数</span><br><span class="line"><span class="number">2.</span>事件响应函数式在固定间隔试行的</span><br><span class="line">&lt;input type=<span class="string">"text"</span> id = <span class="string">"searchElement"</span>&gt;</span><br><span class="line"><span class="keyword">const</span>  SearchElement = <span class="built_in">document</span>.getElementById(<span class="string">"searchElement"</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;.</span><br><span class="line">		clearTimeout(timer)</span><br><span class="line">		timer = setTimeout(fn,delay)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">SearchElement.oninput = debounce(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>))</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = searchElement.value</span><br><span class="line">    log(<span class="string">'value'</span>,value)</span><br><span class="line">,<span class="number">1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">15.</span>如何使用多种方式实现数组拍平</span><br><span class="line">概念 :数组拍平也叫数组扁平化、数组拉平、数组降维。**指的是把多维数组变成一维数组**。</span><br><span class="line">使用场景:复杂场景下的数据处理</span><br><span class="line">实现数组拍平的具体实现：</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,[<span class="number">7</span>,<span class="number">8</span>]]] <span class="comment">//多维数组</span></span><br><span class="line">array  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]; <span class="comment">//实现的结果</span></span><br><span class="line"><span class="number">1.</span>使用reduce实现</span><br><span class="line"><span class="comment">//reduce </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,current</span>)</span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(current)?flatten(current):current)   <span class="comment">//如果是就递归调用</span></span><br><span class="line">&#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = flatten(array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`result`</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ES6的flat函数  在vscode执行不了  在Chorme浏览器（默认支持ES6语法）的控制台可以 ，因为vscode没有兼容ES6的语法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.flat(<span class="literal">Infinity</span>); <span class="comment">//Infinity是长度无限展平</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = flatten(array)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`result`</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (array.some(<span class="built_in">Array</span>.isArray))&#123;  <span class="comment">//只要数组里是个数组就会进while循环</span></span><br><span class="line">    array = [].concat(...array)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1 array </span></span><br><span class="line">  <span class="comment">// 2 已经被拍平</span></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = flatten(array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`result`</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span>什么情况会使判断成立</span><br><span class="line">    <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>,<span class="string">'a'</span>,&#123;  <span class="comment">// Object.defineProperty给目标对象挂载属性并且拿值的操作</span></span><br><span class="line">      <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> value += <span class="number">1</span>;   <span class="comment">//return的值就是a的值  每获取一次a,value都会加1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> <span class="keyword">if</span>(a===<span class="number">1</span>&amp;&amp;a===<span class="number">2</span>&amp;&amp;a===<span class="number">3</span>)&#123;  <span class="comment">//每一次判断都会拿一下a的值，a的值是递加的 是定义在window对象的</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`object`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">17.</span>实现<span class="keyword">new</span>操作符</span><br><span class="line">实际使用场景:封装第三方的工具(通过构造函数进行封装)</span><br><span class="line"> <span class="keyword">const</span> TMap = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">  <span class="keyword">this</span>.address = options.address;</span><br><span class="line">     <span class="keyword">return</span>&#123;</span><br><span class="line">         name:<span class="string">'map'</span>,</span><br><span class="line">         address:<span class="string">'SZ'</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> map  = <span class="keyword">new</span> TMap(&#123;</span><br><span class="line">   name: <span class="string">'tmap'</span>,</span><br><span class="line">   address:<span class="string">"BJ"</span></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'map :&gt;&gt; '</span>, map);  <span class="comment">//返回的是SZ  </span></span><br><span class="line">使用<span class="keyword">new</span>操作符实例化后的对象有两种情况:如果构造函数里没有返回值的话，实例化对象输出的就是构造函数里的实例属性和方法 BJ</span><br><span class="line">					 			如果构造函数里有返回值的话，实例化对象就是那个返回值 SZ</span><br><span class="line">如何实现<span class="keyword">new</span>操作符 -&gt;难先不看</span><br><span class="line"></span><br><span class="line"><span class="number">18.</span>实现一个bind函数</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">origin</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log([a,b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name:<span class="string">"freemen"</span></span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">const</span> func = origin.bind(obj,<span class="number">2</span>); <span class="comment">//改变this的指向 不然是指向window且返回的是一个函数</span></span><br><span class="line"> func(<span class="number">1</span>) <span class="comment">// 输出Freeman [2,1]</span></span><br><span class="line">**模拟一个bind函数** 难先不看</span><br><span class="line">bind函数的实现原理</span><br><span class="line"><span class="number">1.</span> bind 函数改变<span class="keyword">this</span>指向</span><br><span class="line"><span class="number">2.</span> bind 函数是<span class="built_in">Function</span>.prototype上的方法</span><br><span class="line"><span class="number">3.</span> bind 函数的返回值也是函数</span><br><span class="line"><span class="number">4.</span> bind 函数调用之后返回的函数的参数同样也接收处理</span><br><span class="line"></span><br><span class="line">如何实现call和apply函数</span><br><span class="line">apply入参方式是以数组传递的  实现也很难先不看</span><br><span class="line">     call</span><br><span class="line">    <span class="number">1.</span>改变<span class="keyword">this</span>指针</span><br><span class="line">    <span class="number">2.</span>返回函数调用</span><br><span class="line">    <span class="number">3.</span>参数挨个依次传递</span><br><span class="line">     apply</span><br><span class="line">    <span class="number">1.</span>改变<span class="keyword">this</span>指针</span><br><span class="line">    <span class="number">2.</span>返回函数调用</span><br><span class="line">    <span class="number">3.</span>数组方式传参</span><br><span class="line"></span><br><span class="line"><span class="number">19.</span>实现<span class="keyword">instanceof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Persion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"freemen"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Persion</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Persion)<span class="comment">//输出true</span></span><br><span class="line"><span class="keyword">instanceof</span> 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">Obj, Constructor</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> implicitPrototype = Obj.__proto__;  <span class="comment">// 获取实例对象的隐式原型</span></span><br><span class="line">  <span class="keyword">let</span> displayPrototype = Constructor.prototype; <span class="comment">// 获取构造函数的prototype 属性</span></span><br><span class="line">  <span class="comment">// while 循环 -&gt; 在原型链上不断向上查找</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="comment">// 直到 implicitPrototype = null 都没找到, 返回false</span></span><br><span class="line">      <span class="keyword">if</span>(implicitPrototype === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 构造函数的 prototype 属性出现在实例对象的原型链上 返回 true</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (implicitPrototype === displayPrototype)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在原型链上不断查找 构造函数的显式原型</span></span><br><span class="line">      implicitPrototype = implicitPrototype.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> has = instance_of(obj,Persion)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`has`</span>, has)</span><br><span class="line"></span><br><span class="line">实现原理:</span><br><span class="line"><span class="number">1.</span> 获取实例对象的隐式原型</span><br><span class="line"><span class="number">2</span>．获取构造函数的prototype属性</span><br><span class="line"><span class="number">3.</span> <span class="keyword">while</span> 循环-&gt;在原型链上不断向上查找</span><br><span class="line"><span class="number">4.</span> 在原型链上不断查找构造函数的显式原型</span><br><span class="line"><span class="number">5</span>，直到实例对象的隐式原型 = <span class="literal">null</span>都没找到,返回<span class="literal">false</span></span><br><span class="line"><span class="number">6</span>．构造函数的prototype属性出现在实例对象的原型链上返回<span class="literal">true</span> (构造函数的显式原型===实例对象的隐式原型)</span><br><span class="line"></span><br><span class="line"><span class="number">20.</span>总结:</span><br><span class="line"><span class="number">1</span>、什么是原型和原型链?</span><br><span class="line"><span class="number">1.</span>什么是原型</span><br><span class="line">在javascript中，函数可以有属性。每个函数都有一个特殊的属性叫作原型(prototype)</span><br><span class="line">每个对象都会在其内部初始化一个属性，就是prototype(原型)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>什么是原型链</span><br><span class="line">原型链就是当我们访问对象的某个属性或方法时，如果在当前对象中找不到定义，会继续在当前对象的原型对象中查找，如果原型对象中依然没有找到，会继续在原型对象的原型中查找（原型也是对象，也有它自己的原型)如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回<span class="literal">undefined</span>。可以看出，这个查找过程是一个链式的查找，每个对象都有一个到它自身原型对象的链接，这些链接组件的整个链条就是原型链</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>·原型和原型链存在的意义是什么?</span><br><span class="line">**使得实例对象可以共享构造函数原型上属性和方法**，节省内存。构造函数原型上的属性和方法越多，节省内存越大.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>如何理解作用域和作用域链?</span><br><span class="line">讲清楚如下三点:</span><br><span class="line"><span class="number">1.</span>什么是作用域?</span><br><span class="line">作用域是在运行时代码中的某些特定部分中**变量，函数和对象的可访问性**，作用域决定了代码区块中变量和其他资源的可见性。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>作用域存在的意义是什么?  **不同作用域下同名变量不会有冲突。**</span><br><span class="line">作用域存在的最大意义就是变量隔离即:        </span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>什么是作用域链?</span><br><span class="line">当我们在某个函数的内部作用域中查找某个变量时，如果没有找到就会到他的父级作用域中查找，如果父级也没找到就会接着一层一层的向上寻找，直到找到全局作用域还是没找到的话，就宣布放弃。这种一层一层的作用域嵌套关系，就是作用域链</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、你对闭包怎么理解?</span><br><span class="line">讲清楚如下三点:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>什么是闭包?</span><br><span class="line">**一个函数作用域能够访问另外一个函数作用域中的变量的函数**</span><br><span class="line">**闭包:自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方!!!**</span><br><span class="line">bind方法只有在<span class="built_in">Function</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>闭包有哪些实际的使用场景? </span><br><span class="line">    <span class="number">1.</span>事件函数的封装</span><br><span class="line">    <span class="number">2.</span>用闭包模拟私有方法</span><br><span class="line">    <span class="number">3.</span>在循环中给页面元素绑定事件响应函数</span><br><span class="line">使用闭包主要为了设计私有的方法和变量</span><br><span class="line"><span class="number">3.</span>闭包存在什么问题?</span><br><span class="line">好处是可以延伸这个变量的使用范围   缺点:闭包本身会造成内部变量常驻内存，会增大内存使用量，使用不当很容易造成内存泄露</span><br><span class="line">原因就是在函数执行结束之后不会将变量进行销毁</span><br></pre></td></tr></table></figure>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">let</span>、<span class="keyword">const</span>和<span class="keyword">var</span>的区别  </span><br><span class="line">   <span class="number">1</span> 不存在变量提升</span><br><span class="line">   <span class="number">2</span> 块级作用域:不会像<span class="keyword">var</span>一样先变量提升显示<span class="literal">undefined</span>，会直接拿去全局的变量</span><br><span class="line">   <span class="number">3</span> 暂时性死区:在块级作用域里面，声明变量的时候不能提前给它赋值</span><br><span class="line">   <span class="number">4</span> 不可重复声明 <span class="keyword">let</span> a = <span class="string">'10'</span>  <span class="keyword">let</span> a = <span class="string">'20'</span> 语法错误</span><br><span class="line">   <span class="number">5</span> <span class="keyword">let</span> 和 <span class="keyword">const</span>声明的变量不会挂在在全局<span class="built_in">window</span>对象下面</span><br><span class="line"> 	 <span class="comment">// var fullName ='freemen';</span></span><br><span class="line">    <span class="comment">// console.log(`window`, window.fullName) undefined</span></span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">30</span>      这是不会报错的 因为不是在同一个作用域</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span>能够对一个变量进行多次声明</span><br><span class="line">存在变量提升 </span><br><span class="line">在函数中使用使用<span class="keyword">var</span>声明变量时候，该变量是局部的    而如果在函数内不使用<span class="keyword">var</span>，该变量是全局的</span><br><span class="line">**修改声明的变量**</span><br><span class="line"><span class="keyword">var</span>和<span class="keyword">let</span>可以 <span class="keyword">const</span>声明一个只读的常量。一旦声明，常量的值就不能改变</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>声明之后必须马上赋值,否则会报错</span><br><span class="line"><span class="keyword">const</span>声明的简单类型不可更改，复杂类型内部数据可以更改 例如 <span class="keyword">const</span> fullName = [<span class="string">'freeman'</span>]  fullName[<span class="number">1</span>] = <span class="string">'mkw'</span> 不会报错</span><br><span class="line">能用<span class="keyword">const</span>的情况尽量使用<span class="keyword">const</span>，其他情况下大多数使用<span class="keyword">let</span>，避免使用<span class="keyword">var</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>箭头函数和普通函数的区别</span><br><span class="line">    <span class="number">1</span>、箭头函数的<span class="keyword">this</span>指向父级作用域的<span class="keyword">this</span></span><br><span class="line">    <span class="number">2</span>、call()/.apply()/.bind()无法改变箭头函数中<span class="keyword">this</span>的指向</span><br><span class="line">    <span class="number">3</span>、不可以被当作构造函数</span><br><span class="line">    <span class="number">4</span>、不可以使用<span class="built_in">arguments</span>对象  是一个对应于传递给函数的参数的类数组对象。</span><br><span class="line">关于第四点 普通函数</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        log(<span class="string">'args'</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">	sayName(<span class="string">'a'</span>,<span class="string">'b'</span>) <span class="comment">// 输出的是args可以接收传来的参数为a，b</span></span><br><span class="line">换成箭头函数， 报错<span class="built_in">arguments</span>没有定义  而箭头函数接收args参数 <span class="keyword">const</span> sayName = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;.....&#125;  </span><br><span class="line"><span class="number">1</span>、在函数调用中，<span class="keyword">this</span>的指向指向调用它的对象</span><br><span class="line"><span class="number">2</span>、在构造函数中，<span class="keyword">this</span>指向指向实例化对象</span><br><span class="line"><span class="number">3</span>、在事件体中，<span class="keyword">this</span>指向事件源</span><br><span class="line"><span class="number">4</span>、箭头函数的<span class="keyword">this</span>指向父级作用域的<span class="keyword">this</span></span><br><span class="line"><span class="number">5</span>、其他情况(声明式，赋值式的函数)，<span class="keyword">this</span>指向<span class="built_in">window</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>ES6哪个方法可以实现数组去重</span><br><span class="line">	采用ES6中<span class="built_in">Array</span>.from配合<span class="keyword">new</span> <span class="built_in">Set</span></span><br><span class="line">    <span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">	<span class="keyword">const</span> result =  <span class="keyword">new</span> <span class="built_in">Set</span>(array) <span class="comment">//返回的是一个&#123;&#125;  //数组去重console.log(`result`, [...new Set(array)])</span></span><br><span class="line">    我们需要array.from</span><br><span class="line">	<span class="keyword">const</span> result = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array))<span class="comment">//将一个类数组对象转化为数组对象  =&gt;只能对基本类型的值的数组进行去重</span></span><br><span class="line">    如果是一个对象是不能实现去重</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>ES6实例对象新增的方法对象新增的方有哪些？</span><br><span class="line">	<span class="number">1</span> <span class="built_in">Object</span>.is()   =&gt;判断两个值是否相同</span><br><span class="line">        <span class="keyword">const</span> numOne = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> numTwo = <span class="string">'1'</span>;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Object</span>.is(numOne,numTwo);<span class="comment">//false</span></span><br><span class="line">  		<span class="keyword">const</span> result = <span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>);</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">`result`</span>, result);<span class="comment">//true</span></span><br><span class="line"> 	特点： <span class="number">1</span> 不仅可以对值类型进行正常处理而且对象类型的值也可以进行判断</span><br><span class="line">    	  <span class="number">2</span> 对于特殊的值 <span class="literal">NaN</span> 也可以进行正常的处理</span><br><span class="line">    <span class="number">2.</span><span class="built_in">Object</span>.assign()=&gt;两个对象进行合并</span><br><span class="line">        <span class="keyword">const</span> obj = &#123;</span><br><span class="line">               name:<span class="string">"freemen"</span></span><br><span class="line">             &#125;</span><br><span class="line">        <span class="keyword">const</span> objTwo = &#123;</span><br><span class="line">              age: <span class="number">18</span></span><br><span class="line">             &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Object</span>.assign(obj,objTwo);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`result`</span>, result)<span class="comment">//&#123;  name:"freemen"， age: 18&#125;</span></span><br><span class="line">    <span class="number">3.</span><span class="built_in">Object</span>.keys()=&gt;返回一个数组，目标对象的所有可遍历属性的键名</span><br><span class="line">		<span class="keyword">const</span> object = &#123;</span><br><span class="line">       		name:<span class="string">"freemen"</span>,</span><br><span class="line">       		age:<span class="number">18</span></span><br><span class="line">     	&#125;</span><br><span class="line">    	<span class="keyword">const</span> result = <span class="built_in">Object</span>.keys(object);</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">`result`</span>, result);<span class="comment">//['name','age']</span></span><br><span class="line">    <span class="number">4.</span><span class="built_in">Object</span>.values()=&gt;返回一个数组，目标对象的所有可遍历属性的键值 [<span class="string">'freemen'</span>,<span class="string">'18'</span>]</span><br><span class="line">    <span class="number">5.</span><span class="built_in">Object</span>.entries ()=&gt;返回一个键值对数组（keys和values的结合）<span class="comment">//['name','freemen'] ['age','18']</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="class"><span class="keyword">class</span>和<span class="title">function</span>的区别</span></span><br><span class="line">	 //相同点:</span><br><span class="line">    <span class="comment">// 都可以用作构造函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Persion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="string">"freemen"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.fullName = <span class="string">"freemen"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> object = <span class="keyword">new</span> Persion</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`object`</span>, object)</span><br><span class="line">返回的都是Persion&#123;</span><br><span class="line">    fullname:<span class="string">'freemen'</span>,</span><br><span class="line">    [Prototype]:<span class="built_in">Object</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 不同点:</span></span><br><span class="line">    <span class="comment">// * class 不可以使用 call apply bind 的方式来改变他的执行上下文   </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`this.fullName`</span>, <span class="keyword">this</span>.fullName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.fullName = <span class="string">"freemen"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      fullName: <span class="string">"freemen"</span></span><br><span class="line">    &#125;</span><br><span class="line">    Persion.call(obj)<span class="comment">//  普通函数this.fullName freemen  class函数不可以类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>你对promise了解多少  <span class="built_in">Promise</span>对象中的then方法，可以接收构造函数中处理的状态变化</span><br><span class="line">定义：是一种异步编程的一种解决方案。比传统的解决方案--回调函数和事件--更合理和更强大 </span><br><span class="line">基本使用</span><br><span class="line">    <span class="comment">// 3 个状态  pending正在进行中  fulfilled成功  rejected 失败</span></span><br><span class="line">     <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> fullName = <span class="string">"freemen"</span>;</span><br><span class="line">        <span class="keyword">if</span>(fullName===<span class="string">'Vinko'</span>)&#123;</span><br><span class="line">          resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          reject(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">`resolve - value`</span>, value)</span><br><span class="line">     &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">`reject - value`</span>, value)  <span class="comment">//输出这个</span></span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">原型方法 </span><br><span class="line">    **<span class="built_in">Promise</span>.prototype.then**</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> fullName = <span class="string">"freemen"</span>;</span><br><span class="line">       <span class="keyword">if</span>(fullName===<span class="string">"freemen"</span>) &#123;</span><br><span class="line">          resolve(<span class="number">1</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          reject(<span class="number">2</span>) </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`fulfilled value`</span>, value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">fulfilledValue</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`fulfilled value`</span>, fulfilledValue)</span><br><span class="line">    &#125;,(rejectedValue)=&gt;&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`rejectedValue`</span>, rejectedValue)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  	<span class="number">1</span> 可以支持链式调用</span><br><span class="line">    <span class="number">2</span> then 接受两个参数且都是函数  </span><br><span class="line">    第一个函数是我们promise 状态变成fullfilled 时候的回调函数   成功的回调</span><br><span class="line">    第二个函数是我们promise 状态变成rejected时候的回调函数 	 失败的回调</span><br><span class="line">    <span class="number">3</span> 返回值也是<span class="built_in">Promise</span>(新的)</span><br><span class="line">    **<span class="built_in">Promise</span>.prototype.catch**</span><br><span class="line">		捕获<span class="built_in">Promise</span>错误</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">               <span class="keyword">let</span> fullName = <span class="string">"freemen"</span>;</span><br><span class="line">               <span class="keyword">if</span>(fullName===<span class="string">"Vinko"</span>) &#123;</span><br><span class="line">                  resolve(<span class="number">1</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  reject(<span class="string">'promise error'</span>)</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`value`</span>, value)</span><br><span class="line">            &#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`error`</span>, error)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    **<span class="built_in">Promise</span>.prototype.finally**</span><br><span class="line">		用于指定**不管 <span class="built_in">Promise</span> 对象最后状态如何，都会执行的操作*</span><br><span class="line"></span><br><span class="line">实例方法</span><br><span class="line">    **<span class="built_in">Promise</span>.all**</span><br><span class="line">    	<span class="comment">//用于将多个Promise实例包装成一个新的Promise实例</span></span><br><span class="line">        <span class="keyword">const</span> promiseArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">                resolve(item);<span class="comment">//包含多个promise实例的数组对象</span></span><br><span class="line">              &#125;) </span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">Promise</span>.all(promiseArray).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`res`</span>, res) <span class="comment">//res [1,2,3,4,5]</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    **<span class="built_in">Promise</span>.race**</span><br><span class="line">  	<span class="comment">// Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</span></span><br><span class="line">    <span class="comment">// Promise.race 和 Promise.all 区别 </span></span><br><span class="line">    <span class="comment">// Promise.race 继发 只要有一个状态发生改变就拿这个结果作为回调函数的值（res）来执行</span></span><br><span class="line">    <span class="comment">// Promise.all  并发 每一个promise状态都发生改变的时候才拿这个结果</span></span><br><span class="line">    <span class="keyword">const</span> promiseArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(item)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">Promise</span>.race(promiseArray).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`res`</span>, res)<span class="comment">//res 1</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    **<span class="built_in">Promise</span>.resolve**</span><br><span class="line">   <span class="comment">// Promise.resolve  将现有对象转化成Promise 对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">`loading start...`</span>)</span><br><span class="line">       <span class="keyword">let</span> fullName = <span class="string">"freemen"</span>;</span><br><span class="line">       <span class="keyword">if</span>(fullName===<span class="string">"freemen"</span>) &#123;</span><br><span class="line">          resolve(<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              reject(<span class="string">'promise error'</span>)</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`res`</span>, res) <span class="comment">//res为1</span></span><br><span class="line">        &#125;)</span><br><span class="line">=&gt;等价于</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`res`</span>, res)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    **<span class="built_in">Promise</span>.reject**</span><br><span class="line">    <span class="comment">// Promise.reject  返回一个Promise实例 -&gt; 实例的状态rejected</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">`loading start...`</span>)</span><br><span class="line">       <span class="keyword">let</span> fullName = <span class="string">"freemen"</span>;</span><br><span class="line">       <span class="keyword">if</span>(fullName===<span class="string">"Vinko"</span>) &#123;</span><br><span class="line">          resolve(<span class="number">1</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          reject(<span class="string">'promise error'</span>)</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`res`</span>, res)</span><br><span class="line">        &#125;,rejected=&gt;&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`rejected`</span>, rejected) <span class="comment">//rejected promise error</span></span><br><span class="line">        &#125;)</span><br><span class="line"> =&gt;等价于       </span><br><span class="line">	<span class="built_in">Promise</span>.reject(<span class="string">'promise error'</span>).then(<span class="literal">null</span>,rejected=&gt;&#123; <span class="comment">//reject状态的回调函数是我们then函数的第二个参数</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`rejected`</span>, rejected)<span class="comment">//rejected promise error</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="number">7.</span>扩展运算符的实现原理</span><br><span class="line">	<span class="keyword">const</span> baseArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">const</span> array = [...baseArray]</span><br><span class="line">    ==&gt;实现原理</span><br><span class="line">	<span class="keyword">var</span> baseArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">	<span class="keyword">var</span> array  = [].concat(baseArray)</span><br><span class="line"><span class="number">8.</span>forEach, <span class="keyword">for</span>...in, <span class="keyword">for</span>...of之间的区别? </span><br><span class="line"><span class="number">1</span>、forEach是数组的方法</span><br><span class="line"><span class="number">1.</span>遍历的时候更加简洁，效率和<span class="keyword">for</span>循环相同，不用关心集合下标的问题，减少了出错的概率。</span><br><span class="line"><span class="number">2.</span>没有返回值</span><br><span class="line"><span class="number">3.</span>不能使用<span class="keyword">break</span>中断循环，不能使用<span class="keyword">return</span>返回到外层函数</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="keyword">for</span>...in用于可枚举数据，如对象、数组、字符串 得到key</span><br><span class="line"><span class="number">3</span>、<span class="keyword">for</span>...of用于可迭代数据、如数组、字符串、<span class="built_in">Map</span>、<span class="built_in">Set</span> 得到value</span><br></pre></td></tr></table></figure>
<h3 id="React全家桶"><a href="#React全家桶" class="headerlink" title="React全家桶"></a>React全家桶</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>react父子组件如何通信</span><br><span class="line">父组件=&gt;子组件 </span><br><span class="line">	<span class="number">1.</span>Props</span><br><span class="line">    <span class="number">2.</span>Prototype Methods 原型方法</span><br><span class="line">子组件=&gt;父组件   也是通过props传递，只不过前提是要求父组件提前给子组件传递一个函数</span><br><span class="line">	<span class="number">1.</span>Callback Functions 回调函数</span><br><span class="line">    <span class="number">2.</span>Event Bubbling 事件冒泡=&gt;浏览器的事件传输机制 点击内部元素的时候一层一层的冒泡 会触发子组件的父元素的事件响应函数</span><br><span class="line">    <span class="keyword">const</span> Child()=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        &lt;button&gt;click&lt;button&gt;  <span class="comment">//点击按钮触发下面的div的onClick事件 利用浏览器的事件传输机制 点击内部元素的时候一层一层的									冒泡 会触发子组件的父元素的事件响应函数</span></span><br><span class="line">        );&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log( <span class="string">"clicked "</span> )</span><br><span class="line">    &#125;</span><br><span class="line">    render(</span><br><span class="line">    	<span class="keyword">return</span> (</span><br><span class="line">    	&lt;div onClick=&#123;<span class="keyword">this</span>. handleClick&#125;&gt;</span><br><span class="line">            &lt;Child/&gt; </span><br><span class="line">    	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">2.react中的setState是同步还是异步  在执行层面和本质层面进行剖析</span></span><br><span class="line"><span class="regexp">**执行层面**</span></span><br><span class="line"><span class="regexp">同步:原生事件onclick、setTimeout</span></span><br><span class="line"><span class="regexp">异步:react合成事件、生命周期钩子函数</span></span><br><span class="line"><span class="regexp">**本质层面**</span></span><br><span class="line"><span class="regexp">本质:本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致他们没法立马拿到更新后的值，形式了所谓的“异步”</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default class SetStateComponent extends Component &#123;</span></span><br><span class="line"><span class="regexp">  state= &#123;</span></span><br><span class="line"><span class="regexp">    count : 0</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 同步：原生事件和setTimeout </span></span><br><span class="line"><span class="regexp">    **setTimeout**</span></span><br><span class="line"><span class="regexp">   componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">     setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">       this.setState(&#123;count: this.state.count+1&#125;);</span></span><br><span class="line"><span class="regexp">       console.log(`this.state.count`, this.state.count);</span></span><br><span class="line"><span class="regexp">     &#125;)</span></span><br><span class="line"><span class="regexp">    **原生事件**</span></span><br><span class="line"><span class="regexp">     const ele = document.getElementById('element');</span></span><br><span class="line"><span class="regexp">     ele.onclick = ()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">       this.setState(&#123;count: this.state.count+1&#125;);</span></span><br><span class="line"><span class="regexp">       console.log(`this.state.count`, this.state.count)</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">   &#125;</span></span><br><span class="line"><span class="regexp">	**生命周期钩子函数**</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;count: this.state.count+1&#125;);</span></span><br><span class="line"><span class="regexp">    console.log(`this.state.count`, this.state.count)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  ** react合成事件 *</span></span><br><span class="line"><span class="regexp">  handleClick = ()=&gt; &#123; </span></span><br><span class="line"><span class="regexp">    this.setState(&#123;count: this.state.count+1&#125;); /</span><span class="regexp">/点击的时候输出0 异步的没有立马拿到最新的值</span></span><br><span class="line"><span class="regexp">    console.log(`this.state.count`, this.state.count)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button id="element"&gt;add&lt;tton&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;tton&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>在同一个事件响应函数中setStata两次，render会执行几次?</span><br><span class="line">setState机制:内部会维护一个updaterQueue, 当我们同时更新一个同名属性的时候 会对同名的state属性进行一个覆盖。</span><br><span class="line">执行后面的一个setState</span><br><span class="line"><span class="number">4.</span>什么是render props?可以用来解决什么问题?</span><br><span class="line">术语“render prop”是指―种在React组件之间使用一个值为函数的prop共享代码的简单技术</span><br><span class="line">使用场景:获取鼠标坐标值(鼠标移动跟随的场景)</span><br><span class="line">	   路由劫持</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>react中如何进行条件渲染 三元运算符</span><br><span class="line">判断是否登陆渲染相应的组件</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>Router-React中如何获取url的参数</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(<span class="class"><span class="keyword">class</span> <span class="title">RouteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> query = <span class="keyword">this</span>.props.router.query;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`query`</span>, query);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击我吧&lt;tton&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 面试官主要考察什么？</span></span><br><span class="line"><span class="comment">// react框架本身的熟悉程度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试中遇到该题目我们该如何回答？</span></span><br><span class="line"><span class="comment">// 以next为例，用withRouter 包装基础组件 基础组件的props中拿到我们路由的信息</span></span><br><span class="line"><span class="number">7.</span>React-Router有哪几种路由模式?</span><br><span class="line"><span class="number">1</span>、BrowserRouter:浏览器的路由方式，也就是在开发中最常使用的路由方式/</span><br><span class="line">2、HashRouter:在路径前加入#号成为一个哈希值，Hash模式的好处是，再也不会因为我们刷新而找不到我们的对应路径</span><br><span class="line"><span class="number">2.</span>hashRouter和BrowserRouter的实现原理?</span><br><span class="line">hashRouter:    <span class="built_in">window</span> 监听 hashChange 事件来实现路由切换的</span><br><span class="line">BrowserRouter: <span class="built_in">window</span> 监听popstate事件来实现路由切换的</span><br><span class="line">(实现原理:react-router这个库是依赖history这个库的  history这个库给我们提供了路由跳转的方式)</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>什么是jsx？</span><br><span class="line">jsx是由babel进行编译的</span><br><span class="line"> <span class="comment">//jsx 本质是一个语法糖</span></span><br><span class="line"><span class="comment">// jsx 通过@babel/presets-react预设(编译),将jsx转换为React.createElement这个函数 这个函数会生成虚拟DOM</span></span><br><span class="line"><span class="comment">// 生成虚拟DOM之后会调用</span></span><br><span class="line"><span class="comment">// render方法来对虚拟DOM编译</span></span><br><span class="line"><span class="number">9.</span>react的生命周期你了解多少?</span><br><span class="line">面试中遇到该题目我们该如何回答?</span><br><span class="line"><span class="number">1.</span>分阶段（挂载,更新,卸载)讲清楚react的生命周期</span><br><span class="line">挂载:挂载阶段，也可以理解为组件的初始化阶段，就是将我们的组件插入到DOM中，只会发生一次</span><br><span class="line"><span class="keyword">constructor</span>， 组件构造函数，第一个被执行</span><br><span class="line">getDerivedStateFromProps(让组件在 props 变化时更新 state。)，</span><br><span class="line">						它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</span><br><span class="line">                        此生命周期是在 16.3 版本新增的，用于替代 componentWillReceiveProps 生命周期</span><br><span class="line">                        这个函数有两个参数props和state，分别指接收到的新参数和当前的state对象，这个函数会返回一个对象用来						更新当前的state对象，如果不需要更新可以返回null</span><br><span class="line">	render,</span><br><span class="line">    componentDidMount 组件挂载之后调用</span><br><span class="line">更新:当组件的props改变了，或组件内部调用了setState或者forceUpdate发生，会发生多次</span><br><span class="line">	getDerivedStateFromProps, 无论我们接收到新的属性，调用了setState还是调用了forceUpdate，这个方法都会被调用</span><br><span class="line">    shouldComponentUpdate，控制更新的阀门 ，控制 render 是否允许被执行。。</span><br><span class="line">    render,渲染render函数是纯函数（同样的输入必定有同样的输出）</span><br><span class="line">	getSnapshotBeforeUpdate,这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之	 前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate（获取的快照），如果你不想要返回值，请	 返回null，一定要和componentDidUpdate一起使用  （这个方法代替了之前的componentWillUpdate）</span><br><span class="line">    componentDidUpdate 该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps（之前的属性），prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的</span><br><span class="line"></span><br><span class="line">卸载: 我们的组件被卸载或者销毁了</span><br><span class="line">	componentWillUnmount:清除一些定时器，取消网络请求。</span><br></pre></td></tr></table></figure>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、webpack的理解</span><br><span class="line">    <span class="number">1.</span>webpack是一个用于现代JavaScript应用程序的**静态模块打包工具**</span><br><span class="line">    <span class="number">2.</span>解决模块依赖问题 :例如A模块依赖B模块，B模块依赖C模块，就会把C模块放在最前面</span><br><span class="line">    <span class="number">3.</span>解决代码编写问题 :将less转化为css  将ts转化为js	</span><br><span class="line">    <span class="number">4.</span>解决开发效率问题 :webpack提供了热加载的功能，当我们项目开发过程中，保存文件后会自动更新</span><br><span class="line">    <span class="number">5.</span>解决项目优化问题 :项目完成开发上线的时候，webpack会将代码进行压缩优化，提高性能。</span><br><span class="line"><span class="number">2</span>、使用过webpack中的哪些loader</span><br><span class="line">	loader 分为js相关、css相关、文件相关、</span><br><span class="line">	js相关 </span><br><span class="line">   		babel-loader:处理javascript文件，提供语法转换(编译过程中<span class="class"><span class="keyword">class</span>转换成<span class="title">function</span>)，语法垫片(对<span class="title">ES</span>的新语法提供支持)</span></span><br><span class="line">        source-map-loader:从现有源文件中提取源映射关系(webpack打出来的包都是一个个bundle.js，bundle.js里面包括webpack打包的代码和源文件，如果要在项目中进行debug调试的话，没有source-map-loader的话，就会debug到webpack打出来的包都是一个个bundle.js中，有的话就会定位到源代码中，在源代码进行调试)</span><br><span class="line">    css相关</span><br><span class="line">        style-loader:把编译后的css以style标签的格式插入DOM中      执行顺序<span class="number">3</span></span><br><span class="line">        css-loader:处理css中比如url()@<span class="keyword">import</span>等语法的文件引用路径问题   执行顺序<span class="number">2</span>  </span><br><span class="line">        less-loader:将less编译为css  执行顺序<span class="number">1</span> 先由less转为css</span><br><span class="line">    文件相关</span><br><span class="line">    	file-loader:处理文件引用路径问题</span><br><span class="line">        gzip-loader:加载gzip资源</span><br><span class="line">		url-loader:允许有条件地将文件转换为内联的base<span class="number">-64</span> URL，转化玩之后，减少了http请求的个数，提高了应用的性能</span><br><span class="line">     **注意**loader以数组的方式进行配置,执行的顺序是从后往前栈结构的顺序执行。   </span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span>使用过webpack中的哪些plugin分别是用来做什么的</span><br><span class="line">    DllPlugin 为了极大减少构建时间，进行分离打包</span><br><span class="line">    HotModuleReplacementPlugin 启用模块热替换(Enable Hot Module Replacement -HMR)*</span><br><span class="line">    HtmlwebpackPlugin 简单创建HTML文件,用于服务器访问</span><br><span class="line">    ProvidePlugin 全局的注入模块，不必通过<span class="keyword">import</span>/<span class="built_in">require</span>使用模块</span><br><span class="line">	这些插件的执行顺序与配置顺序无关 pligun可以在webpack的整个编译周期执行</span><br><span class="line"><span class="number">4.</span>如何实现一个loader   -D是开发依赖 -S 生成依赖</span><br><span class="line">	**loader本质上是一个函数，这个函数接收source为参数,函数返回值便是我们最终loader处理的结果。**</span><br><span class="line">	使用过uglify-loader来进行代码压缩的</span><br><span class="line">    <span class="number">1.</span>首先现在webpack.config.js下配置loader和指定loader编写的目录</span><br><span class="line">    <span class="number">2.</span>在指定编写的目录写对应的loader的实现操作</span><br><span class="line">    <span class="number">3.</span>返回code实现webpack代码的压缩。</span><br><span class="line"><span class="number">5.</span>如何编写一个plugin  日志loader</span><br><span class="line">	<span class="number">1.</span>plugin本质上是一个构造函数,通常用<span class="class"><span class="keyword">class</span>类来表示,<span class="title">constructor</span>中接受入参,</span></span><br><span class="line"><span class="class">    且必须实现<span class="title">apply</span>方法来接收<span class="title">webpack</span>的主体编译对象<span class="title">compiler</span></span></span><br><span class="line"><span class="class">	2.讲清楚自己实现过哪些自定义的<span class="title">plugin</span>,分别是用来做什么的?</span></span><br><span class="line"><span class="class">	打印日志的<span class="title">LogPlugin</span></span></span><br><span class="line">6.plugin和loader的区别:</span><br><span class="line">	<span class="number">1.</span>功能:loader能做的事情，plugin也可以做</span><br><span class="line">    <span class="number">2.</span>执行顺序:</span><br><span class="line">		pligin 可以在webpack编译的过程中执行，类比react的生命周期钩子</span><br><span class="line">        loader 只能在固定的阶段执行</span><br><span class="line">    <span class="number">3.</span>本质上的区别</span><br><span class="line">    	loader 本质上是一个翻译官，对客户端识别不了的源码进行翻译</span><br><span class="line">        plugin 执行的是一些副操作，比如输出一个日子，图片资源可以实现插件将图片做一些副操作，上传到cdn里面</span><br><span class="line"><span class="number">7.</span>webpack的构建流程</span><br><span class="line">	如下图</span><br><span class="line"><span class="number">8.</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112251724421.png" alt="image-20211225172445261"></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、JavaScript的数组方法有哪些?</span><br><span class="line">	concat连接<span class="number">2</span>个或更多数组,并返回结果</span><br><span class="line">	every对数组中的每一项运行给定函数，如果该函数对每一项都返回<span class="literal">true</span>，则返回<span class="literal">true</span></span><br><span class="line">        <span class="keyword">const</span> array = [&#123;<span class="attr">name</span>:<span class="string">'freemen'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'vinko'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;];</span><br><span class="line">        <span class="keyword">const</span> result  = array.every(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.name===<span class="string">"freemen"</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(result);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	filter对数组中的每一项运行给定函数，返回该函数会返回<span class="literal">true</span>的项组成的数组</span><br><span class="line">    forEach对数组中的每—项运行给定函数**这个方法没有返回值** 传入的参数可以使item,和一个索引index</span><br><span class="line">    <span class="keyword">const</span> array = [&#123;<span class="attr">name</span>:<span class="string">'freemen'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'vinko'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;];</span><br><span class="line">    array.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item); <span class="comment">//&#123;name:'freemen',age:18&#125;&#123;name:'vinko',age:18&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(index);<span class="number">0</span> <span class="number">1</span> </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    join将所有的数组元素连接成一个字符串</span><br><span class="line">    <span class="keyword">const</span> array  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">const</span> result = array.join(<span class="string">','</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);<span class="comment">//1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    indexOf返回第一个与给定参数相等的数组元素的索引，没有找到则返回<span class="number">-1</span></span><br><span class="line">    lastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值</span><br><span class="line">    map对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</span><br><span class="line">     	<span class="keyword">const</span> array = [&#123;<span class="attr">name</span>:<span class="string">'freemen'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'vinko'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;];</span><br><span class="line">        <span class="keyword">const</span> result = array.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.name===<span class="string">'freemen'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">           	 <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        	&#125;)</span><br><span class="line"></span><br><span class="line">    reverse 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个</span><br><span class="line">    slice传入索引值，将数组里对应索引范围内的元素作为新数组返回</span><br><span class="line">    some对数组中的每一项运行给定函数，如果任一项返回<span class="literal">true</span>，则返回<span class="literal">true</span></span><br><span class="line">        <span class="keyword">const</span> array  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">const</span> result = array.some(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item===<span class="number">6</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line">    sort按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数</span><br><span class="line">    <span class="keyword">const</span> result = array.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> a-b;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	toString 将数组作为字符串返回</span><br><span class="line"><span class="number">2</span>、栈 peek获取栈顶</span><br><span class="line">	 isEmpty栈是否为空</span><br><span class="line"><span class="number">3</span>、react-redux有用到队列的数据结构（发布订阅机制） 所有的订阅者都会拿到消息执行，执行的原则是先进先出</span><br><span class="line"><span class="number">4</span>、冒泡排序</span><br></pre></td></tr></table></figure>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">装饰者模式:不改变对象自身代码的基础上新增功能</span><br><span class="line">策略模式的实现:有效解决<span class="keyword">if</span> <span class="keyword">else</span>逻辑复杂不可维护的情况</span><br><span class="line"><span class="keyword">let</span> strategys = &#123;</span><br><span class="line">	s(base)&#123;</span><br><span class="line">        log(<span class="string">'phone'</span>)</span><br><span class="line">        <span class="keyword">return</span> base*<span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    a(base)&#123;</span><br><span class="line">        log(<span class="string">'书包'</span>)</span><br><span class="line">        <span class="keyword">return</span> base*<span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">	b(base)&#123;</span><br><span class="line">        log(<span class="string">'鼠标'</span>)</span><br><span class="line">        <span class="keyword">return</span> base*<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catulaBonus</span>(<span class="params">base,grade</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strategys[grade](base)</span><br><span class="line">&#125;</span><br><span class="line">代理模式:转发请求</span><br><span class="line"></span><br><span class="line">发布-订阅模式又叫观察者模式、它定义对象间的一种一对多的依赖关系当一个对象的状状态发生改变时所有依赖于它的对象都将得到通知</span><br><span class="line">最基础的例子是事件监听</span><br><span class="line">迭代器模式:对一个目标数组进行遍历</span><br><span class="line">倒叙迭代器</span><br><span class="line"><span class="keyword">let</span> reverseEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!array.isArray(obj))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'params is must an array'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =obj.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    	callback.call(obj[i],obj[i],i)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reverseEach(array,(item,index)=&gt;&#123;</span><br><span class="line">    log(<span class="string">`item:<span class="subst">$&#123;item&#125;</span>`</span>)</span><br><span class="line">    log(<span class="string">`index:<span class="subst">$&#123;index&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="网络协议面试题及实操"><a href="#网络协议面试题及实操" class="headerlink" title="网络协议面试题及实操"></a>网络协议面试题及实操</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、http常见状态码及含义:</span><br><span class="line">    <span class="number">200</span>请求成功</span><br><span class="line">    <span class="number">301</span>永久重定向</span><br><span class="line">    <span class="number">302</span>临时重定向</span><br><span class="line">    <span class="number">401</span>未授权</span><br><span class="line">    <span class="number">403</span>没权限,服务器拒绝了请求  </span><br><span class="line">    <span class="number">404</span>表示服务器上没有找到该资源</span><br><span class="line">    <span class="number">405</span>表示请求的方式不对</span><br><span class="line">    <span class="number">500</span>服务器错误</span><br><span class="line"><span class="number">2</span>、<span class="keyword">get</span>和post区别</span><br><span class="line">    1.<span class="keyword">get</span>用来获取数据，post用来提交数据</span><br><span class="line">    2.<span class="keyword">get</span>参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节)，而post无限制。</span><br><span class="line">    3.<span class="keyword">get</span>参数通过 url 传递，post放在请求体 (request body) 中。 <span class="keyword">get</span>是明文传输，post的请求参数是放在请求体中 </span><br><span class="line">    4.<span class="keyword">get</span>请求只能进行url编码，而post支持多种编码方式。</span><br><span class="line">    </span><br><span class="line">3、http协议中的header及含义</span><br><span class="line">accept:代表客户端希望接受的数据类型</span><br><span class="line">accept-encoding:浏览器发给服务器,声明浏览器支持的编码类型</span><br><span class="line">accept-language:表示浏览器所支持的语言类型</span><br><span class="line">Cache-Control:缓存开关，no-cache表示禁用缓存</span><br><span class="line">referer: referer的正确英语拼法是referrer。由于早期HTTP规范的拼写错误，主要用于防止盗链和恶意请求</span><br><span class="line"></span><br><span class="line">4、网络分层模型 OSI七层模型</span><br><span class="line">    应用层</span><br><span class="line">    表示层</span><br><span class="line">    会话层</span><br><span class="line">    传输层</span><br><span class="line">    网络层</span><br><span class="line">    链路层</span><br><span class="line">    物理层</span><br></pre></td></tr></table></figure>
<h3 id="浏览器面试题"><a href="#浏览器面试题" class="headerlink" title="浏览器面试题"></a>浏览器面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、浏览器事件传输机制</span><br><span class="line">    事件传输机制冒泡和捕获分别由微软和网景公司提出</span><br><span class="line">    这两个概念都是为了解决页面中事件流（事件发生顺序）的问题</span><br><span class="line">    </span><br><span class="line">	事件触发的三个阶段:捕获阶段、目标阶段、冒泡阶段   </span><br><span class="line">    addEventListener(,<span class="literal">true</span>)是捕获阶段 从外到内</span><br><span class="line">    addEventListener(,<span class="literal">false</span>)是冒泡阶段 从内到外</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、localStorage和sessionStorage的区别  本地存储和会话存储的区别</span><br><span class="line">数据生命周期:</span><br><span class="line">	localStorage:永久性存储 除非被用户主动清理，否则一直存在</span><br><span class="line">	sessionStorage:页面关闭就清理</span><br><span class="line">数据存储大小</span><br><span class="line">    localStorage: <span class="number">5</span>M</span><br><span class="line">	sessionStorage:<span class="number">5</span>M</span><br><span class="line"><span class="number">3</span>、浏览器的事件循环机制</span><br><span class="line">你对浏览器的事件循环机制了解多少</span><br><span class="line">	宏任务</span><br><span class="line">		scripti(整个代码段)</span><br><span class="line">		setTimeout</span><br><span class="line">		setInterval</span><br><span class="line">        setlmmediate</span><br><span class="line">        I/O</span><br><span class="line">		UI render	</span><br><span class="line">	微任务</span><br><span class="line">		process.next Tick</span><br><span class="line">		<span class="built_in">Promise</span></span><br><span class="line">		Async/Await</span><br><span class="line">		MutationObsarver(html5新特性)</span><br><span class="line"><span class="number">4</span>、浏览器的回流和重绘</span><br><span class="line">浏览器的渲染过程是怎样的?</span><br><span class="line"><span class="number">1</span>．解析HTML，生成DOM树，解析css，生成CSSOM树</span><br><span class="line"><span class="number">2</span>．将DOM树和CSSOM树结合，生成渲染树(Render Tree)</span><br><span class="line"><span class="number">3.</span> Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点</span><br><span class="line">的几何信息（位置，大小)</span><br><span class="line"><span class="number">4.</span> Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点</span><br><span class="line">的绝对像素</span><br><span class="line"><span class="number">5.</span>调用GPU触发渲染，将结果展示在页面上</span><br><span class="line"></span><br><span class="line">回流:</span><br><span class="line">我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</span><br><span class="line">(重新绘制当前页面，包括整个结构和样式)</span><br><span class="line">重绘:</span><br><span class="line">我们通过构造渲染树，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点</span><br><span class="line">(重新绘制当前页面样式)</span><br><span class="line">比方说我们软件设计中的设计模式源于建筑学</span><br><span class="line">回流:相当于把房子拆了重建</span><br><span class="line">重绘:相当于重新粉刷</span><br><span class="line">结论:回流必然导致重绘，重绘不一定会伴随着回流</span><br><span class="line"></span><br><span class="line">何时触发回流和重绘</span><br><span class="line"><span class="number">1.</span>添加或删除可见的DOM元素</span><br><span class="line"><span class="number">2.</span>元素的内容、位置或尺寸发生变化</span><br><span class="line"><span class="number">3.</span>页面一开始渲染的时候</span><br><span class="line"><span class="number">4.</span>浏览器的窗口尺寸变化</span><br><span class="line"></span><br><span class="line">避免回流和重绘  图片</span><br><span class="line">使用文档片段fragment避免不停的往页面插入元素</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、跨域</span><br><span class="line">同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</span><br><span class="line">如果两个URL的protocol、port (en-US)(如果有指定的话)和 host都相同的话，则这两个URL是同源。</span><br><span class="line"></span><br><span class="line">当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</span><br><span class="line">跨域的解决方法:</span><br><span class="line">jsonp:通过动态创建 script 标签，通过 script 标签的 src 请求来通过jsonp跨域</span><br><span class="line">原理:</span><br><span class="line">	利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的jSON 数据。JSONP请求一定需要对方的服务器做支持才可以</span><br><span class="line">    优点: <span class="built_in">JSON</span>优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题</span><br><span class="line">    缺点∶仅支持<span class="keyword">get</span>方法具有局限性,不安全可能会遭受XSS攻击。</span><br><span class="line">postMessage</span><br><span class="line">postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题</span><br><span class="line">1．页面和其打开的新窗口的数据传递</span><br><span class="line">2.多窗口之间消息传递</span><br><span class="line">3．页面与嵌套的iframe消息传递</span><br><span class="line">4.上面三个场景的跨域数据传递</span><br><span class="line">6、浏览器主要组成部分</span><br><span class="line">	用户界面</span><br><span class="line">    浏览器引擎</span><br><span class="line">    渲染引擎</span><br><span class="line">    网络模块</span><br><span class="line">    用户界面后端</span><br><span class="line">    javascript解析器</span><br><span class="line">    数据存储模块</span><br><span class="line"></span><br><span class="line">用户界面:包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</span><br><span class="line">浏览器引擎:在用户界面和呈现引擎之间传送指令。</span><br><span class="line">渲染引擎–负责显示请求的内容。如果请求的内容是 HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上</span><br><span class="line">网络模块:用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。</span><br><span class="line">用户界面后端:用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</span><br><span class="line">JavaScript解释器:用于解析和执行JavaScript代码。</span><br><span class="line">数据存储模块:这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookie SessionStorage LocalStorage</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112292242811.png" alt="image-20211229224218562"></p>
<p><img data-src="/images/loading.gif" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211229224445796.png" alt="image-20211229224445796"></p>
<h3 id="软素质"><a href="#软素质" class="headerlink" title="软素质"></a>软素质</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">一、说一下自己的优点和缺点?</span><br><span class="line"><span class="number">1</span>．避开岗位的核心技能</span><br><span class="line"><span class="number">2</span>．把缺点放在场景中描述</span><br><span class="line"><span class="number">3</span>．对缺点进行合理化解释</span><br><span class="line"><span class="number">4</span>．优点随便说，主要方向还是在岗位上</span><br><span class="line">二、是否能接受加班?（建议分情况作答)</span><br><span class="line">假设公司有重要的项目要赶。示范回答:贵公司现在正处于发展上升期，也在官网上有看到公司的重要项目成果，我觉得有时候因为赶项目进度、工作需要等忙起来是非常正常的，面对这种情况，我是非常愿意配合公司和团队的工作，让工作能够更顺利地完成，此外，我也相信自己一定能在公司安排的工作中获得到锻炼，获得更快地成长。</span><br><span class="line">·假设自己作为新人，对业务不熟悉。示范回答:我作为公司刚进去的新人，可能刚开始进入公司接触业务时不太熟练，</span><br><span class="line">会出现需要加班的情况，但我更愿意提高工作效率，并积极向公司的前辈请教学习，在一定的时间内完成工作而不是拖到下班之后。当然，如果有紧急的事情，忙起来需要加班也是可以接受的。</span><br><span class="line">三、对薪酬的要求?</span><br><span class="line">·薪资并不是我求职的唯一标准，我来贵司求职的主要动机是兴趣，这份工作是我喜欢做的，也相信自己可以胜任，更相</span><br><span class="line">信公司会给出一个合理的薪酬。</span><br><span class="line">·我希望薪资可以达到XX，据我了解，贵司这个岗位薪资范围是A-~B，而结合岗位职责及任职要求，我对自己也进行了</span><br><span class="line">相应评估，也愿意接受贵司的下一步考核。</span><br><span class="line">四、为什么你觉得这个岗位适合自己?（为什么要聘用你)</span><br><span class="line"><span class="number">1.</span>描述应聘岗位的胜任条件，强调自己的工作能力跟岗位的匹配度，岗位要求的工作技能是否自己掌握了，掌握的程度是怎样的，最好在面试中说出来。(建议:在面试前最好是要针对应聘岗位，把自己胜任的条件一一列出来，做到知己知彼。)</span><br><span class="line"><span class="number">2.</span>描述自己能为公司做出什么贡献，公司是一个讲究利益的地方，聘用你肯定要你为公司做出贡献。那么你在回答这个问</span><br><span class="line">题时，就需要说出你的加入可以为公司带来什么，这非常重要。(一定要明确你的工作目标和职业规划，表明你的立场和专业程度，让HR信任你。)</span><br><span class="line"><span class="number">3.</span>描述出自身的优势。公司为何要聘用你，而不聘用别人，肯定是你有比别人优秀的地方。那么在回答这个问题时，就一</span><br><span class="line">定要说出自己与众不同的地方，最好是要举一个例子，来支持你的观点。</span><br><span class="line">(提示:这个问题，主要是想进一步了解你的信息，以及为这次面试做了多少功课。在面试前，最好是要尽可能获取有关公司可行业的资料信息。在回答的时候，结合自己所做的功课，建立个人和公司的联系，说明自己在哪一方面能够匹配公司的要求。)</span><br><span class="line">五、对我们公司有多少了解?</span><br><span class="line">·如果不了解，就按实际情况回答就好，知道多少就说多少，(很多时候去面试对这个公司的了解都是从网上查到的，不</span><br><span class="line">会太深入）;最好是提前做好一些调研和准备工作。</span><br><span class="line">六、缺乏工作经验，如何胜任这份工作?</span><br><span class="line">·承认工作经验的重要性。</span><br><span class="line">·突显个人优势。用自己的其他优势特长来补足经验上的不足，比如说记忆力好、动手能力强、语言能力强、学习能力强等。</span><br><span class="line">·强调自己会不断提高工作能力。切忌用假大空的话。</span><br></pre></td></tr></table></figure>
<h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、简历投递</span><br><span class="line">    <span class="number">1.</span>朋友内推:更好的了解公司以及团队内部的情况</span><br><span class="line">    <span class="number">2.</span>招聘软件:boss直聘 打钩</span><br><span class="line">    <span class="number">3.</span>公众号</span><br><span class="line"><span class="number">2</span>、如何准备项目经验</span><br><span class="line">    <span class="number">1.</span>准备<span class="number">1</span><span class="number">-2</span>个实际做过的或者可以讲清楚整个业务流程的项目</span><br><span class="line">    <span class="number">2</span>．说清楚其中作用的技术栈</span><br><span class="line">    <span class="number">3</span>．讲清楚在项目开发过程中遇到的难点</span><br><span class="line">    <span class="number">4.</span>复盘整个过程发掘出可以优化的地方</span><br><span class="line">        <span class="number">1</span>、样式布局可以进行优化:以采用css <span class="built_in">module</span>的方式 以.css/.less文件文件为主，而不是styled-components的方式</span><br><span class="line">			虽然采用styled-components的方式可以有效避免组件之间样式的冲突 但是编写代码起来繁琐（包括没有代码提示）</span><br><span class="line">            同时jsx 中的原生标签不能一眼看出来，也额外增加了标签变量。</span><br><span class="line"></span><br><span class="line">    	<span class="number">2</span>、前端的页面，还不完整，可以加一个后台管理系统来管理数据。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、学历是否能反应一个人的真实水平</span><br><span class="line">	当然不能 学历是判断潜力的一个相对客观的一个指标</span><br><span class="line"><span class="number">4</span>、简书项目</span><br><span class="line">	<span class="number">1.</span>不同的浏览器内核里对html body标签默认的样式是不同的，有可能在某一个浏览器上的body的margin间距值是<span class="number">10</span> 而在另外一个浏览器的间距值就是<span class="number">8</span> 为了让这个代码在所有浏览器的表现形式是一致的，我们要先把这些浏览器默认对这些标签的实现进行一个统一</span><br><span class="line">reset.css就是干这个活 ，当你引入这个之后，标签基本上在所有浏览器的margin，padding值都会一模一样，这样就防止在不同的浏览器打开呈现的效果不同。</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202201011412255.png" alt="image-20220101141245546"></p>
<h3 id="高频考点"><a href="#高频考点" class="headerlink" title="高频考点"></a>高频考点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">React面试题</span><br><span class="line">. React组件通讯的常见方式。JSX本质是什么?</span><br><span class="line">    <span class="number">1</span>、父组件通过向子组件传递 props</span><br><span class="line">	<span class="number">2</span>、利用回调函数，可以实现子组件向父组件通信</span><br><span class="line">	<span class="number">3</span>、跨级组件间通信：使用context对象 </span><br><span class="line">	<span class="number">4</span>、非嵌套组件间通信：使用事件订阅</span><br><span class="line">    </span><br><span class="line">. context 是什么，有何用途?</span><br><span class="line">    Context 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</span><br><span class="line">		创建Context容器对象：</span><br><span class="line">		渲染子组件时，外面包裹容器对象的Provider属性, 通过value属性给后代组件传递数据</span><br><span class="line">		后代组件读取数据：</span><br><span class="line">						第一种方式:仅适用于类组件 </span><br><span class="line">							<span class="keyword">static</span> contextType = xxxContext  <span class="comment">// 声明接收context</span></span><br><span class="line">	  						<span class="keyword">const</span> theme = <span class="keyword">this</span>.context <span class="comment">// 读取context中的value数据  theme就是value的值</span></span><br><span class="line">						第二种方式: 函数组件与类组件都可以  函数式没有<span class="keyword">this</span>所以第一种不适合函数式组件</span><br><span class="line">                        	外面包裹容器对象的Consumer属性</span><br><span class="line">                            </span><br><span class="line">. shouldComponentUpdate 的深入理解。</span><br><span class="line">	控制组件更新的“阀门” 应不应该更新状态  ** </span><br><span class="line">    在父组件更新时会触发此函数，在此函数中可以根据props是否变化来setState，并且在此函数中的setState不会再次触发子组件的render</span><br><span class="line">    </span><br><span class="line">. 描述redux单项数据流。</span><br><span class="line">	react要去改变store里的数据，首先要一个派发action，action会通过dispatch方法传递给store，store再把之前的数据和传递过来的action转发给reducers，reducers是一个函数，当reducers接收到state和action之后，做一些处理之后，会返回一个新的state给到store，store用这个新的state替换掉之前的state，store数据发生改变之后，react组件会感知到store里的state发生改变（用的是<span class="string">``</span>store.subcribe()<span class="string">``</span>来监测store里状态的改变）就会从store里面重新取出数据更新组件的内容，页面就发生变化了</span><br><span class="line">    </span><br><span class="line">. setState是同步还是异步?</span><br><span class="line">    **执行层面**</span><br><span class="line">同步:原生事件、setTimeout</span><br><span class="line">异步:react合成事件、生命周期钩子函数</span><br><span class="line">**本质层面**</span><br><span class="line">本质:本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致他们没法立马拿到更新后的值，形式了所谓的“异步”</span><br><span class="line"></span><br><span class="line">. 用React设计一个todolist，请设计组件结构，设计state 数据结构。</span><br><span class="line">	</span><br><span class="line">webpack面试题</span><br><span class="line">. 前端代码为何要进行构建和打包?</span><br><span class="line">. module chunk bundle分别是什么意思，有何区别?</span><br><span class="line"></span><br><span class="line">. loader和plugin 的区别。</span><br><span class="line">. webpack如何实现懒加载?</span><br><span class="line">. webpack <span class="string">'常见性能优化方式(开放型题目，自由发挥)。</span></span><br><span class="line"><span class="string">. babel-runtime和babel-polyfill的区别。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">JavaScript面试题</span></span><br><span class="line"><span class="string">1、var 和 let const的区别</span></span><br><span class="line"><span class="string">    var是ES5语法，let const是ES6语法;var有变量提升</span></span><br><span class="line"><span class="string">    var和let是变量，可修改;const是常量，不可修改﹔</span></span><br><span class="line"><span class="string">    let const有块级作用域，var没有</span></span><br><span class="line"><span class="string">2、typeof 能判断哪些类型</span></span><br><span class="line"><span class="string">    undefined string number boolean symbol</span></span><br><span class="line"><span class="string">    object(注意，typeof null === '</span>object<span class="string">')</span></span><br><span class="line"><span class="string">    function</span></span><br><span class="line"><span class="string">3、列举强制类型转换和隐式类型转换</span></span><br><span class="line"><span class="string">    强制:parseInt parseFloat toString 等</span></span><br><span class="line"><span class="string">    隐式:if、逻辑运算、==、＋拼接字符串</span></span><br><span class="line"><span class="string">4、数组的pop push unshift shift分别是什么</span></span><br><span class="line"><span class="string">功能是什么?</span></span><br><span class="line"><span class="string">	push()方法是向数组末尾添加一个或者多个元素，并返回新的长度。</span></span><br><span class="line"><span class="string">	pop()方法删除数组的最后一个元素，把数组的长度减1，返回的是删除的元素。</span></span><br><span class="line"><span class="string">    unshift()方法是向数组的开头添加一个或多个元素，并且返回新的长度。</span></span><br><span class="line"><span class="string">    shift()方法是数组的第一个元素从其中删除，并返回第一个元素的值。</span></span><br><span class="line"><span class="string">返回值是什么?</span></span><br><span class="line"><span class="string">	pop()返回的是删除的元素</span></span><br><span class="line"><span class="string">	push()返回的是数组的长度****</span></span><br><span class="line"><span class="string">	unshift()返回的是数组的长度****</span></span><br><span class="line"><span class="string">    shift()返回的是删除的第一个元素元素</span></span><br><span class="line"><span class="string">是否会对原数组造成影响?</span></span><br><span class="line"><span class="string">	都产生影响</span></span><br><span class="line"><span class="string">以下对原数组不产生影响</span></span><br><span class="line"><span class="string">    toString:得到数组中每个值的字符串形式拼接而成的、一个以逗号分隔的字符串。</span></span><br><span class="line"><span class="string">    valueOf:返回数组的原始值</span></span><br><span class="line"><span class="string">    join:使用指定的分隔符，将数组的每个元素连接起来，返回构建的字符串。</span></span><br><span class="line"><span class="string">    concat:传递一个或多个数组，则会将数组的每一项都添加到结果数组中。</span></span><br><span class="line"><span class="string">    slice:返回起始位置到数组末尾的所有项</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">纯函数:不改变原数组（没有副作用），且返回一个数组  =&gt;等同于对原数组不产生影响</span></span><br><span class="line"><span class="string">    map</span></span><br><span class="line"><span class="string">    filter</span></span><br><span class="line"><span class="string">    slice</span></span><br><span class="line"><span class="string">    concat</span></span><br><span class="line"><span class="string">非纯函数:forEach reduce some every    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5、slice(-2)//截取后面两个 纯函数</span></span><br><span class="line"><span class="string">   splice 非纯函数 splice(1,2,'</span>a<span class="string">','</span>b<span class="string">')//从第一个元素开始截取两个 然后添加ab</span></span><br><span class="line"><span class="string">6、const res = [10,20,30].map(parseInt)</span></span><br><span class="line"><span class="string">	拆解开是</span></span><br><span class="line"><span class="string">    [10,20,30].map((num,index)=&gt;&#123;</span></span><br><span class="line"><span class="string">        return parseInt(num,index)  //parseInt(20,1)  parseInt(30,2)不符合parseInt的转换规则</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">结果为[10,NaN,NaN]//map返回的是一个数组</span></span><br><span class="line"><span class="string">**parseInt如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。**</span></span><br><span class="line"><span class="string">7、ajax请求get和post的区别</span></span><br><span class="line"><span class="string">    get 一般用于查询操作，post 一般用户提交操作</span></span><br><span class="line"><span class="string">    get参数拼接在url上(明文传输), post放在请求体内（数据体积可更大)</span></span><br><span class="line"><span class="string">    安全性:post易于防止 CSRF</span></span><br><span class="line"><span class="string">8、闭包应用场景:作为参数被传入，作为返回值被返回</span></span><br><span class="line"><span class="string">   自由变量的查找，要在函数定义的地方（而非执行的地方</span></span><br><span class="line"><span class="string">   影响∶变量会常驻内存，得不到释放。闭包不要乱用</span></span><br><span class="line"><span class="string">9、如何阻止事件的冒泡和默认行为</span></span><br><span class="line"><span class="string">	event.stopPropagation</span></span><br><span class="line"><span class="string">	event.preventDefault</span></span><br><span class="line"><span class="string">	这两个API</span></span><br><span class="line"><span class="string">10、查找、添加、删除、替换DOM节点的方法?</span></span><br><span class="line"><span class="string">    查找:</span></span><br><span class="line"><span class="string">      getElementsByTagName()    //通过标签名称</span></span><br><span class="line"><span class="string">      getElementsByName()    //通过元素的Name属性的值</span></span><br><span class="line"><span class="string">      getElementById()    //通过元素Id，唯一性</span></span><br><span class="line"><span class="string">	添加appendChild()</span></span><br><span class="line"><span class="string">    删除removeChild()</span></span><br><span class="line"><span class="string">	替换replaceChild()</span></span><br><span class="line"><span class="string">11、如何减少DOM操作?(耗性能)</span></span><br><span class="line"><span class="string">    缓存DOM查询结果(获取dom的list长度的时候先把list拿出来 避免重复获取)</span></span><br><span class="line"><span class="string">    多次DOM操作，合并到一次插入</span></span><br><span class="line"><span class="string">12、==会尝试类型转换，===严格相等</span></span><br><span class="line"><span class="string">13、函数声明和函数表达式的区别</span></span><br><span class="line"><span class="string">函数声明function fn() &#123;...&#125;</span></span><br><span class="line"><span class="string">函数表达式const fn = function() &#123;...&#125;</span></span><br><span class="line"><span class="string">函数声明会在代码执行前预加载，而函数表达式不会</span></span><br><span class="line"><span class="string">14、new Object()和 Object.create()区别</span></span><br><span class="line"><span class="string">   &#123;&#125;等同于new Object，原型Object.prototype</span></span><br><span class="line"><span class="string">   Object.create(null)没有原型</span></span><br><span class="line"><span class="string">   Object.create(&#123;...&#125;)可指定原型   =&gt;意思是创建了一个空对象，但是空对象的原型指向了&#123;...&#125;</span></span><br><span class="line"><span class="string">15、下图关于this的题 第一个是1 第二个是undefined 如果将函数作为一个独立函数来执行的话 this就是undefined</span></span><br><span class="line"><span class="string">16、\w 命中字母数字下划线 \d匹配数字</span></span><br><span class="line"><span class="string">17、trim去除空格字符=&gt;保证浏览器的兼容性</span></span><br><span class="line"><span class="string">18、Math.max</span></span><br><span class="line"><span class="string">19、如何用JS实现继承</span></span><br><span class="line"><span class="string">    class继承</span></span><br><span class="line"><span class="string">    prototype继承</span></span><br><span class="line"><span class="string">20、如何捕获JS中的异常 =&gt;手动捕获catch</span></span><br><span class="line"><span class="string">21、 什么是JSON ?</span></span><br><span class="line"><span class="string">    json是一种数据格式，本质是一段字符串。</span></span><br><span class="line"><span class="string">    json格式和JS对象结构一致，对JS语言更友好</span></span><br><span class="line"><span class="string">    window.JSON是一个全局对象:JSON.stringify JSON.parse</span></span><br><span class="line"><span class="string">22、获取当前页面的url参数</span></span><br><span class="line"><span class="string">    传统方式，查找location.search</span></span><br><span class="line"><span class="string">	新API，URLSearchParams</span></span><br><span class="line"><span class="string">23、数组去重的几种方式</span></span><br><span class="line"><span class="string">	Set方式=&gt;无序 不能重复</span></span><br><span class="line"><span class="string">24、手写一个深拷贝 </span></span><br><span class="line"><span class="string">   Object.assign()不是深拷贝，这是追加信息 </span></span><br><span class="line"><span class="string">   const obj = &#123;a: 10,b:20,c: 30&#125;</span></span><br><span class="line"><span class="string">   Object.assign(obj, &#123;d: 40&#125;) //obj:&#123;a:10，b: 20,c: 30,d: 40&#125;</span></span><br><span class="line"><span class="string">   const obj1=  Object.assign(&#123;&#125;，obj, &#123;e: 50&#125;) </span></span><br><span class="line"><span class="string">   obj1=&#123;a:10，b: 20,c: 30,d: 40,e: 50&#125;</span></span><br><span class="line"><span class="string">   第一层级的浅层拷贝</span></span><br><span class="line"><span class="string">   const obj = &#123;a: 10,b:&#123;x:100,y:100&#125;&#125;</span></span><br><span class="line"><span class="string">   const obj1=  Object.assign(&#123;&#125;，obj, &#123;c: 50&#125;)</span></span><br><span class="line"><span class="string">   obj.a=100 那么obj变成&#123;a: 100,b:&#123;x:100,y:100&#125;&#125;  obj1没有改</span></span><br><span class="line"><span class="string">   obj.b.x=101 obj和obj1都改了 只拷贝了第一层级a：10 c:30  xy就不拷贝了</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202201012031391.png" alt="image-20220101203115228"></p>
<blockquote>
<p>拍平数组  如果是很多重就递归拍平</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202201012059994.png" alt="image-20220101205927937"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/02/01/%E5%B0%9A%E7%A1%85%E8%B0%B7React%E7%AC%94%E8%AE%B0%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/%E5%B0%9A%E7%A1%85%E8%B0%B7React%E7%AC%94%E8%AE%B0%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">尚硅谷React笔记详解</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T00:00:00+08:00">2021-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/01/%E5%B0%9A%E7%A1%85%E8%B0%B7React%E7%AC%94%E8%AE%B0%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/01/%E5%B0%9A%E7%A1%85%E8%B0%B7React%E7%AC%94%E8%AE%B0%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="React-基础"><a href="#React-基础" class="headerlink" title="React 基础"></a>React 基础</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">**使用jsx创建虚拟DOM</span><br><span class="line"><span class="number">1.</span>&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../js/babel.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;  -&gt; 引入babel，用于将jsx转为js</span></span><br><span class="line"><span class="regexp">const VDOM = (  </span></span><br><span class="line"><span class="regexp">			&lt;h1 id="title"&gt;</span></span><br><span class="line"><span class="regexp">				&lt;span&gt;Hello,React&lt;/</span>span&gt;  </span><br><span class="line">			&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">		)</span></span><br><span class="line"><span class="regexp">/</span>* 此处一定不要写引号，因为不是字符串  下面这些代码经过babel翻译为js原生代码的写法*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">	babel.js的作用</span></span><br><span class="line"><span class="regexp">    1.浏览器不能直接解析JSX代码, 需要babel转译为纯JS的代码才能运行</span></span><br><span class="line"><span class="regexp">    2.只要用了JSX，都要加上type="text/</span>babel<span class="string">", 声明需要babel来处理</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    React面向组件编程:</span></span><br><span class="line"><span class="string">    1.	组件名必须首字母大写</span></span><br><span class="line"><span class="string">    2.	虚拟DOM元素只能有一个根元素</span></span><br><span class="line"><span class="string">    3.	虚拟DOM元素必须有结束标签</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**使用js创建虚拟DOM</span></span><br><span class="line"><span class="string">2.&lt;script type="</span>text/javascript<span class="string">" &gt; //原生js</span></span><br><span class="line"><span class="string">const VDOM = React.createElement('h1',&#123;id:'title'&#125;,React.createElement('span',&#123;&#125;,'Hello,React'))//标签名 标签属性  标签内容    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3.关于虚拟DOM：</span></span><br><span class="line"><span class="string">        1.本质是Object类型的对象（一般js对象）</span></span><br><span class="line"><span class="string">        2.虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性。</span></span><br><span class="line"><span class="string">        3.虚拟DOM最终会被React转化为真实DOM，呈现在页面上。</span></span><br><span class="line"><span class="string">        一定注意区分：【js语句(代码)】与【js表达式】</span></span><br><span class="line"><span class="string">					1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方</span></span><br><span class="line"><span class="string">								下面这些都是表达式：</span></span><br><span class="line"><span class="string">										(1). a</span></span><br><span class="line"><span class="string">										(2). a+b</span></span><br><span class="line"><span class="string">										(3). demo(1)</span></span><br><span class="line"><span class="string">										(4). arr.map() </span></span><br><span class="line"><span class="string">										(5). function test () &#123;&#125;</span></span><br><span class="line"><span class="string">					2.语句(代码)：</span></span><br><span class="line"><span class="string">								下面这些都是语句(代码)：</span></span><br><span class="line"><span class="string">										(1).if()&#123;&#125;</span></span><br><span class="line"><span class="string">										(2).for()&#123;&#125;</span></span><br><span class="line"><span class="string">										(3).switch()&#123;case:xxxx&#125;</span></span><br><span class="line"><span class="string">4.jsx语法规则：</span></span><br><span class="line"><span class="string">        1.定义虚拟DOM时，不要写引号。</span></span><br><span class="line"><span class="string">        2.标签中混入JS表达式时要用&#123;&#125;。</span></span><br><span class="line"><span class="string">        3.样式的类名指定不要用class，要用className。</span></span><br><span class="line"><span class="string">        4.内联样式，要用style=&#123;&#123;key:value&#125;&#125;的形式去写。</span></span><br><span class="line"><span class="string">        5.只有一个根标签 就是说h2只能一个，如果要两个就得加一个div  [div包裹很不情愿,后期有办法处理,可以通过Frangment标签.]</span></span><br><span class="line"><span class="string">        6.标签必须闭合</span></span><br><span class="line"><span class="string">        7.标签首字母</span></span><br><span class="line"><span class="string">            (1).若小写字母开头，则将该标签转为html中同名元素（都是小写的），若html中无该标签对应的同名元素，则报错。good会报错</span></span><br><span class="line"><span class="string">            (2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。GOOD    </span></span><br><span class="line"><span class="string">5.创建函数式组件</span></span><br><span class="line"><span class="string">        **函数名大写 函数必须有返回值</span></span><br><span class="line"><span class="string">		function MyComponent()&#123;</span></span><br><span class="line"><span class="string">			console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式 禁止这种自定义的函数this指向window</span></span><br><span class="line"><span class="string">			return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		**渲染组件到页面</span></span><br><span class="line"><span class="string">		ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById('test')) //标签必须闭合&lt;MyComponent/&gt;</span></span><br><span class="line"><span class="string">		/* </span></span><br><span class="line"><span class="string">			执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？)</span></span><br><span class="line"><span class="string">					1.React解析组件标签，找到了MyComponent组件。</span></span><br><span class="line"><span class="string">					2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span></span><br><span class="line"><span class="string">		*/</span></span><br><span class="line"><span class="string">6.创建类式组件</span></span><br><span class="line"><span class="string">		class MyComponent extends React.Component &#123;</span></span><br><span class="line"><span class="string">			render()&#123;</span></span><br><span class="line"><span class="string">                //不用写构造器 写render 返回值也必须写  继承React.Component也必须写</span></span><br><span class="line"><span class="string">				//render是放在哪里的？ —— 组件的的原型对象上，供实例使用。</span></span><br><span class="line"><span class="string">				//render中的this是谁？—— 组件的实例对象 &lt;=&gt; MyComponent组件实例对象。</span></span><br><span class="line"><span class="string">				console.log('render中的this:',this);//结果MyComponent的实例对象</span></span><br><span class="line"><span class="string">				return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		//2.渲染组件到页面</span></span><br><span class="line"><span class="string">		ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById('test'))  //const my = new MyComponent()</span></span><br><span class="line"><span class="string">		/* </span></span><br><span class="line"><span class="string">			执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？</span></span><br><span class="line"><span class="string">					1.React解析组件标签，找到了MyComponent组件。</span></span><br><span class="line"><span class="string">					2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</span></span><br><span class="line"><span class="string">					3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span></span><br><span class="line"><span class="string">		*/</span></span><br><span class="line"><span class="string">7.类式组件可以自定义方法————要用赋值语句的形式+箭头函数，否则this指向为undefined。</span></span><br><span class="line"><span class="string">	类中可以直接写赋值语句，就类似于在实例自身追加一个属性名</span></span><br><span class="line"><span class="string">  因为类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined。   </span></span><br><span class="line"><span class="string">  函数式不知道方法只能支持赋值语句。</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">8.方法的定义在render外部，解构赋值是在render内部</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">9.严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！React不认这样的更改//this.state.isHot = !isHot //这是错误的写法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10.对标签属性进行类型、必要性的限制放到类里   如果Person有初始化状态，就这样写state = &#123;&#125;在这里面写就可以了。</span></span><br><span class="line"><span class="string">    Person.propTypes = &#123;</span></span><br><span class="line"><span class="string">        name:PropTypes.string.isRequired, //限制name必传，且为字符串</span></span><br><span class="line"><span class="string">        sex:PropTypes.string,//限制sex为字符串</span></span><br><span class="line"><span class="string">        age:PropTypes.number,//限制age为数值</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Person.defaultProps = &#123;</span></span><br><span class="line"><span class="string">        sex:'男'，//sex默认值为男</span></span><br><span class="line"><span class="string">        age:18 //age默认值为18</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">11.用函数式创建组件，由于没有实例函数因此没有this。无法使用state和refs这两个属性 但是props属性例外。</span></span><br><span class="line"><span class="string">function Person (props)&#123;</span></span><br><span class="line"><span class="string">			const &#123;name,age,sex&#125; = props  **** C参数全部都在props</span></span><br><span class="line"><span class="string">			return (</span></span><br><span class="line"><span class="string">					&lt;div&gt;你好&lt;/div&gt;   </span></span><br><span class="line"><span class="string">				)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">12.	对标签属性进行类型、必要性的限制  类的关键字 static    ***可以当做简写形式</span></span><br><span class="line"><span class="string">    static propTypes = &#123;</span></span><br><span class="line"><span class="string">        name:PropTypes.string.isRequired, //限制name必传，且为字符串   把这两个东西放进一个打括号里</span></span><br><span class="line"><span class="string">        sex:PropTypes.string,//限制sex为字符串</span></span><br><span class="line"><span class="string">        age:PropTypes.number,//限制age为数值</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">13.渲染类组件标签的基本流程:</span></span><br><span class="line"><span class="string">		1.React解析组件标签，找到了MyComponent组件。</span></span><br><span class="line"><span class="string">        2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</span></span><br><span class="line"><span class="string">        3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span></span><br><span class="line"><span class="string">14. 强烈注意</span></span><br><span class="line"><span class="string">    *	组件中render方法中的this为组件实例对象</span></span><br><span class="line"><span class="string">    **	组件自定义的方法中this为undefined，如何解决？</span></span><br><span class="line"><span class="string">            a)	通过函数对象的bind()强制绑定this</span></span><br><span class="line"><span class="string">            b)	箭头函数</span></span><br><span class="line"><span class="string">	***	状态数据，不能直接修改或更新</span></span><br><span class="line"><span class="string">15.ref的三种形式</span></span><br><span class="line"><span class="string">	*   字符串形式的ref   &lt;input ref="</span>input1<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">        const &#123;input1&#125; = this.refs//调用的时候要加了s </span></span><br><span class="line"><span class="string">		这种字符串形式的ref马上要被废弃，因为string类型的refs存在一些效率上的问题。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    **  回调形式的ref    &lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c&#125;&#125;</span></span><br><span class="line"><span class="string">    	这么写的结果就是把ref当前所处的节点挂在了实例自身上，并且取了个名字叫input1</span></span><br><span class="line"><span class="string">        const &#123;input1&#125; = this//取input1就直接从实例自身取就可以了，直接写this即可</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string"> 	*** createRef创建ref容器·myRef = React.createRef()  &lt;input ref=&#123;this.myRef&#125;/&gt;</span></span><br><span class="line"><span class="string">        使用直接this.myRef.current....  即可</span></span><br><span class="line"><span class="string">        这是最推荐的 但是也是最繁琐的 因为有多少个ref就要创建多少个myRef</span></span><br><span class="line"><span class="string">        React.createRef调用后可以返回一个容器，该容器可以存储**被ref所标识的节点**,该容器是“专人专用”的</span></span><br><span class="line"><span class="string">        ref所在节点input被放到了myRef的容器里</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">16.回调函数的特点: 1、你定义的函数 2、你没调用 3、这函数最终执行了 </span></span><br><span class="line"><span class="string">17.事件的处理；</span></span><br><span class="line"><span class="string">				(1).通过onXxx属性指定事件处理函数(注意大小写)</span></span><br><span class="line"><span class="string">						a.React使用的是自定义(合成)事件, 而不是使用的原生DOM事件（onClick） —————— 为了更好的兼容性</span></span><br><span class="line"><span class="string">						b.React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)     ————————为了高效</span></span><br><span class="line"><span class="string">				(2).通过event.target得到发生事件的DOM元素对象 ——————————不要过度使用ref</span></span><br><span class="line"><span class="string">                   &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;</span></span><br><span class="line"><span class="string">            		//展示左侧输入框的数据</span></span><br><span class="line"><span class="string">                    showData = (event)=&gt;&#123;//发生事件的事件源</span></span><br><span class="line"><span class="string">                        console.log(event.target);**输出的是&lt;button&gt;点我提示左侧的数据&lt;/button&gt;</span></span><br><span class="line"><span class="string">                        alert(this.myRef.current.value);</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">				失去焦点那边可以省略ref 因为发生事件的元素正好是你操作的元素，就可以省略</span></span><br><span class="line"><span class="string">				点击按钮提示那个不能省略 因为给的是button加的Click事件，但是要拿input的数据</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">18.受控组件:输入类的DOM随着你的输入把东西维护到状态里去，等需要用的时候直接从状态里取出来</span></span><br><span class="line"><span class="string">				handleSubmit = (event)=&gt;&#123;</span></span><br><span class="line"><span class="string">                    event.preventDefault() //阻止表单提交</span></span><br><span class="line"><span class="string">                    const &#123;username,password&#125; = this.state//拿到的真正的值 下面就不用.value</span></span><br><span class="line"><span class="string">                    alert(`你输入的用户名是：$&#123;username&#125;,你输入的密码是：$&#123;password&#125;`)</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">				&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span></span><br><span class="line"><span class="string">						用户名：&lt;input onChange=&#123;this.saveUsername&#125; type="</span>text<span class="string">" name="</span>username<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">						密码：&lt;input onChange=&#123;this.savePassword&#125; type="</span>password<span class="string">" name="</span>password<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">						&lt;button&gt;登录&lt;/button&gt;</span></span><br><span class="line"><span class="string">				&lt;/form&gt;</span></span><br><span class="line"><span class="string">   非受控组件:现用现取</span></span><br><span class="line"><span class="string">   				const &#123;username,password&#125; = this //获取那两个节点</span></span><br><span class="line"><span class="string">				//对输入类的DOM 现用现取</span></span><br><span class="line"><span class="string">				alert(`你输入的用户名是：$&#123;username.value&#125;,你输入的密码是：$&#123;password.value&#125;`)</span></span><br><span class="line"><span class="string">                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span></span><br><span class="line"><span class="string">						用户名：&lt;input ref=&#123;c =&gt; this.username = c&#125; type="</span>text<span class="string">" name="</span>username<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">						密码：&lt;input ref=&#123;c =&gt; this.password = c&#125; type="</span>password<span class="string">" name="</span>password<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">						&lt;button&gt;登录&lt;/button&gt;&#123;/*点了登陆就触发那个表单提交*/&#125;</span></span><br><span class="line"><span class="string">				&lt;/form&gt;</span></span><br><span class="line"><span class="string">19.高阶函数:如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。</span></span><br><span class="line"><span class="string">        1.若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。</span></span><br><span class="line"><span class="string">        2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。</span></span><br><span class="line"><span class="string">        常见的高阶函数有：Promise、setTimeout、arr.map()等等</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   使用函数柯里化:不加小括号是因为把一个函数作为onChange回调，加了小括号我把这个函数返回值交给onChange回调，下面写的返回值就是                 一个函数 返回的就是函数。</span></span><br><span class="line"><span class="string">onChange=&#123;this.saveFormData('username')</span></span><br><span class="line"><span class="string">saveFormData = (dataType)=&gt;&#123; //dataTye就是传的东西</span></span><br><span class="line"><span class="string">        return (event)=&gt;&#123;  </span></span><br><span class="line"><span class="string">            this.setState(&#123;[dataType]:event.target.value&#125;) //函数作为onchange的回调是返回值作为回调</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">	//onchange要的就是一个函数 现在给的就是一个函数 onchange回调执行的时候 react帮你调用然后传入event</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   不使用函数柯里化:onChange=&#123;event =&gt; this.saveFormData('username',event) &#125; 直接传一个函数</span></span><br><span class="line"><span class="string">   	//保存表单数据到状态中  同时接到dataType event</span></span><br><span class="line"><span class="string">			saveFormData = (dataType,event)=&gt;&#123;</span></span><br><span class="line"><span class="string">				this.setState(&#123;[dataType]:event.target.value&#125;)  //因为上面传的是一个函数，因此这里就不用返回一个函数</span></span><br><span class="line"><span class="string">			&#125;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112071958382.png" alt="image-20211207195755851"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20.</span>组件生命周期理解</span><br><span class="line">    <span class="number">1.</span>	组件从创建到死亡它会经历一些特定的阶段。</span><br><span class="line">    <span class="number">2.</span>	React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。</span><br><span class="line">    <span class="number">3.</span>	我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。</span><br><span class="line"></span><br><span class="line">    **挂载时**</span><br><span class="line">    <span class="keyword">constructor</span>:组件构造函数，常用于初始化组件state，以及对组件内响应方法的绑定</span><br><span class="line"></span><br><span class="line">    componentWillMount:在第一次渲染前的钩子函数，也常用于初始化state，在新版生命周期中已弃用</span><br><span class="line"></span><br><span class="line">    render:组件渲染函数，返回一个jsx元素，用于显示真实DOM中的元素</span><br><span class="line"></span><br><span class="line">    componentDidMount:在组件挂载后执行，一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span><br><span class="line">    </span><br><span class="line">    **更新时**</span><br><span class="line">    compontentWillReceiveProps:</span><br><span class="line">    在父组件更新时会触发此函数，在此函数中可以根据props是否变化来setState，并且在此函数中的	setState不会再次触发子组件的		render</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate:/控制组件更新的“阀门” 应不应该更新状态</span><br><span class="line">	在setState和compontentWillReceiveProps后会触发此函数，可以在此函数中编写相关方法判断是否继续render，相当于一个自定义	  的diff函数</span><br><span class="line"></span><br><span class="line">    componentWillUpdate:组件的props或state发生改变后，render之前触发，在第一次组件挂载时不会触发此函数 ***弃用</span><br><span class="line"></span><br><span class="line">    render</span><br><span class="line"></span><br><span class="line">    componentDidUpdate:在组件的props或state更新完并执行完render后触发   </span><br><span class="line"></span><br><span class="line">    **卸载时**</span><br><span class="line">	componentWillUnmount:在组件卸载或者销毁之前触发  一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br><span class="line">    </span><br><span class="line">	其中componentWillMount、compontentWillReceiveProps、componentWillUpdate在新版生命周期中均已被弃用</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112072120099.png" alt="image-20211207212028192"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">新版生命周期:</span><br><span class="line">				<span class="number">1.</span> 初始化阶段: 由ReactDOM.render()触发---初次渲染</span><br><span class="line">								<span class="number">1.</span>	<span class="keyword">constructor</span>()</span><br><span class="line">								2.	getDerivedStateFromProps </span><br><span class="line">								3.	render()</span><br><span class="line">								4.	componentDidMount() =====&gt; 常用*****</span><br><span class="line">											一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span><br><span class="line">				2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发</span><br><span class="line">								1.	getDerivedStateFromProps</span><br><span class="line">								2.	shouldComponentUpdate()</span><br><span class="line">								3.	render()        ******必须要用</span><br><span class="line">								4.	getSnapshotBeforeUpdate</span><br><span class="line">								5.	componentDidUpdate()</span><br><span class="line">				3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发</span><br><span class="line">								1.	componentWillUnmount()  =====&gt; 常用***</span><br><span class="line">											一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br><span class="line"></span><br><span class="line">新版生命周期:中将较于旧版，增加了两个新的钩子，分别是getDerivedStateFromProps、getSnapshotBeforeUpdate，</span><br><span class="line">并弃用了componentWillMount、compontentWillReceiveProps、componentWillUpdate这三个钩子</span><br><span class="line"></span><br><span class="line">static getDerivedStateFromProps(nextProps, prevState) </span><br><span class="line">若state的值在任何时候都取决于props那么可以使用getDerivedStateFromProps  横跨挂载和更新</span><br><span class="line">    </span><br><span class="line">getDerivedStateFromProps为静态函数，传入参数为nextProps、prevState。其中，nextProps为将要更新的props，prevState	为上一个状态，可根据传入的props，以及过去的state来增加限制条件，防止无用的更新</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)</span><br><span class="line">	在更新之前获取快照 在组件更新DOM前调用，可以在此DOM更新前捕获一些页面信息（例如滚动位置），此生命周期返回的值会作为参数传入	 componentDidUpdate</span><br><span class="line">    </span><br><span class="line">key的作用</span><br><span class="line">经典面试题:</span><br><span class="line">      1). react/vue中的key有什么作用？（key的内部原理是什么？）</span><br><span class="line">      2). 为什么遍历列表时，key最好不要用index?</span><br><span class="line">      </span><br><span class="line">			1. 虚拟DOM中key的作用：</span><br><span class="line">					1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</span><br><span class="line"></span><br><span class="line">					2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, </span><br><span class="line">												随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</span><br><span class="line"></span><br><span class="line">									a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</span><br><span class="line">												(1).若虚拟DOM中内容没变, 直接使用之前的真实DOM</span><br><span class="line">												(2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实													 DOM</span><br><span class="line"></span><br><span class="line">									b. 旧虚拟DOM中未找到与新虚拟DOM相同的key</span><br><span class="line">												根据数据创建新的真实DOM，随后渲染到到页面</span><br><span class="line">									</span><br><span class="line">			2. 用index作为key可能会引发的问题： （this.setState(&#123;persons:[p,...persons]&#125;)这个就是破坏了顺序性操作）</span><br><span class="line">								<span class="number">1.</span> 若对数据进行：逆序添加、逆序删除等破坏顺序操作:</span><br><span class="line">												会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</span><br><span class="line"></span><br><span class="line">								<span class="number">2.</span> 如果结构中还包含输入类的DOM：</span><br><span class="line">												会产生错误DOM更新 ==&gt; 界面有问题。</span><br><span class="line">												</span><br><span class="line">								<span class="number">3.</span> 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，</span><br><span class="line">									仅用于渲染列表用于展示，使用index作为key是没有问题的。</span><br><span class="line">					</span><br><span class="line">			<span class="number">3.</span> 开发中如何选择key?:</span><br><span class="line">								<span class="number">1.</span>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</span><br><span class="line">								<span class="number">2.</span>如果确定只是简单的展示数据，用index也是可以的。</span><br><span class="line">            </span><br><span class="line">            慢动作回放----使用index索引值作为key</span><br><span class="line"></span><br><span class="line">			初始数据：</span><br><span class="line">					&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'小张'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">					&#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'小李'</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;,</span><br><span class="line">			初始的虚拟DOM：</span><br><span class="line">					&lt;li key=<span class="number">0</span>&gt;小张--<span class="number">-18</span>&lt;input type=<span class="string">"text"</span>/&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					/</span><span class="regexp">/这里的input框给小王用了 所以小张残留的信息给了小王了 因此会产生错误DOM更新，界面有问题</span></span><br><span class="line"><span class="regexp">					&lt;li key=1&gt;小李---19&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">			更新后的数据：</span></span><br><span class="line"><span class="regexp">					&#123;id:3,name:'小王',age:20&#125;,</span></span><br><span class="line"><span class="regexp">					&#123;id:1,name:'小张',age:18&#125;,</span></span><br><span class="line"><span class="regexp">					&#123;id:2,name:'小李',age:19&#125;,</span></span><br><span class="line"><span class="regexp">			更新数据后的虚拟DOM：</span></span><br><span class="line"><span class="regexp">					&lt;li key=0&gt;小王---20&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					&lt;li key=1&gt;小张---18&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					&lt;li key=2&gt;小李---19&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">	-----------------------------------------------------------------</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">			慢动作回放----使用id唯一标识作为key</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">			初始数据：</span></span><br><span class="line"><span class="regexp">					&#123;id:1,name:'小张',age:18&#125;,</span></span><br><span class="line"><span class="regexp">					&#123;id:2,name:'小李',age:19&#125;,</span></span><br><span class="line"><span class="regexp">			初始的虚拟DOM：</span></span><br><span class="line"><span class="regexp">					&lt;li key=1&gt;小张---18&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					&lt;li key=2&gt;小李---19&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">			更新后的数据：</span></span><br><span class="line"><span class="regexp">					&#123;id:3,name:'小王',age:20&#125;,</span></span><br><span class="line"><span class="regexp">					&#123;id:1,name:'小张',age:18&#125;,</span></span><br><span class="line"><span class="regexp">					&#123;id:2,name:'小李',age:19&#125;,</span></span><br><span class="line"><span class="regexp">			更新数据后的虚拟DOM：  因为把小王放在第一个了 所以遍历的时候小王是第一个</span></span><br><span class="line"><span class="regexp">					&lt;li key=3&gt;小王---20&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					&lt;li key=1&gt;小张---18&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					&lt;li key=2&gt;小李---19&lt;input type="text"/</span>&gt;&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="React应用-基于React脚手架"><a href="#React应用-基于React脚手架" class="headerlink" title="React应用(基于React脚手架)"></a>React应用(基于React脚手架)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用脚手架开发的项目的特点: 模块化, 组件化, 工程化</span><br><span class="line"><span class="number">2.</span>react脚手架项目结构:</span><br><span class="line">	(<span class="number">1</span>).index.html -------- 主页面</span><br><span class="line">    (<span class="number">2</span>).App.js    --------- App组件</span><br><span class="line">	(<span class="number">3</span>).index.js   ------- 入口文件</span><br><span class="line"><span class="number">3.</span>功能界面的组件化编码流程:</span><br><span class="line">	<span class="number">1.</span> 拆分组件: 拆分界面,抽取组件</span><br><span class="line">	<span class="number">2.</span> 实现静态组件: 使用组件实现静态页面效果</span><br><span class="line">	<span class="number">3.</span> 实现动态组件</span><br><span class="line">		<span class="number">3.1</span> 动态显示初始化数据</span><br><span class="line">            <span class="number">3.1</span><span class="number">.1</span> 数据类型</span><br><span class="line">            <span class="number">3.1</span><span class="number">.2</span> 数据名称</span><br><span class="line">            <span class="number">3.1</span><span class="number">.2</span> 保存在哪个组件?</span><br><span class="line">		<span class="number">3.2</span> 交互(从绑定事件监听开始</span><br><span class="line"><span class="number">4.</span><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)<span class="comment">//为什么能找到public里的index.html ,这是因为React底层帮忙写好的。     </span></span><br><span class="line"><span class="number">5.</span>状态在哪里，操作状态的方法就在哪里。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>常用的ajax请求库:</span><br><span class="line">    <span class="number">1.</span>	jQuery: 比较重, 如果需要另外引入不建议使用</span><br><span class="line">    <span class="number">2.</span>	axios: 轻量级, 建议使用</span><br><span class="line">        <span class="number">1</span>)	封装XmlHttpRequest对象的ajax</span><br><span class="line">        <span class="number">2</span>)	 promise风格</span><br><span class="line">        <span class="number">3</span>)	可以用在浏览器端和node服务器端</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>SPA的理解</span><br><span class="line">    <span class="number">1.</span>	单页Web应用（single page web application，SPA）。</span><br><span class="line">    <span class="number">2.</span>	整个应用只有一个完整的页面。</span><br><span class="line">    <span class="number">3.</span>	点击页面中的链接不会刷新页面，只会做页面的局部更新。</span><br><span class="line">    <span class="number">4.</span>	数据都需要通过ajax请求获取, 并在前端异步展现。</span><br></pre></td></tr></table></figure>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8.</span>路由的理解</span><br><span class="line">    <span class="number">1.</span>	一个路由就是一个映射关系(key:value)</span><br><span class="line">    <span class="number">2.</span>	key为路径, value可能是<span class="function"><span class="keyword">function</span>或<span class="title">component</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">9.路由分类</span></span><br><span class="line"><span class="function">    1.	后端路由：</span></span><br><span class="line"><span class="function">        (<span class="params"><span class="number">1</span></span>)	理解： <span class="title">value</span>是<span class="title">function</span>, 用来处理客户端提交的请求。</span></span><br><span class="line"><span class="function">        (<span class="params"><span class="number">2</span></span>)	注册路由： <span class="title">router</span>.<span class="title">get</span>(<span class="params">path, function(req, res</span>))</span></span><br><span class="line"><span class="function">        (<span class="params"><span class="number">3</span></span>)	工作过程：当<span class="title">node</span>接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</span></span><br><span class="line"><span class="function">    2.	前端路由：</span></span><br><span class="line"><span class="function">        (<span class="params"><span class="number">1</span></span>)	浏览器端路由，<span class="title">value</span>是<span class="title">component</span>，用于展示页面内容。</span></span><br><span class="line"><span class="function">        (<span class="params"><span class="number">2</span></span>)	注册路由: &lt;<span class="title">Route</span> <span class="title">path</span>="/<span class="title">test</span>" <span class="title">component</span>=</span>&#123;Test&#125;&gt;</span><br><span class="line">        (<span class="number">3</span>)	工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</span><br><span class="line"><span class="number">10.</span>react-router-dom的理解</span><br><span class="line">    <span class="number">1.</span>	react的一个插件库。</span><br><span class="line">    <span class="number">2.</span>	专门用来实现一个SPA应用。</span><br><span class="line">    <span class="number">3.</span>	基于react的项目基本都会用到此库。</span><br><span class="line"></span><br><span class="line">    内置组件</span><br><span class="line">    <span class="number">1.</span>	&lt;BrowserRouter&gt;</span><br><span class="line">    <span class="number">2.</span>	&lt;HashRouter&gt;</span><br><span class="line">    <span class="number">3.</span>	&lt;Route&gt;</span><br><span class="line">    <span class="number">4.</span>	&lt;Redirect&gt;</span><br><span class="line">    <span class="number">5.</span>	&lt;Link&gt;</span><br><span class="line">    <span class="number">6.</span>	&lt;NavLink&gt;</span><br><span class="line">    <span class="number">7.</span>	&lt;Switch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>redux是什么</span><br><span class="line">    (<span class="number">1</span>).redux是一个专门用于做状态管理的JS库(不是react插件库)。</span><br><span class="line">    (<span class="number">2</span>).它可以用在react, angular, vue等项目中, 但基本与react配合使用。</span><br><span class="line">    (<span class="number">3</span>).作用: 集中式管理react应用中多个组件共享的状态。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>什么情况下需要使用redux</span><br><span class="line">    (<span class="number">1</span>).某个组件的状态，需要让其他组件可以随时拿到（共享）。</span><br><span class="line">    (<span class="number">2</span>).一个组件需要改变另一个组件的状态（通信）。</span><br><span class="line">    (<span class="number">3</span>).总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</span><br><span class="line"><span class="number">3.</span> redux的三个核心概念</span><br><span class="line">    (<span class="number">1</span>).动作的对象</span><br><span class="line">    (<span class="number">2</span>).包含<span class="number">2</span>个属性</span><br><span class="line">    	type：标识属性, 值为字符串, 唯一, 必要属性</span><br><span class="line">     	data：数据属性, 值类型任意, 可选属性</span><br><span class="line">    (<span class="number">3</span>).例子：&#123; <span class="attr">type</span>: <span class="string">'ADD_STUDENT'</span>,<span class="attr">data</span>:&#123;<span class="attr">name</span>: <span class="string">'tom'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125; &#125;</span><br><span class="line"><span class="number">4.</span>reducer</span><br><span class="line">    <span class="number">1.</span>	用于初始化状态、加工状态。</span><br><span class="line">    <span class="number">2.</span>	加工时，根据旧的state和action， 产生新的state的纯函数。</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>store</span><br><span class="line">    <span class="number">1.</span>	将state、action、reducer联系在一起的对象</span><br><span class="line">    <span class="number">2.</span>	如何得到此对象?</span><br><span class="line">        <span class="number">1</span>)	<span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line">        <span class="number">2</span>)	<span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line">        <span class="number">3</span>)	<span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line">    <span class="number">3.</span>	此对象的功能?</span><br><span class="line">        <span class="number">1</span>)	getState(): 得到state</span><br><span class="line">        <span class="number">2</span>)	dispatch(action): 分发action, 触发reducer调用, 产生新的state</span><br><span class="line">        <span class="number">3</span>)	subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>redux的核心API</span><br><span class="line">	createstore()</span><br><span class="line">		作用：创建包含指定reducer的store对象</span><br><span class="line"><span class="number">7.</span>store对象</span><br><span class="line">    <span class="number">1.</span>	作用: redux库最核心的管理对象</span><br><span class="line">    <span class="number">2.</span>	它内部维护着:</span><br><span class="line">        <span class="number">1</span>)	state</span><br><span class="line">        <span class="number">2</span>)	reducer</span><br><span class="line">    <span class="number">3.</span>	核心方法:</span><br><span class="line">        <span class="number">1</span>)	getState()</span><br><span class="line">        <span class="number">2</span>)	dispatch(action)</span><br><span class="line">        <span class="number">3</span>)	subscribe(listener)</span><br><span class="line">    <span class="number">4.</span>	具体编码:</span><br><span class="line">        <span class="number">1</span>)	store.getState()</span><br><span class="line">        <span class="number">2</span>)	store.dispatch(&#123;<span class="attr">type</span>:<span class="string">'INCREMENT'</span>, number&#125;)</span><br><span class="line">        <span class="number">3</span>)	store.subscribe(render)</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>applyMiddleware():作用：应用上基于redux的中间件(插件库)</span><br><span class="line"><span class="number">9.</span>combineReducers():作用：合并多个reducer函数</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>redux异步编程理解：</span><br><span class="line">        <span class="number">1.</span>	redux默认是不能进行异步处理的, </span><br><span class="line">        <span class="number">2.</span>	某些时候应用中需要在redux中执行异步任务(ajax, 定时器)</span><br><span class="line">		使用异步中间件:npm install --save redux-thunk</span><br><span class="line">            <span class="number">1.</span>	一个react插件库</span><br><span class="line">            <span class="number">2.</span>	专门用来简化react应用中使用redux</span><br><span class="line">            </span><br><span class="line"><span class="number">11.</span> react-Redux将所有组件分成两大类</span><br><span class="line">    <span class="number">1.</span>	UI组件</span><br><span class="line">        <span class="number">1</span>)	只负责 UI 的呈现，不带有任何业务逻辑</span><br><span class="line">        <span class="number">2</span>)	通过props接收数据(一般数据和函数)</span><br><span class="line">        <span class="number">3</span>)	不使用任何 Redux 的 API</span><br><span class="line">        <span class="number">4</span>)	一般保存在components文件夹下</span><br><span class="line">    <span class="number">2.</span>	容器组件</span><br><span class="line">        <span class="number">1</span>)	负责管理数据和业务逻辑，不负责UI的呈现</span><br><span class="line">        <span class="number">2</span>)	使用 Redux 的 API</span><br><span class="line">        <span class="number">3</span>)	一般保存在containers文件夹下</span><br><span class="line"><span class="number">12.</span>相关API</span><br><span class="line">	<span class="number">1.</span>	Provider：让所有组件都可以得到state数据</span><br><span class="line">             &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">              &lt;App /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">	2.	connect：用于包装 UI 组件生成容器组件</span></span><br><span class="line"><span class="regexp"> 			import &#123; connect &#125; from 'react-redux'</span></span><br><span class="line"><span class="regexp">            connect(mapStateToprops,mapDispatchToProps)(Counter)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">	3.	mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性</span></span><br><span class="line"><span class="regexp">            const mapStateToprops = function (state) &#123;</span></span><br><span class="line"><span class="regexp">              return &#123;</span></span><br><span class="line"><span class="regexp">                value: state</span></span><br><span class="line"><span class="regexp">              &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">	4.	mapDispatchToProps：将分发action的函数转换为UI组件的标签属性</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">13.纯函数</span></span><br><span class="line"><span class="regexp">    1.	一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</span></span><br><span class="line"><span class="regexp">    2.	必须遵守以下一些约束  </span></span><br><span class="line"><span class="regexp">        1)	不得改写参数数据</span></span><br><span class="line"><span class="regexp">        2)	不会产生任何副作用，例如网络请求，输入和输出设备</span></span><br><span class="line"><span class="regexp">        3)	不能调用Date.now()或者Math.random()等不纯的方法  </span></span><br><span class="line"><span class="regexp">    3.	redux的reducer函数必须是一个纯函数</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">14.高阶函数</span></span><br><span class="line"><span class="regexp">    1.	理解: 一类特别的函数</span></span><br><span class="line"><span class="regexp">        1)	情况1: 参数是函数</span></span><br><span class="line"><span class="regexp">        2)	情况2: 返回是函数</span></span><br><span class="line"><span class="regexp">    2.	常见的高阶函数: </span></span><br><span class="line"><span class="regexp">        1)	定时器设置函数</span></span><br><span class="line"><span class="regexp">        2)	数组的forEach()/m</span>ap()/filter()/reduce()/find()/bind()</span><br><span class="line">        <span class="number">3</span>)	promise</span><br><span class="line">        <span class="number">4</span>)	react-redux中的connect函数</span><br><span class="line">    <span class="number">3.</span>	作用: 能实现更加动态, 更加可扩展的功能</span><br></pre></td></tr></table></figure>
<h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112081552249.png" alt="image-20211208153416819"></p>
<h3 id="简书项目"><a href="#简书项目" class="headerlink" title="简书项目"></a>简书项目</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、在reducer.js文件里,不能对原始的state做修改，为了防止这一点得引入facebook团队研发出来的一个库：immutable.js</span><br><span class="line"></span><br><span class="line">它会帮助我们生成一个immutable对象 （不可改变的）如果state是immutable对象就是不可以被改变，就不会出问题。</span><br><span class="line"><span class="number">2</span>、immutable这个库提供了一个fromJS方法，可以帮助我们把一个js对象转化为immutable对象，用这个方法把数据对象（js对象）</span><br><span class="line"></span><br><span class="line">转化为immutable对象。此时header下的index文件的mapState方法里的数据已经转化为immutable类型的数据（state.header）</span><br><span class="line"></span><br><span class="line">如果是immutable类型的数据，再进行state.header.focused这种语法是不合理的了。immutable.js里面调用state.header里的属性不能通过点focused的方式来调用，得通过点<span class="keyword">get</span>的方法传入focused的属性来获取对应的属性。此时不会报错，但是点击的时候就会报错报错的原因在与当你派发一个action的时候，传入reducers返回的是一个普通对象，普通对象时没有<span class="keyword">get</span>方法的 为了防止这种情况，可以使用immutable对象的<span class="keyword">set</span>方法，immutable对象的<span class="keyword">set</span>方法，会结合之前immutable对象的值和设置的值,返回一个全新的对象，此时没有改变原始的state</span><br><span class="line">3、：借助immutable这个库避免编写改变数据里state的情况</span><br><span class="line">4、获取ajax数据一般来说不会直接写在组件里，会把异步的操作放到action，或者放到redux-saga里面进行处理，这里统一使用redux-thunk，把异步操作都放至action里处理</span><br><span class="line">5、redux-thunk其实就是action和store之间的中间件 其实就是对dispatch方法的升级 以前的action返回的是一个对象，现在可以返回函数</span><br><span class="line">6、在public文件夹下创建一个api文件夹之后在创建headerList.json的文件输入一下数据 之后在网页访问这个链接页面就可以显示数据</span><br><span class="line">原理:首先先到功能目录下看看有没有对应的路由，找不到就会去public目录下找api的headerList.json，找到后就会把文件的内容输出出来</span><br><span class="line">通过这个特性，我们可以创建一些假数据，保存。模拟的数据要和后端对的数据要保持一致，就是定一下格式</span><br><span class="line">7、这样写实际上还是有问题的：创建store，默认list是一个空数组，fromJS方法会将js对象转换为immuable对象，list是个数组，也会变成immuable的数组，但是调用<span class="keyword">set</span>去改变list的时候，action.data实际上是一个普通的数组， list数组会由immuable数组变成一个普通的数组，这样的话数据类型就会变了，解决这个问题</span><br><span class="line">8、至于优化觉得可以做一些性能上的优化。因为每点击一次焦点的时候就会发送一次ajax请求。实际上列表中的数据获取一次就可以了</span><br><span class="line">解决问题：给``handleInputFocus(list)``传入list 然后输出list可以看出第一次请求的时候list.size是0，之后就是50，</span><br><span class="line">所以控制当size为0的时候才发送请求，之后不等于0的时候就不发生了，这样就避免了每次获取焦点的时候都发一个ajax请求，从而做到性能上的调优。</span><br><span class="line"></span><br><span class="line">9、前两周这个包刚更新过如果按之前的编码规则会使得路由组件无法显示</span><br><span class="line">import Home from './Home '</span><br><span class="line">老版本</span><br><span class="line">&lt;Route path=" / home" component=&#123; Home &#125; /&gt;</span><br><span class="line">新版本</span><br><span class="line">&lt;Route path=<span class="string">" / home"</span> element=&#123; &lt;Home/&gt; &#125; /&gt;</span><br><span class="line"><span class="number">10</span>、在public下的api定义一个接口home.json。之后在home组件下借助componentDidMount这个声明周期函数来发ajax请求去获取数据，获取了数据，（当组件挂载完毕）。就要将获取的数据取修改store里初试的数据</span><br><span class="line"><span class="number">11</span>、修改store里的数据也就是状态 就得使用connect的第二个参数，通过这个函数就可以定义一个方法将action派发给store，因为UI组件不能和store直接通信，只能通过容器组件。派发给store之后store就会派发给reducer。</span><br><span class="line"><span class="number">12</span>、因为首页的index.js都调用了connect的方法，和store做了连接，这就会产生一个问题，只要store发生了改变，那么每一个组件都会被重新渲染，也就是每个函数的render函数会被重新执行，可能有些数据发生改变了，但是那个数据和这个组件一点关系都没有，但是这个组件依然会被重新渲染，导致性能不好。提高组价性能 shouldComponentUpdata，可以在这里做性能优化的代码，判断只有与这个组件相关的数据发生改变才让render函数重新执行（重新渲染），否则<span class="keyword">return</span> <span class="literal">false</span>不让render函数重新执行。</span><br><span class="line">通过这种方式来避免虚拟DOM的比对，提高性能，react也考虑到了这点，如果你在每个特组件都去自己写should....太麻烦了，react内置了新的组件类型，引入PureComponent，区别就是PureComponent内在自己底层实现了should...,这样就不用我们手写收should......做性能优化。之后就是每个UI组件都替换为PureComponent</span><br><span class="line">之所以项目用**PureComponent**，是因为项目的数据管理用了immuable.js的框架，它可以保证我们的数据是immuable的，这样PureComponent和immuablejs数据格式的管理相结合，使用PureComponent一点问题都没有，但是如果你在你的项目里面，没有使用immuable.js管理你的数据，那么使用PureComponen有的时候会遇到坑。（偏底层的坑）</span><br><span class="line"><span class="number">13</span>、当我们在react实现页面跳转的时候，我们要用到react-router-dom第三方模块，它的这种跳转是单页应用跳转，link标签要在Router里面否则会报错</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/01/25/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">常规面试题</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-25T00:00:00+08:00">2021-01-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/25/%E9%9D%A2%E8%AF%95%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/25/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="HTML-CSS-面试题"><a href="#HTML-CSS-面试题" class="headerlink" title="HTML CSS 面试题"></a>HTML CSS 面试题</h2><h3 id="1、如何理解HTML-语义化？"><a href="#1、如何理解HTML-语义化？" class="headerlink" title="1、如何理解HTML 语义化？"></a>1、如何理解HTML 语义化？</h3><ul>
<li><p>让人更容易读懂（增加代码可读性）</p>
</li>
<li><p>让搜索引擎更容易读懂（SEO 搜索引擎优化）</p>
</li>
</ul>
<h3 id="2、默认情况下，哪些HTML-标签是块级元素、哪些是内联元素？"><a href="#2、默认情况下，哪些HTML-标签是块级元素、哪些是内联元素？" class="headerlink" title="2、默认情况下，哪些HTML 标签是块级元素、哪些是内联元素？"></a>2、默认情况下，哪些HTML 标签是块级元素、哪些是内联元素？</h3><ul>
<li><p>块级元素：display: block/table; 有div h1 h2 table ul ol p 等</p>
</li>
<li><p>内联元素：display: inline/inline-block; 有span img input button 等</p>
</li>
</ul>
<h3 id="3、盒子模型的宽度如何计算？"><a href="#3、盒子模型的宽度如何计算？" class="headerlink" title="3、盒子模型的宽度如何计算？"></a>3、盒子模型的宽度如何计算？</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101219090.png" alt="image-20211210121939411"></p>
<ul>
<li><p>offsetWidth = ( 内容宽度+ 内边距+ 边框)，无外边距</p>
</li>
<li><p>因此，答案是122px</p>
</li>
<li><p>补充：如果让offsetWidth 等于100px ，该如何做？  在div1样式做设置盒子模型为：IE盒子模型（box-sizing: border-box;）</p>
<blockquote>
<p>设置了box-sizing: border-box之后;宽度其实变成了78 加上内边距20 边框2 加起来就100了。</p>
</blockquote>
</li>
</ul>
<h3 id="4、argin-纵向重叠的问题"><a href="#4、argin-纵向重叠的问题" class="headerlink" title="4、argin 纵向重叠的问题"></a>4、argin 纵向重叠的问题</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101231157.png" alt="image-20211210123149043"></p>
<ul>
<li><p>相邻元素的margin-top 和margin-bottom 会发生重叠</p>
</li>
<li><p>空白内容的<p></p> 也会重叠   —&gt;空白内容重叠可忽略</p>
</li>
<li><p>答案：15px</p>
</li>
</ul>
<h3 id="5、margin-负值的问题"><a href="#5、margin-负值的问题" class="headerlink" title="5、margin 负值的问题"></a>5、margin 负值的问题</h3><blockquote>
<p>对margin 的top left right bottom 设置负值，有何效果？</p>
</blockquote>
<ul>
<li><p>margin-top 和margin-left 负值，元素向上、向左移动</p>
</li>
<li><p>margin-right 负值，右侧元素左移，自身不受影响</p>
</li>
<li><p>margin-bottom 负值，下方元素上移，自身不受影响</p>
</li>
</ul>
<h3 id="6-float-布局"><a href="#6-float-布局" class="headerlink" title="6.float 布局"></a>6.float 布局</h3><blockquote>
<p>如何实现圣杯布局和双飞翼布局? 手写clearfix</p>
</blockquote>
<p>圣杯布局和双飞翼布局的目的：</p>
<ul>
<li>三栏布局，中间一栏最先加载和渲染（内容最重要)</li>
<li>两侧内容固定，中间内容随着宽度自适应</li>
<li>一般用于PC网页</li>
</ul>
<p>圣杯布局例子:</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101320431.png" alt="image-20211210132014561"></p>
<p>三者都设置浮动且center宽度设置为百分百加上容器本身设置内边距</p>
<p>使得right的宽度无法在left的右侧排列被挤下来了</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101322479.png" alt="image-20211210132236216"></p>
<p>若要使得left移动至上图样式 设置margin-left：-100% ，设置这个实则就是父元素宽度的百分之百。也就是center（container）的宽度</p>
<p>（可以看成浮动元素它是别挤下来的 实际上是紧靠灰色部分的右侧。所以设置了这个就到了上图的位置） </p>
<p>之后在设置相对定位 （right：200px即可）因为设置了相对定位是相对于自身移动，对其他元素没有影响。（可以看到定位的坐标为灰色的左上顶点处）</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101331666.png" alt="image-20211210133101515"></p>
<p>给margin-right设置负150即可成为下图</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101332848.png" alt="image-20211210133244236"></p>
<p><strong>注意：不好理解！！！ 就是给自身元素设置的margin-right：自身宽度。就会使自身宽度不占位置从而上移</strong></p>
<blockquote>
<p>上述的布局就是圣杯布局  圣杯布局两边留白是通过padding设置的 而双飞翼布局是通过margin来进行两边留白的</p>
</blockquote>
<p>双飞翼布局:</p>
<ol>
<li>双飞翼布局是通过margin来进行两边留白。</li>
<li>left直接设置margin-left：-100%即可。</li>
</ol>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101343886.png" alt="image-20211210134341275"></p>
<p>right：也设置margin-left：-190px。</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101343263.png" alt="image-20211210134356122"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">手写clearfix  BFC解决清除浮动的问题</span><br><span class="line">	.clearfix:after&#123;</span><br><span class="line">        content:<span class="string">''</span>;</span><br><span class="line">        display:table;</span><br><span class="line">        clear:both;</span><br><span class="line">    &#125;</span><br><span class="line">将clearfix属性添加到容器的<span class="class"><span class="keyword">class</span>内。 因为是浮动元素，高度塌陷了。为了防止不塌陷所以在<span class="title">container</span>内设置该样式</span></span><br></pre></td></tr></table></figure>
<h3 id="7、flex-布局"><a href="#7、flex-布局" class="headerlink" title="7、flex 布局"></a>7、flex 布局</h3><blockquote>
<p> flex 实现一个三点的色子</p>
</blockquote>
<ul>
<li>flex-direction :主轴方向（横向或者纵向）</li>
<li>justify-content：主轴对齐方式（开始对齐，居中对齐，结束对齐）</li>
<li>align-items：交叉轴的对齐方式（开始对齐，居中对齐，结束对齐）</li>
<li>flex-wrap：换行</li>
<li>align-self：子元素在交叉轴的对齐方式（开始对齐，居中对齐，结束对齐）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">    .box &#123;</span><br><span class="line">        width: <span class="number">200</span>px;</span><br><span class="line">        height: <span class="number">200</span>px;</span><br><span class="line">        border: 2px solid #ccc;</span><br><span class="line">        border-radius: <span class="number">10</span>px;</span><br><span class="line">        padding: <span class="number">20</span>px;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;<span class="comment">/*对齐方式：两边对齐*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    .item &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        width: <span class="number">40</span>px;</span><br><span class="line">        height: <span class="number">40</span>px;</span><br><span class="line">        border-radius: <span class="number">50</span>%;</span><br><span class="line">        background-color: #666;</span><br><span class="line">    &#125;</span><br><span class="line">    .item:nth-child(<span class="number">2</span>) &#123;</span><br><span class="line">        align-self: center; <span class="comment">/*第二个子元素垂直居中*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    .item:nth-child(<span class="number">3</span>) &#123;</span><br><span class="line">        align-self: flex-end;<span class="comment">/*第三个子元素垂直方向尾对齐*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="box"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span class="item"&gt;&lt;/</span>span&gt;</span><br><span class="line">        &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span class="item"&gt;&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101458568.png" alt="image-20211210145834952"></p>
<h3 id="8、absolute-和relative-分别依据什么定位？"><a href="#8、absolute-和relative-分别依据什么定位？" class="headerlink" title="8、absolute 和relative 分别依据什么定位？"></a>8、absolute 和relative 分别依据什么定位？</h3><blockquote>
<p>relative 依据自身定位</p>
<p>absolute 依据最近一层的定位元素定位（定位元素有：absolute relative fixed  body）</p>
</blockquote>
<h3 id="9、居中对齐有哪些实现方式？"><a href="#9、居中对齐有哪些实现方式？" class="headerlink" title="9、居中对齐有哪些实现方式？"></a>9、居中对齐有哪些实现方式？</h3><blockquote>
<p>水平居中</p>
<p>垂直居中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">水平居中:</span><br><span class="line">    inline 元素：text-align: center</span><br><span class="line">    block 元素：margin: auto</span><br><span class="line">    absolute 元素：left: <span class="number">50</span>% + margin-left 负值</span><br><span class="line">垂直居中:</span><br><span class="line">	inline 元素：line-height的值等于height 值</span><br><span class="line">    absolute 元素：top: <span class="number">50</span>% + margin-top 负值  **必须知道子元素的尺寸</span><br><span class="line">    absolute 元素：transform(<span class="number">-50</span>%, <span class="number">-50</span>%)  </span><br><span class="line"> 	absolute 元素：top, left, bottom, right = <span class="number">0</span> + margin: auto</span><br></pre></td></tr></table></figure>
<h3 id="10、CSS-图文样式"><a href="#10、CSS-图文样式" class="headerlink" title="10、CSS -图文样式"></a>10、CSS -图文样式</h3><blockquote>
<p>line-height 如何继承</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101431321.png" alt="image-20211210143133796"></p>
<ul>
<li>写具体数值，如30px ，则继承该值（比较好理解）<ul>
<li>就直接继承30px</li>
</ul>
</li>
<li>写比例，如2 / 1.5 ，则继承该比例（比较好理解）<ul>
<li>直接比例乘以p标签的font-size 2*16=32px</li>
</ul>
</li>
<li>写百分比，如200% ，则继承计算出来的值（考点）<ul>
<li>直接body里的font-size的比例乘200%就是20*2=40px</li>
</ul>
</li>
</ul>
<h3 id="11、CSS-响应式"><a href="#11、CSS-响应式" class="headerlink" title="11、CSS -响应式"></a>11、CSS -响应式</h3><blockquote>
<p>rem 是什么？</p>
<p>响应式布局的常见方案？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rem 是什么？</span><br><span class="line">	rem 是一个长度单位</span><br><span class="line">    	px ，绝对长度单位，最常用</span><br><span class="line">        em ，相对长度单位，相对于父元素，不常用</span><br><span class="line">        rem ，相对长度单位，相对于根元素，常用于响应式布局</span><br><span class="line">          html &#123;</span><br><span class="line">            font-size: <span class="number">100</span>px;  <span class="comment">//等于1rem</span></span><br><span class="line">        &#125;</span><br><span class="line">		**任何使用长度的地方都可以用rem  例如宽度高度都可以</span><br><span class="line">响应式布局的常见方案？</span><br><span class="line">	media-query，根据不同的屏幕宽度设置根元素font-size</span><br><span class="line"> 	body &#123;</span><br><span class="line">            font-size: <span class="number">0.16</span>rem;  <span class="comment">/*在iphone6/7 就是16px*/</span></span><br><span class="line">        &#125;</span><br><span class="line">	rem，基于根元素的相对单位</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript面试题"><a href="#JavaScript面试题" class="headerlink" title="JavaScript面试题"></a>JavaScript面试题</h2><h3 id="1、typeof-能判断的类型"><a href="#1、typeof-能判断的类型" class="headerlink" title="1、typeof 能判断的类型?"></a>1、typeof 能判断的类型?</h3><blockquote>
<p>考点：JS变量类型</p>
</blockquote>
<h3 id="2、何时使用-何时使用"><a href="#2、何时使用-何时使用" class="headerlink" title="2、何时使用===何时使用=="></a>2、何时使用===何时使用==</h3><blockquote>
<p>考点：强制类型转换</p>
</blockquote>
<h3 id="3、window-onload和-DOMContentLoaded区别"><a href="#3、window-onload和-DOMContentLoaded区别" class="headerlink" title="3、window.onload和 DOMContentLoaded区别"></a>3、window.onload和 DOMContentLoaded区别</h3><blockquote>
<p>考点:页面加载过程，（页面渲染过程）</p>
</blockquote>
<h3 id="4、JS创建10个标签，点击弹出对应的序号"><a href="#4、JS创建10个标签，点击弹出对应的序号" class="headerlink" title="4、JS创建10个标签，点击弹出对应的序号"></a>4、JS创建10个<a>标签，点击弹出对应的序号</h3><blockquote>
<p>考点:JS作用域</p>
</blockquote>
<h3 id="5、手写节流throttle和防抖debounce"><a href="#5、手写节流throttle和防抖debounce" class="headerlink" title="5、手写节流throttle和防抖debounce"></a>5、手写节流throttle和防抖debounce</h3><blockquote>
<p>考点:性能、体验优化</p>
</blockquote>
<h3 id="6、Promise解决什么问题"><a href="#6、Promise解决什么问题" class="headerlink" title="6、Promise解决什么问题?"></a>6、Promise解决什么问题?</h3><blockquote>
<p>考点:JS异步 </p>
</blockquote>
<h3 id="7、值类型和引用类型的区别"><a href="#7、值类型和引用类型的区别" class="headerlink" title="7、值类型和引用类型的区别"></a>7、值类型和引用类型的区别</h3><blockquote>
<p>值类型各用各的，不会相互干扰。而引用类型一旦赋值了 b改变了 a也改变了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**值类型</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a=<span class="number">200</span></span><br><span class="line">log(b)<span class="comment">//100</span></span><br><span class="line">**引用数据类型</span><br><span class="line"><span class="keyword">let</span> a=&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b=a</span><br><span class="line">b.age=<span class="number">21</span></span><br><span class="line">log(a.age)<span class="comment">//21</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101608311.png" alt="image-20211210160818584"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101608586.png" alt="image-20211210160828452"></p>
<h3 id="8、typeof-运算符"><a href="#8、typeof-运算符" class="headerlink" title="8、typeof 运算符"></a>8、typeof 运算符</h3><ul>
<li><p>识别所有值类型</p>
</li>
<li><p>识别函数</p>
</li>
<li><p>判断是否是引用类型（不可再细分)</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101845522.png" alt="image-20211210184526582"></p>
</li>
</ul>
<h3 id="9、深拷贝"><a href="#9、深拷贝" class="headerlink" title="9、深拷贝"></a>9、深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">	age: <span class="number">20</span>,</span><br><span class="line">    name: <span class="string">'xx×'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">	city: <span class="string">'beijing'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	arr:[ <span class="string">'a'</span>,<span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const obj2 = obj1</span></span><br><span class="line"><span class="keyword">const</span> obj2 = deepClone(obj1)  <span class="comment">//这边就是进行了深拷贝</span></span><br><span class="line"></span><br><span class="line">obj2.address.city = <span class="string">'shanghai'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.address.city) <span class="comment">//这是浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝就是obj2改了 obj1不会变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>||obj ==<span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">//obj是null,或者不是对象或者不是数组,直接返回</span></span><br><span class="line">        <span class="keyword">return</span> obj                                       *****************</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化返回结果  obj是对象和数组</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">	<span class="keyword">if</span> （obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        result = []</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		result = &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;  <span class="comment">//是数组和对象就可以遍历</span></span><br><span class="line">    	<span class="comment">//保证key（age,name...） 是自己的属性，而不是原型的属性 因为这里没有考虑到原型上的东西可忽略，但是面试的时候不可忽略</span></span><br><span class="line">    	<span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    	<span class="comment">//递归调用!!!</span></span><br><span class="line">    		result[key] = deepclone(obj[key])<span class="comment">//obj[key]就是key对应的值  首先20进来在*****返回了</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***<span class="keyword">let</span> result = &#123;</span><br><span class="line">	age: <span class="number">20</span>,</span><br><span class="line">    name: <span class="string">'xx×'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">		city: <span class="string">'beijing'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	arr:[ <span class="string">'a'</span>,<span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;   <span class="comment">//深拷贝的结果。</span></span><br></pre></td></tr></table></figure>
<h3 id="10、变量计算-类型转换"><a href="#10、变量计算-类型转换" class="headerlink" title="10、变量计算-类型转换"></a>10、变量计算-类型转换</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101836320.png" alt="image-20211210183556963"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101903385.png" alt="image-20211210190327229"></p>
<blockquote>
<p>let x1=obj1.x 是干扰人的</p>
</blockquote>
<h3 id="11、原型和原型链"><a href="#11、原型和原型链" class="headerlink" title="11、原型和原型链"></a>11、原型和原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**两种写的方式**</span><br><span class="line"><span class="built_in">console</span>. log(</span><br><span class="line"><span class="string">`姓名<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> ，学号<span class="subst">$&#123;<span class="keyword">this</span>.number&#125;</span></span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(</span></span><br><span class="line"><span class="string">'姓名'+ this.name + '，学号'+this.number</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure>
<p><strong>class</strong></p>
<ul>
<li><p>constructor</p>
</li>
<li><p>属性</p>
</li>
<li><p>方法</p>
</li>
</ul>
<p><strong>继承</strong></p>
<ul>
<li>extends</li>
<li>super</li>
<li>扩展或重写方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>( name) &#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">	&#125;	</span><br><span class="line">	eat() &#123;</span><br><span class="line">	<span class="built_in">console</span>. log(<span class="string">`$ithis.name&#125; eat something`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, number) &#123;</span><br><span class="line">	<span class="keyword">super</span>(name) <span class="comment">//继承父类的name</span></span><br><span class="line">	<span class="keyword">this</span>.number = number</span><br><span class="line">	&#125;</span><br><span class="line">	sayHi()&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`姓名 <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>学号<span class="subst">$&#123;<span class="keyword">this</span>.number&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xialuo = <span class="keyword">new</span> Student(<span class="string">'夏洛'</span>,<span class="number">100</span>)</span><br><span class="line">log(xialuo.name)</span><br><span class="line">log(xialuo.number)</span><br><span class="line">xialuo.sayHi()</span><br><span class="line">xialuo.eat()</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101928446.png" alt="image-20211210192840339"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101931965.png" alt="image-20211210193103817"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101950046.png" alt="image-20211210195041939"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101951660.png" alt="image-20211210195103225"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112101955937.png" alt="image-20211210195508425"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102018741.png" alt="image-20211210201830160"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、如何准确判断一个变量是不是数组?</span><br><span class="line">    a <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br></pre></td></tr></table></figure>
<h3 id="12、作用域和闭包"><a href="#12、作用域和闭包" class="headerlink" title="12、作用域和闭包"></a>12、作用域和闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">this</span>的不同应用场景，如何取值?</span><br><span class="line"><span class="number">2</span>、手写bind 函数</span><br><span class="line"><span class="number">3</span>、实际开发中闭包的应用场景，举例说明</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102030318.png" alt="image-20211210203042511"></p>
<p><strong>作用域</strong></p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域(ES6新增)</li>
</ul>
<blockquote>
<p>if for {} 就是块级作用域</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102044389.png" alt="image-20211210204400524"></p>
<p><strong>自由变量</strong></p>
<ul>
<li><p>一个变量在当前作用域没有定义，但被使用了</p>
</li>
<li><p>向上级作用域,一层一层依次寻找，直至找到为止</p>
</li>
<li><p>如果到全局作用域都没找到，则报错xx is not defined</p>
</li>
</ul>
<p><strong>闭包</strong></p>
<p>作用域应用的特殊情况，有两种表现:</p>
<ul>
<li>函数作为参数被传递</li>
<li>函数作为返回值被返回</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102047593.png" alt="image-20211210204753650"></p>
<blockquote>
<p>答案为100</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102048254.png" alt="image-20211210204829747"></p>
<blockquote>
<p>答案为100</p>
</blockquote>
<p><strong>闭包:自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方!!!</strong></p>
<h3 id="13、this"><a href="#13、this" class="headerlink" title="13、this"></a>13、this</h3><blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>作为普通函数被调用  -&gt;window</li>
<li>使用call apply bind- &gt;传入什么就是绑定什么</li>
<li>作为对象方法被调用 -&gt;返回对象本身</li>
<li>在class方法中调用 -&gt;当前实例本身</li>
<li>箭头函数 -&gt;上级作用域的this的值来决定</li>
</ul>
<p><strong>注意：this取什么值，是在函数执行的时候确认的，不是在函数定义的时候确认的</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102056796.png" alt="image-20211210205632681"></p>
<blockquote>
<p>bind和call的区别是  bind会返回一个新的函数再去执行</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102057499.png" alt="image-20211210205745060"></p>
<blockquote>
<p>this===window是因为function这个函数执行本身是setTimeout触发的执行，它并不是zhangsan.方法触发的执行。</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112102100839.png" alt="image-20211210210004770"></p>
<blockquote>
<p>特点：箭头函数本身没有this都是取它上级作用域的this</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">手写bind函数</span><br><span class="line">由于fun1的隐式原型===<span class="built_in">Function</span>的显示原型</span><br><span class="line">bind方法只有在<span class="built_in">Function</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    log(a,b,c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'this is fn1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 =fn1.bind(&#123;<span class="attr">x</span>:<span class="number">100</span>&#125;,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> res = fn2()</span><br><span class="line">log(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//把参数列表变成数组</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototypes.slice.call(<span class="built_in">arguments</span>)<span class="comment">//slice是Array.prototypes上的API</span></span><br><span class="line">    <span class="comment">//获取this(数组的第一项)</span></span><br><span class="line">    <span class="keyword">const</span> t =args.shift()</span><br><span class="line">    <span class="comment">//fn1.bidn(...)中的fn1</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//因为上面fn1.bind返回的是一个函数 函数是要执行的</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(t,args)<span class="comment">//这里的args已经为20,30,40 因为上面做了shift的操作会改变原数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i a</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">            a.innerHTML = i + <span class="string">'&lt;br&gt;'</span></span><br><span class="line">            a.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                e.preventDefault()</span><br><span class="line">                alert(i)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(a)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">如果是上述代码 无论点哪个标签都是显示<span class="number">10</span>，因为此时i是全局作用域，只有当点击的时候才会去执行回调函数，而回调函数的alert(i)是一个自由变量所以会去全局找（循环都结束了），因为都是<span class="number">10</span>  （js引擎在退出循环的时候，迭代变量i保存的是导致循环退出的值）</span><br><span class="line">    <span class="keyword">let</span> a</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">            a.innerHTML = i + <span class="string">'&lt;br&gt;'</span></span><br><span class="line">            a.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="comment">//不会立马执行</span></span><br><span class="line">                e.preventDefault()</span><br><span class="line">                alert(i)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(a)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">如果是上述代码就可以避免这个问题，因为此时i为块级作用域，（js引擎在后台会为每个迭代循环声明一个新的迭代变量），自由变量i就会在块中去找，因此就可以实现点击什么显示什么。</span><br></pre></td></tr></table></figure>
<h3 id="14、异步和单线程"><a href="#14、异步和单线程" class="headerlink" title="14、异步和单线程"></a>14、异步和单线程</h3><p><strong>JS本质是单线程的。</strong>也就是说，它并不能像JAVA语言那样，两个线程并发执行。但我们平时看到的JS，分明是可以同时运作很多任务的，这又是怎么回事呢？</p>
<p>首先，JS的代码，大致分为两类，<strong><a href="https://www.zhihu.com/search?q=同步代码&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A265349066}" target="_blank" rel="noopener">同步代码</a></strong>和<strong>异步代码</strong>。JS引擎的主线程负责执行代码，由于只有这一个线程，执行当然是同步的，即按照顺序来。另外，还有一个叫做<strong><a href="https://www.zhihu.com/search?q=任务队列&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A265349066}" target="_blank" rel="noopener">任务队列</a></strong>的东西，所有的异步代码都是从队列当中来。</p>
<p>所以实际上我们会发现，JS根本不可能同时执行两个任务，本质上还是单线程。</p>
<blockquote>
<p> 因为这些任务的发生都不是在当下，而是过段时间以后再执行。因此时间不可控，你不能因为5秒后要执行一个函数，就让主线程闲置5秒什么都不干吧？所以你只能继续执行后续的同步代码。而当你单击鼠标或滚动窗口时，主线程可能正在执行其它代码，忙着呢！没工夫处理，因此，事件触发线程就负责来接收这个事件，并把要执行的任务暂时保存在任务队列当中。等主线程把手里的同步代码执行完，就立刻会向任务队列提取最新的任务。</p>
</blockquote>
<p><strong>单线程和异步</strong></p>
<ul>
<li>遇到等待(网络请求，定时任务)不能卡住</li>
<li>需要异步</li>
<li>回调callback函数形式</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112110932233.png" alt="image-20211211093254048"></p>
<blockquote>
<p>异步打印顺序100 300 200  异步不会阻塞 后面代码的执行300会立马出来。</p>
<p>同步 弹出200会卡主 不点确定300不会出来</p>
</blockquote>
<ul>
<li>基于JS是单线程语言</li>
<li>异步不会阻塞代码执行</li>
<li>同步会阻塞代码执行</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>网络请求，如ajax图片加载</li>
<li>定时任务，如setTimeout</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">手写<span class="built_in">Promise</span>加载一张图片 代码演示</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'http...'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p =  <span class="keyword">new</span> <span class="built_in">Promise</span>(  <span class="comment">//Promise传入一个函数 函数有两个参数</span></span><br><span class="line">    (resolve,reject)=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">        img.onload=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`图片加载失败<span class="subst">$&#123;src&#125;</span>`</span>))<span class="comment">//或者 const err = new Error()/ reject(err)</span></span><br><span class="line">        &#125;</span><br><span class="line">        img.src =src</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">loadImg(url).then(接收一个函数函数就是上面resolve里面的对象)                    <span class="comment">//Promise对象就有thenloadImg(url).then(img=&gt;&#123;</span></span><br><span class="line">	<span class="built_in">console</span>.log(img.width)</span><br><span class="line">	<span class="keyword">return</span> img</span><br><span class="line">&#125;).then(<span class="function"><span class="params">img</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.height)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">ex</span>=&gt;</span><span class="built_in">console</span>.error(ex))</span><br><span class="line"></span><br><span class="line">情况<span class="number">2</span> 如果有两张图</span><br><span class="line">thenloadImg(url).then(<span class="function"><span class="params">img</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(img.width)</span><br><span class="line">	<span class="keyword">return</span> img   <span class="comment">//普通对象   **如果是普通对象下一个then函数里参数就会接收到返回的对象</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">img</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.height)</span><br><span class="line">    <span class="keyword">return</span> loadImg(url2)<span class="comment">//promise实例**如果是promise实例的话下一个then函数里的参数是loadImg(u2)加载完成之后的图片对象</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">img2</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img2.width)</span><br><span class="line">    <span class="keyword">return</span> img2</span><br><span class="line">&#125;)</span><br><span class="line">这就是利用promise解决回调地狱的问题</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<ul>
<li>单线程和异步，异步和同步区别<ul>
<li>基于JS是单线程语言</li>
<li>异步不会阻塞代码执行</li>
<li>同步会阻塞代码执行</li>
</ul>
</li>
<li>前端异步的应用场景:<ul>
<li>网络请求</li>
<li>定时任务</li>
</ul>
</li>
<li>Promise解决callback hell</li>
</ul>
<h3 id="15、JS-Web-API（DOM）"><a href="#15、JS-Web-API（DOM）" class="headerlink" title="15、JS Web API（DOM）"></a>15、JS Web API（DOM）</h3><ul>
<li>DOM</li>
<li>BOM</li>
<li>事件绑定</li>
<li>ajax</li>
<li>存储</li>
</ul>
<p><strong>vue 和React框架应用广泛，封装了DOM操作</strong><br><strong>但DOM操作一直都会前端工程师的基础、必备知识</strong><br><strong>只会vue而不懂 DOM操作的前端程序员，不会长久</strong></p>
<blockquote>
<p>不要被工具和框架限制了自己的能力</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、DOM的本质是从HTML文件解译出的一棵树（一层一层）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、DOM是哪种数据结构</span><br><span class="line">	是树（DOM树）结构</span><br><span class="line"><span class="number">3</span>、DOM操作的常用API</span><br><span class="line">	* DOM节点的操作</span><br><span class="line">    * DOM结构操作</span><br><span class="line">    * attribute和property的操作</span><br><span class="line"><span class="number">4</span>、attr和property 的区别</span><br><span class="line">	* property:修改对象属性，不会体现到 html结构中（尽量用这个）</span><br><span class="line">	* attribute:修改html 属性，会改变html结构</span><br><span class="line">	* 两者都有可能引起 DOM重新渲染</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111029555.png" alt="image-20211211102904678"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111029346.png" alt="image-20211211102949224"></p>
<blockquote>
<p>property本身不是API的一部分，是一种JS属性操作的形式</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111033030.png" alt="image-20211211103301872"></p>
<blockquote>
<p>设置attribute会将设置的属性嵌到dom结构里的（修改标签的属性）</p>
<p> 而property修改的是JS变量的一个属性（不会对标签产生任何的影响）</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111034273.png" alt="image-20211211103431882"></p>
<p><strong>property和attribute</strong></p>
<ul>
<li>property:修改对象属性，不会体现到 html结构中（尽量用这个）</li>
<li>attribute:修改html 属性，会改变html结构</li>
<li>两者都有可能引起 DOM重新渲染</li>
</ul>
<p><strong>DOM结构操作</strong></p>
<ul>
<li>新增/插入节点</li>
<li>获取子元素列表,获取父元素</li>
<li>删除子元素</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111041651.png" alt="image-20211211104105539"></p>
<blockquote>
<p>移动节点就是原本div1没有p2的 设置了此操作div1就有了p2</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111043263.png" alt="image-20211211104241164"></p>
<blockquote>
<p>获取子元素列表有时候不是我们想要的 因为它会将文本元素一块打印出来</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先先将divchild变成一个数组再进行遍历</span></span><br><span class="line"><span class="comment">//Array.prototype.slice.call(div1.childNodes)就是将返回的结果变成一个数组</span></span><br><span class="line"><span class="keyword">const</span> divchild = <span class="built_in">Array</span>.prototype.slice.call(div1.childNodes).filter(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(child.nodeType===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'divchild'</span>,divchild)<span class="comment">//结果就是dom元素 3个p标签/就不是text文本</span></span><br><span class="line"></span><br><span class="line">**filter()：方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素；不会改变原始数组；</span><br><span class="line"><span class="keyword">return</span>后面判断结果，取布尔值，<span class="literal">true</span>的话就添入新的filter数组中，<span class="literal">false</span>的话，不会添进filter的数组中。**</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111053378.png" alt="image-20211211105346903"></p>
<p><strong>DOM性能</strong></p>
<ul>
<li>DOM操作非常“昂贵”，避免频繁的DOM操作（占用CPU多 ）</li>
<li>对DOM查询做缓存</li>
<li>将频繁操作改为一次性操作</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111108747.png" alt="image-20211211110819646"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>；i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">    li.innerHTML = <span class="string">`LIST Item <span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">    list.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line">这样就是频繁操作DOM,耗费性能</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111125652.png" alt="image-20211211112538924"></p>
<h3 id="16、BOM操作（Browser-Object-Model）"><a href="#16、BOM操作（Browser-Object-Model）" class="headerlink" title="16、BOM操作（Browser Object Model）"></a>16、BOM操作（Browser Object Model）</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111437471.png" alt="image-20211211143716541"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111437609.png" alt="image-20211211143728545"></p>
<h3 id="17、事件"><a href="#17、事件" class="headerlink" title="17、事件"></a>17、事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、编写一个通用的事件监听函数</span><br><span class="line"><span class="number">2</span>、描述事件冒泡的流程</span><br><span class="line"><span class="number">3</span>、无限下拉的图片列表,如何监听每个图片的点击?</span><br></pre></td></tr></table></figure>
<p><strong>事件绑定</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111439359.png" alt="image-20211211143946225"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111441678.png" alt="image-20211211144103348"></p>
<blockquote>
<p>elem：绑定的按钮id </p>
</blockquote>
<p><strong>事件冒泡</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111452922.png" alt="image-20211211145246199"></p>
<p><strong>stopPropagation组织冒泡 没有这个点击激活的时候由于会冒泡到body就会触发body从而打印取消</strong></p>
<p><strong>事件代理（是基于事件冒泡来做的）</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111455966.png" alt="image-20211211145459660"></p>
<blockquote>
<p>绑定在父元素上 代码简介 （比每一个a标签都绑定一个元素）</p>
<p>减少浏览器的内存占用 （每一个a标签都去挂载事件监听，耗内存）</p>
<p>禁止滥用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem,type,selector,fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fn == <span class="literal">null</span>) &#123;   <span class="comment">//传递三个参数和四个参数的对比</span></span><br><span class="line">		fn = selector</span><br><span class="line">    	selector = <span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">elem.addEventListener(type,event =&gt; &#123;   <span class="comment">//整体对照下面的例子进行观察</span></span><br><span class="line">    	<span class="keyword">const</span> target = event.target<span class="comment">//触发的元素</span></span><br><span class="line">		<span class="keyword">if</span> (selector) &#123;  <span class="comment">//这里的selector就是a</span></span><br><span class="line">		<span class="comment">//代理绑定</span></span><br><span class="line">            <span class="keyword">if</span>(target.matches(selector))&#123; <span class="comment">//target.matches一个DOM元素是否符合CSS选择器</span></span><br><span class="line">                fn.call(target,event)</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//普通绑定</span></span><br><span class="line">            fn.call(target,event)<span class="comment">//这里的target就是this的意思</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通绑定</span></span><br><span class="line"><span class="keyword">const</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">'btn1'</span>)</span><br><span class="line">bindEvent(btn1, <span class="string">'click'</span> , event =&gt;&#123;</span><br><span class="line">	<span class="comment">//console.log (event.target）//获取触发的元素</span></span><br><span class="line">    event.preventDefault()<span class="comment">//阻止默认行为</span></span><br><span class="line">	alert(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//代理绑定</span></span><br><span class="line"><span class="keyword">const</span> div3 = <span class="built_in">document</span>.getElementById (<span class="string">'div3'</span>)</span><br><span class="line">bindEvent(div3, <span class="string">'click '</span>,<span class="string">'a'</span>, event =&gt;&#123;</span><br><span class="line">	event.preventDefault()</span><br><span class="line">	alert(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">'btn1'</span>)</span><br><span class="line">bindEvent(btn1, <span class="string">'click'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">event </span>)</span>&#123;</span><br><span class="line">	<span class="comment">//console.log (event.target）//获取触发的元素</span></span><br><span class="line">    event.preventDefault()<span class="comment">//阻止默认行为</span></span><br><span class="line">	alert(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//代理绑定</span></span><br><span class="line"><span class="keyword">const</span> div3 = <span class="built_in">document</span>.getElementById (<span class="string">'div3'</span>)</span><br><span class="line">bindEvent(div3, <span class="string">'click '</span>,<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	event.preventDefault()</span><br><span class="line">	alert(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111532295.png" alt="image-20211211153208756"></p>
<p><strong>下图就可以验证target.matches(selector) 其中代理绑定的是a标签不是button标签，因此就可以判断是否符合css选择器</strong></p>
<blockquote>
<p>上述代码有错误，因为箭头函数没有this，会向上级作用域查找，为window，而window.innerHTML就不符合要求了</p>
<p>因此得将箭头函数转换为普通函数</p>
</blockquote>
<p><strong>描述事件冒泡的流程</strong></p>
<ul>
<li>基于 DOM 树形结构</li>
<li>事件会顺着触发元素向上冒泡</li>
<li>应用场景:代理（是基于事件冒泡机制才能使用的）</li>
</ul>
<p><strong>无限下拉图片列表，如何监听每个图片的点击</strong></p>
<ul>
<li>事件代理</li>
<li>用e.target获取触发元素</li>
<li>用matches来判断是否是触发元素</li>
</ul>
<h3 id="18、跨域"><a href="#18、跨域" class="headerlink" title="18、跨域"></a>18、跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 同源策略</span><br><span class="line">**ajax请求时，浏览器要求当前网页和server 必须同源（安全)</span><br><span class="line">**同源︰协议、域名、端口，三者必须</span><br><span class="line">前端:http:<span class="comment">//a.com:8080/;   server:https://b.com/api/xxx  三者都不相同</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111548913.png" alt="image-20211211154807380"></p>
<p><strong>加载图片css js可无视同源策略</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、&lt;img src=跨域的图片地址/&gt;</span><br><span class="line"><span class="number">2</span>、&lt;link href=跨域的css地址/&gt;</span><br><span class="line"><span class="number">3</span>、&lt;script src=跨域的js地址&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">4、&lt;img/</span>&gt;可用于统计打点，可使用第三方统计服务</span><br><span class="line"><span class="number">5</span>、&lt;link /&gt; <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>可使用CDN ，CDN一般都是外域</span></span><br><span class="line">6、&lt;script&gt;可实现JSONP</span><br></pre></td></tr></table></figure>
<p><strong>跨域</strong></p>
<ul>
<li>所有的跨域，都必须经过server端允许和配合</li>
<li>未经server端允许就实现跨域，说明浏览器有漏洞，危险信号</li>
</ul>
<p><strong>JSONP</strong><br>访问<a href="https://imooc.com/，服务端定返回一个html文件吗?" target="_blank" rel="noopener">https://imooc.com/，服务端定返回一个html文件吗?</a></p>
<blockquote>
<p>不一定，服务器可以任意动态拼接数据返回，只要符合html格式要求</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、&lt;script&gt;可绕过跨域限制</span><br><span class="line"><span class="number">2</span>、服务器可以任意动态拼接数据返回</span><br><span class="line"><span class="number">3</span>、所以，&lt;script&gt;就可以获得跨域的数据，只要服务端愿意返回</span><br><span class="line">（跨域必须经过服务端的允许和配合，服务端如果愿意给你返回一个拼接好的数据的script的JSONP文件的话，这样就可以通过&lt;script&gt;可绕过跨域限制，从而获得跨域的数据）</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111617957.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">	xhr.open ( <span class="string">'GET'</span>, <span class="string">'/data/test.json'</span> , <span class="literal">true</span>)</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        	<span class="keyword">if</span> (xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">    			resolve( </span><br><span class="line">    				<span class="built_in">JSON</span>. parse(xhr.responseText)</span><br><span class="line">    				)</span><br><span class="line">    			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (xhr.status===<span class="number">404</span>)&#123;</span><br><span class="line">    				reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">' 404 not found '</span>))</span><br><span class="line">        	&#125;</span><br><span class="line">   		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'/data/test.json'</span></span><br><span class="line">ajax(url)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span><span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span><span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure>
<p><strong>ajax知识点</strong></p>
<ul>
<li>XMLHttpRequest</li>
<li>状态码:readyState status</li>
<li>跨域︰同源策略（如何绕过)，JSON，CORS</li>
</ul>
<h3 id="19、存储"><a href="#19、存储" class="headerlink" title="19、存储"></a>19、存储</h3><p>1、描述cookie localStorage sessionStorage区别</p>
<blockquote>
<p>容量 cookie 4kb  另外一个5M<br>API 易用性<br>是否跟随http请求发送出去  </p>
</blockquote>
<p><strong>cookie</strong></p>
<ul>
<li><p>本身用于浏览器和server通讯（本身是http请求的一部分）</p>
</li>
<li><p>被“借用”到本地存储来（ localStorage sessionStorage这是html5之后才提出来的，所以之前都是拿cookie做本地存储）</p>
</li>
<li><p>可用document.cookie= ‘..’来修改（前端修改cookie的方式）=&gt;赋值同名覆盖 不同名叠加</p>
</li>
<li><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111636930.png" alt="image-20211211163645518"></p>
<p><strong>注意</strong>：cookie的设计并不是用来本地存储，它是为了浏览器和客服端通讯，只是被借用到本地存储来</p>
</li>
</ul>
<p><strong>cookie的缺点</strong></p>
<ul>
<li>存储大小，最大4KB（限制）</li>
<li>http请求时需要发送到服务端，增加请求数据量</li>
<li>只能用document.cookie = ‘.…’来修改,太过简陋</li>
</ul>
<p><strong>localStorage和sessionStorage</strong></p>
<ul>
<li>HTML5专门为存储而设计,最大可存5M(已经很大了)</li>
<li>API简单易用 =&gt;setItem getItem</li>
<li>不会随着http请求被发送出去</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111639672.png" alt="image-20211211163925702"></p>
<p><strong>localStorage和 sessionStorage</strong></p>
<ul>
<li>localStorage数据会永久存储，除非代码或手动删除</li>
<li>sessionStorage 数据只存在于当前会话，浏览器关闭则清空</li>
<li>一般用localStorage会更多一些</li>
</ul>
<h3 id="20、防抖"><a href="#20、防抖" class="headerlink" title="20、防抖"></a>20、防抖</h3><p><strong>防抖 debounce</strong></p>
<ul>
<li>监听一个输入框的，文字变化后触发chaange事件</li>
<li>直接用keyup 事件，则会频发触发change事件</li>
<li>防抖∶用户输入结束或暂停时，才会触发change事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">500</span>）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	let timer = null</span></span></span><br><span class="line"><span class="function"><span class="params">                   </span></span></span><br><span class="line"><span class="function"><span class="params">	return function(</span>)</span>&#123;.</span><br><span class="line">		<span class="keyword">if</span> (timer) &#123;</span><br><span class="line">			clearTimeout(timer)</span><br><span class="line">			&#125;</span><br><span class="line">		timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">			fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">		&#125;, delay)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">input1.addEventListener(<span class="string">'keyup'</span>,debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log (input1.value)</span><br><span class="line">&#125;),<span class="number">600</span>)</span><br></pre></td></tr></table></figure>
<p>对照下面这个</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111722163.png" alt="image-20211211172257947"></p>
<p><strong>节流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">节流throttle</span><br><span class="line"><span class="number">1</span>、拖拽一个元素时，要随时拿到该元素被拖拽的位置</span><br><span class="line"><span class="number">2</span>、直接用drag事件，则会频发触发，很容易导致卡顿</span><br><span class="line"><span class="number">3</span>、节流:无论拖拽速度多快，都会每隔<span class="number">100</span>ms触发一次</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">100</span>）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	let timer = null</span></span></span><br><span class="line"><span class="function"><span class="params">                   </span></span></span><br><span class="line"><span class="function"><span class="params">	return function(</span>)</span>&#123;.</span><br><span class="line">		<span class="keyword">if</span> (timer) &#123;</span><br><span class="line">			<span class="keyword">return</span> </span><br><span class="line">			&#125;</span><br><span class="line">		timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">			fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">		&#125;, delay)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">input1.addEventListener(<span class="string">'drag'</span>,throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="comment">//这里的e是传给throttle返回的函数 而function包裹的函数没有e</span></span><br><span class="line">   <span class="comment">// 由于有fn.apply(this, arguments) 有这个fn是function这个函数 其中arguments有event</span></span><br><span class="line">		<span class="built_in">console</span>.log (e.offsetX,e.offsetY)</span><br><span class="line">&#125;),<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112111735199.png" alt="image-20211211173501159"></p>
<p><strong>关于简历</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简洁明了，突出个人技能和项目经验（技术栈）</span><br><span class="line">可以把个人博客，开源作品放在简历里</span><br><span class="line">不要造假，保证能力上的真实性（斟酌用词，不要使用精通， 了解熟练即可）</span><br><span class="line"></span><br><span class="line">谈谈自己的缺点</span><br></pre></td></tr></table></figure>
<h2 id="React框架"><a href="#React框架" class="headerlink" title="React框架"></a>React框架</h2><h3 id="1、事件"><a href="#1、事件" class="headerlink" title="1、事件"></a>1、事件</h3><ol>
<li><p>bind this：修改方法的this指向。使用箭头函数this就指向当前实例，就不用bind（this）</p>
</li>
<li><p>关于event 参数</p>
<ul>
<li><p>event. preventDefault()//阻止默认行为</p>
</li>
<li><p>event. stopPropagation() //阻止冒泡</p>
</li>
<li><p>event.target 指向当前元素，即当前元素触发</p>
</li>
<li><p>event.nativeEvent.target 指向当前元素 即当前元素触发</p>
</li>
<li><p>event.nativeEvent.currentTarget 绑定是绑定在document上<strong>**</strong></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>event是SyntheticEvent事件，模拟出来DOM事件所有能力</p>
</li>
<li><p>event.nativeEvent是原生事件对象</p>
</li>
<li><p>所有的事件，都被挂载到document上<strong>**</strong></p>
</li>
<li><p>和DOM事件不一样，和Vue事件也不一样</p>
</li>
</ul>
<ol>
<li>传递自定义参数</li>
</ol>
<h3 id="2、setState"><a href="#2、setState" class="headerlink" title="2、setState"></a>2、setState</h3><ol>
<li><p>不可变值（不能直接修改state）</p>
<ul>
<li>concat，slice，filter 这些东西不会改变原来的list值。而push pop splice会改变不可用 </li>
<li>或者可以通过this.state.list.slice() <strong>不传入值就相当于给list做了一个副本，这样就可以使用push，pop这种API，原本的list不变</strong></li>
<li>扩展对象可以用解构赋值 {…this.state.list,a:100}</li>
</ul>
</li>
<li><p>可能是异步更新</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122053575.png" alt="image-20211212205326882"></p>
<blockquote>
<p>先打印再累加   想要获取最新的值就在setState传入第二个参数，第二个参数的值是一个函数</p>
</blockquote>
<p><strong>但是在setTimeout中setState是同步的  自己定义的DOM事件，setState是同步的</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122059184.png" alt="image-20211212205931478"></p>
<p>标准写法应该这样</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122119780.png" alt="image-20211212211952584"></p>
<blockquote>
<p>要销毁这个自定义的DOM事件</p>
</blockquote>
</li>
<li><p>可能会被合并（仅限对象才会被合并，函数不会被合并）</p>
</li>
</ol>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122152658.png" alt="image-20211212215230884"></p>
<h3 id="3、组件生命周期"><a href="#3、组件生命周期" class="headerlink" title="3、组件生命周期"></a>3、组件生命周期</h3><p> <img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122159266.png" alt="image-20211212215915750"></p>
<h3 id="4、高级特性"><a href="#4、高级特性" class="headerlink" title="4、高级特性"></a>4、高级特性</h3><ol>
<li><p>函数组件</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122208615.png" alt="image-20211212220821520"></p>
</li>
<li><p>非受控组件</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122215332.png" alt="image-20211212221502666"></p>
<blockquote>
<p> 建议写受控组件  因为受控没有ref  因为官网尽量不要写ref</p>
</blockquote>
</li>
<li><p>Portals</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122216014.png" alt="image-20211212221609897"></p>
<blockquote>
<p><strong>Portals使用场景</strong><br>overflow: hidden  父元素设置了BFC影响了子元素的展示，可以让子元素逃离父元素之外展示<br>父组件z-index值太小：同理<br>fixed需要放在body第一层级：同理</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122225929.png" alt="image-20211212222543204"></p>
</li>
<li><p>context</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112122226510.png" alt="image-20211212222646168"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 创建Context容器对象：</span><br><span class="line">	<span class="keyword">const</span> XxxContext = React.createContext()  </span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：</span><br><span class="line">	&lt;xxxContext.Provider value=&#123;数据&#125;&gt;</span><br><span class="line">		子组件</span><br><span class="line">    &lt;<span class="regexp">/xxxContext.Provider&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">		&lt;Provider value=&#123;&#123;username,age&#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">					&lt;B/</span>&gt;</span><br><span class="line">				&lt;<span class="regexp">/Provider&gt;  这样包裹一下 B组件以及B的子组件都能用只不过需要声明接收</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">3) 后代组件读取数据：</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/第一种方式:仅适用于类组件 </span></span><br><span class="line"><span class="regexp">	  static contextType = xxxContext  /</span><span class="regexp">/ 声明接收context</span></span><br><span class="line"><span class="regexp">	  this.context /</span><span class="regexp">/ 读取context中的value数据</span></span><br><span class="line"><span class="regexp">	  </span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/第二种方式: 函数组件与类组件都可以  函数式没有this所以第一种不适合函数式组件</span></span><br><span class="line"><span class="regexp">	  &lt;xxxContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">	    &#123;</span></span><br><span class="line"><span class="regexp">	      value =&gt; ( /</span><span class="regexp">/ value就是context中的value数据</span></span><br><span class="line"><span class="regexp">	        要显示的内容</span></span><br><span class="line"><span class="regexp">	      )</span></span><br><span class="line"><span class="regexp">	    &#125;</span></span><br><span class="line"><span class="regexp">	  &lt;/</span>xxxContext.Consumer&gt;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">在应用开发中一般不用context, 一般都它封装react插件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异步组件</p>
<p>性能优化：异步组件—&gt;组件比较大，路由需要懒加载</p>
<p> <strong>lazyLoad  懒加载 路由组件最常用  就是避免100个组件去请求100次  最好的就是点哪个就请求哪个</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span></span><br><span class="line"><span class="keyword">const</span> Login = lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'@/pages/Login'</span>))  <span class="comment">//现点现加载 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span></span><br><span class="line">&lt;Suspense fallback=&#123;&lt;h1&gt;loading.....&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Route path="/</span>xxx<span class="string">" component=&#123;Xxxx&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Redirect to="</span>/login<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">    &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">&lt;/Suspense&gt;  //这就是如果网络慢慢 迟迟不回来 要fallback指定一个组件component=&#123;Xxxx&#125;显示</span></span><br><span class="line"><span class="string">//Network选项卡 点谁加载谁  把网络故意调慢  点了About加载 会显示Loading</span></span><br><span class="line"><span class="string">//&lt;h1&gt;loading.....&lt;/h1&gt;如果Loading要写成一个组件就另外写一个文件就可以 但是引入的时候不要懒加载</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>性能组件（永远是面试的重点）</p>
<p>性能优化对于React更加重要</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131211882.png" alt="image-20211213121121649"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131212189.png" alt="image-20211213121203921"></p>
<blockquote>
<p>判断下一个状态的数据和前一个数据是否相同，不相同可以渲染，相同就不可以渲染。优化性能</p>
<p>背后的逻辑是什么？ SCU默认会返回true，但是有返回false的权利</p>
<p>SCU一定要每次都用嘛？不一定，性能优化需要的时候用。需要的时候才优化</p>
</blockquote>
<p><strong>SCU使用总结**</strong></p>
<ul>
<li><p>SCU 默认返回true ，即React默认重新渲染所有子组件</p>
</li>
<li><p>必须配合“不可变值”一起使用</p>
</li>
<li><p>可先不用SCU，有性能问题时再考虑使用</p>
<p><strong>PureComponent 和memo</strong></p>
</li>
<li><p>PureComponent , SCU默认实现了浅比较</p>
</li>
<li><p>memo ，函数组件中的PureComponent</p>
</li>
<li><p>浅比较已使用大部分情况（尽量不要做深度比较)</p>
</li>
</ul>
<p><strong>immutable.js</strong></p>
<ul>
<li>彻底拥抱“不可变质”</li>
<li>基于共享数据（不是深拷贝），速度好</li>
<li>有一定学习和迁移成本，按需使用</li>
</ul>
</li>
<li><p>高阶组件HOC</p>
<p><strong>关于组件公共逻辑的抽离</strong></p>
<ul>
<li>mixin , 已被React 弃用</li>
<li>高阶组件HOC</li>
<li>Render Props</li>
<li>connect也是高阶组件</li>
</ul>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131431082.png" alt="image-20211213143101772"></p>
<blockquote>
<p>接收一个组件，返回的是一个由函数拼接而成的组件</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131440059.png" alt="image-20211213144047471"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131441622.png" alt="image-20211213144120493"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131442900.png" alt="image-20211213144230500"></p>
</li>
<li><p>Render Props（比HOC更容易理解）</p>
</li>
</ol>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131451135.png" alt="image-20211213145106982"></p>
<p><strong>注意</strong>：暴露的是什么，组件就传什么，比如下图，暴露的是APP 在入口文件APP相当于子组件所以直接在APP输入props即可</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131453594.png" alt="image-20211213145353719"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131454305.png" alt="image-20211213145442204"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131456086.png" alt="image-20211213145533126"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131458034.png" alt="image-20211213145754832"></p>
<h3 id="5、Redux"><a href="#5、Redux" class="headerlink" title="5、Redux"></a>5、Redux</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131508199.png" alt="image-20211213150838083"></p>
<blockquote>
<p>redux怎么去获取异步action</p>
<p>单向数据流的图</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112131523848.png" alt="image-20211213152256044"></p>
<h3 id="6、React原理"><a href="#6、React原理" class="headerlink" title="6、React原理"></a>6、React原理</h3><p><strong>函数式编程</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">纯函数，不可变值</span><br></pre></td></tr></table></figure>
<p><strong>vdom和diff</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff比较同级，不跨级比较</span><br></pre></td></tr></table></figure>
<p><strong>jsx本质</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、是一个 React.createElement 函数，他接收多个参数，执行返回vnode，vnode通过vdom的patch或者其他方法渲染页面</span><br><span class="line"><span class="comment">//调用 React 的 createElement API </span></span><br><span class="line"><span class="number">2</span>、不是模板引擎，而是语法糖</span><br><span class="line"><span class="number">3</span>、第一个参数，可能是组件（大写），也可能是html 标签名（小写）</span><br><span class="line"><span class="number">4</span>、第二个参数是属性信息，如果没有属性则为 <span class="literal">null</span>；</span><br><span class="line">第三个参数是子元素；</span><br><span class="line">    如果拥有多个子元素，可以依次放在第三个、第四个...</span><br><span class="line">    也可以用在数组中存放多个子元素	</span><br><span class="line"><span class="number">4</span>、组件名，首字母必须大写( React规定)</span><br></pre></td></tr></table></figure>
<p><strong>合成事件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、所有事件挂载到<span class="built_in">document</span> 上</span><br><span class="line"><span class="number">2</span>、event 不是原生的，是 SyntheticEvent合成事件对象</span><br><span class="line"><span class="number">3</span>、和Vue 事件不同，和DOM事件也不同</span><br><span class="line">为何要合成事件机制?</span><br><span class="line"><span class="number">1</span>、更好的兼容性和跨平台</span><br><span class="line"><span class="number">2</span>、载到<span class="built_in">document</span> ，减少内存消耗，避免频繁解绑</span><br><span class="line"><span class="number">3</span>、方便事件的统一管理（如事务机制)</span><br></pre></td></tr></table></figure>
<p><strong>setState 和 batchUpdata</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、setState无所谓异步还是同步</span><br><span class="line"><span class="number">2</span>、看是否能命中batchUpdate机制</span><br><span class="line"><span class="number">3</span>、判断isBatchingUpdates</span><br><span class="line"></span><br><span class="line">哪些能命中batchUpdate机制</span><br><span class="line"><span class="number">1</span>、生命周期（和它调用的函数)</span><br><span class="line"><span class="number">2</span>、React 中注册的事件（和它调用的函数)</span><br><span class="line"><span class="number">3</span>、React可以“管理”的入口</span><br><span class="line"></span><br><span class="line">哪些不能命中batchUpdate机制</span><br><span class="line"><span class="number">1</span>、setTimeout setInterval 等（和它调用的函数)</span><br><span class="line"><span class="number">2</span>、自定义的DOM事件（和它调用的函数)</span><br><span class="line"><span class="number">3</span>、React“管不到”的入口</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112141231918.png" alt="image-20211214123112436"></p>
<blockquote>
<p>Y就是异步的State N 就是同步的State</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112141233547.png" alt="image-20211214123342209"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112141234154.png" alt="image-20211214122922788"></p>
<blockquote>
<p>执行函数前处于batchUpdate 且isBatchingUpdates=ture。执行函数完之后isBatchingUpdates=false。</p>
<p>因为settimeout（）这个函数式异步的就直接执行isBatchingUpdates=false。了 之后进行this.set的时候isBatchingUpdates已经是false了。所以判断setState是异步还是同步的时候，就看isBatchUpdates是true还是false 且设置这个是在入口中设置的。</p>
</blockquote>
<p><strong>组件之间如何通讯</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、父子组件props</span><br><span class="line"><span class="number">2</span>、自定义事件</span><br><span class="line"><span class="number">3</span>、Redux和Context</span><br></pre></td></tr></table></figure>
<p><strong>Context是什么，如何应用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父组件，向其下所有子孙组件传递信息</span><br><span class="line">如一些简单的公共信息，主题色，语言等。</span><br><span class="line">复杂的公共信息，用redux</span><br></pre></td></tr></table></figure>
<p><strong>shouldComponentUpdate用途</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">性能优化</span><br><span class="line">配合不可变值一起使用，否则会出错</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112141634311.png" alt="image-20211214163434174"></p>
<blockquote>
<p>两次异步操作合并成一次所以只加1，异步操作玩之后执行同步</p>
</blockquote>
<p><strong>纯函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回一个新值，没有副作用（不会偷偷修改其他值）</span><br><span class="line">重点：不可变值</span><br><span class="line">如arr1=arr.slice()</span><br></pre></td></tr></table></figure>
<p><strong>函数组件和class组件的区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">纯函数，输入props，输出JSX</span><br><span class="line">没有实例，没有生命周期，没有state</span><br><span class="line">不能扩展其他方法</span><br></pre></td></tr></table></figure>
<p><strong>什么是受控组件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表单的值，收state 控制</span><br><span class="line">需要自行监听onChange ，更新state</span><br></pre></td></tr></table></figure>
<p><strong>何时使用异步组件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载大组件</span><br><span class="line">路由懒加载</span><br></pre></td></tr></table></figure>
<p><strong>多个组件有公共逻辑，如何抽离</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高阶组件</span><br><span class="line">Render Props</span><br></pre></td></tr></table></figure>
<p><strong>Redux如何进行异步请求</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用异步action</span><br><span class="line">如redux-thunk</span><br></pre></td></tr></table></figure>
<p><strong>PureComponent 有何区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现了浅比较的shouldComponentUpdate</span><br><span class="line">优化性能</span><br><span class="line">但要结合不可变值使用</span><br></pre></td></tr></table></figure>
<p><strong>React性能优化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">渲染列表时加key</span><br><span class="line">自定义事件、DOM事件及时销毁</span><br><span class="line">合理使用异步组件</span><br><span class="line">减少函数bind <span class="keyword">this</span>的次数</span><br><span class="line">合理使用SCU PureComponent和memo</span><br><span class="line">合理使用Immutable.js</span><br><span class="line">webpack层面的优化(后面会讲)</span><br><span class="line">前端通用的性能优化，如图片懒加载</span><br><span class="line">使用SSR</span><br></pre></td></tr></table></figure>
<p><strong>React和Vue的区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">都支持组件化</span><br><span class="line">都是数据驱动视图</span><br><span class="line">都使用vdom 操作 DOM</span><br><span class="line"></span><br><span class="line">React使用JSX拥抱JS，Vue使用模板拥抱html</span><br><span class="line">React函数式编程，Vue声明式编程</span><br><span class="line">React 更多需要自力更生，Vue把想要的都给你</span><br></pre></td></tr></table></figure>
<h3 id="7、webpack"><a href="#7、webpack" class="headerlink" title="7、webpack"></a>7、webpack</h3><p><strong>webpack介绍</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webpack已经是前端打包构建的不二选择</span><br><span class="line">每日必用，面试必考</span><br><span class="line">成熟的工具，重点在于配置和使用，原理并不高优</span><br><span class="line"></span><br><span class="line">前端代码为何要进行构建和打包</span><br><span class="line"><span class="built_in">module</span> chunk bundle 分别什么意思，有何区别?</span><br><span class="line">loader和plugin的区别?</span><br><span class="line">webpack如何实现懒加载?</span><br><span class="line">webpack常见性能优化</span><br><span class="line">babel-runtime和 babel-polyfill的区别</span><br></pre></td></tr></table></figure>
<p><strong>webpack基本配置</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vue-cli create-react-app  **cli工程师</span><br><span class="line">常用上述脚手架，而不会自己配置webpaclk ?</span><br><span class="line">则面试不会通过</span><br><span class="line"></span><br><span class="line">拆分配置和merge （公共的配置common 生产环境下的配置，开发环境下的配置）</span><br><span class="line"></span><br><span class="line">跨域问题：开发环境下还会定义一个devserver 里可以通过设置代理proxy将本地/api/XXX代理到 localhost：<span class="number">3000</span>/api/xxx</span><br><span class="line"></span><br><span class="line">loader的执行顺序是从后往前</span><br><span class="line">postcss-loader 浏览器的兼容性的</span><br><span class="line">对css文件：先postcss-loader 浏览器的兼容性的一些东西做了再变成css插入到style中</span><br><span class="line">对less文件，先通过less解析语法成css然后插入style中</span><br><span class="line">图片大小小于<span class="number">5</span>kb用base64格式产出否则用file-loader的形式，产出url格式</span><br></pre></td></tr></table></figure>
<p><strong>webpack高级配置</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本配置只能做demo，不能做线上项目</span><br><span class="line">多入口：entry要写两个。</span><br><span class="line">output要通过[name]的变量去操作 </span><br><span class="line">plugins要：每一个入口都要创建一个新的HtmlWebpackPlugin的实例（<span class="keyword">new</span>）</span><br><span class="line">	chunks：会帮你只引入什么名字的js文件 不写chunk会把html文件一块引入。</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112141932424.png" alt="image-20211214193227860"></p>
<p><strong>抽离css文件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开发环境下用的是通过css-loader转换成出css文件插入到style-loader里面去的</span><br><span class="line">生成环境下需要用MiniCssExtractPlugin.loader,通过这种方式就不再是塞到style-loader里面去了</span><br><span class="line">单独拧出来，（在plugins里面加了一个抽离css文件的plugins的配置）还是用<span class="keyword">new</span> MiniCssExtractPlugin标志一下抽离出的css文件是什么。抽离完还要压缩（optimization配置里面）抽离出来就可以在index.html引入抽离的css文件了</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112141950571.png" alt="image-20211214195006905"></p>
<p><strong>抽离公共代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">抽离公共部分相互引用，减少加载和执行的次数</span><br><span class="line">开发环境下没必要做。</span><br><span class="line"></span><br><span class="line">第三方模块复用一次的原因是是避免细微的改动重新加载这个模块，影响加载速度，耗费性能。</span><br><span class="line">test 是模块来自 </span><br><span class="line">大小限制最好写<span class="number">3</span>kb <span class="number">5</span>kB这样 name就是代码分割产出的chunk</span><br><span class="line">多入口plugins里面引用<span class="keyword">new</span> HtmlWebpackPlugin下也要考虑代码分割的chunk</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142004025.png" alt="image-20211214200446809"></p>
<p><strong>懒加载</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引入动态数据-&gt;懒加载</span><br><span class="line">异步代码也会产出一个chunk 文件名不是自己规定的</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142051458.png" alt="image-20211214205110387"></p>
<p><strong>moudle chunk bundle的区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> -各个源码文件，webpack 中一切皆模块 只要是引入的就是模块</span><br><span class="line">chunk -多模块合并成的，如entry（一个入口就可以生成一个至多个chunk，因为入口定义的文件也包括其他文件一块引进来） </span><br><span class="line">        <span class="keyword">import</span>() splitChunk 拆分代码也可以定义chunk 懒加载引入动态数据也是一个chunk</span><br><span class="line">        可以理解成内存中的一个概念，还没整理的输出</span><br><span class="line">bundle -最终的输出文件（一个chunk对应一个bundle）bundle可能是很多个文件不止一个文件</span><br></pre></td></tr></table></figure>
<p><strong>webpack性能优化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、优化打包构建速度-开发体验和效率</span><br><span class="line">    优化 babel-loader - 缓存 加一个cacheDirectory参数，加上之后只要ES6代码没有改，就不会重新编译，缓存一下。</span><br><span class="line">    				 - 有include和exclude两者选一个去明确打包范围</span><br><span class="line">	</span><br><span class="line">	happyPack -多进程打包工具 -JS单线程，开启多进程打包</span><br><span class="line">        					-提高构建速度（特别是多核CPU )</span><br><span class="line">							-把对.js文件的处理转交给id为babel的HappyPack实例 图<span class="number">3</span></span><br><span class="line">	</span><br><span class="line">	IgnorePlugin -避免引入无用模块 -例如moment.js这个日期处理的库 加载时间的库，<span class="number">200</span>多kb 就是因为把语言的库引进来了，可以通					 -过引入这个插件来避免引入这个模块，至于语言的模块就自己手动引入  -还能优化产出的体积  图<span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	ParallelUglifyPlugin -开启多进程进行代码压缩JS JS单线程，开启多进程压缩更快和HappyPack原理类似 图四压缩就是直接输结果</span><br><span class="line">						</span><br><span class="line">	noParse  -避免重复打包  像一些min.js文件基本都是采用模块化处理过了，不用再重新打包 在moudule文件下加一下就好了如下图<span class="number">2</span></span><br><span class="line">	</span><br><span class="line">    自动刷新 -一保存代码编译完之后浏览器自动刷新 开发环境用（devServer）默认开启会用</span><br><span class="line">    </span><br><span class="line">	热更新 -自动刷新的升级版，改完代码之后浏览器不要刷新，代码就生效，体验更好</span><br><span class="line">                        自动刷新:整个网页全部刷新，速度较慢</span><br><span class="line">                        自动刷新:整个网页全部刷新，状态会丢失 包括你点击的路由 自动刷新玩就会回到首页和你输入的状态下次就不见</span><br><span class="line">						热更新：新代码生效，网页不刷新，状态不丢失</span><br><span class="line">                        引入插件，<span class="keyword">new</span>实例，devServer设置hot为<span class="literal">true</span></span><br><span class="line">                        如果是改js文件的话就会导致自动刷新，原因是因为某些模块没有开启热更新的监听 图<span class="number">4</span></span><br><span class="line">                        自动刷新会影响你开发的体验再去开启热更新</span><br><span class="line">	</span><br><span class="line">	DllPlugin-针对大的库和大的第三方插件没必要每一次都把所有打包一遍，我们可以实现把第三方库打包好之后引用 *动态链接库插件</span><br><span class="line">			 - 前端框架如vue React，体积大，构建慢</span><br><span class="line">			 - 较稳定，不常升级版本</span><br><span class="line">			 - 同一个版本只构建一次即可，不用每次都重新构建</span><br><span class="line">            webpack 已内置 DllPlugin支持</span><br><span class="line">            DllPlugin插件 -先把react进行预打包出dll文件（webpack.dull.js） 图<span class="number">5</span> 产出两个文件 一个是加载了打包所有关于入口						  - react-react-dom的所有文件，另一个是索引</span><br><span class="line">            DlIReferencePlugin插件 -使用dll文件。使用就不要重新打包 </span><br><span class="line">			使用首先现在入口文件的index.html引入这个src = ‘./react.dull.js’这个文件 然后<span class="keyword">new</span>实例 图<span class="number">6</span></span><br><span class="line">			</span><br><span class="line">	webpack优化构建速度(可用于生产环境)					不可用生产环境</span><br><span class="line">        优化 babel-loader									 自动刷新</span><br><span class="line">        happyPack										  热更新</span><br><span class="line">        IgnorePlugin									  DllPlugin</span><br><span class="line">        ParallelUglifyPlugin  *必须用</span><br><span class="line">        noParse</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	**总结**</span><br><span class="line">    IgnorePlugin直接不引入，代码中没有</span><br><span class="line">    noParse 引入，但不打包</span><br><span class="line">	项目较大，打包较慢，开启多进程能提高速度</span><br><span class="line">	项目较小，打包很快，开启多进程会降低速度(进程开销)</span><br><span class="line">	按需使用</span><br><span class="line"></span><br><span class="line">     **ES6 Module和Commonjs区别**</span><br><span class="line">    ES6 Module静态引入，编译时引入  必须放在最上面 否则报错  图<span class="number">7</span></span><br><span class="line"> 	Commonjs动态引入，执行时引入，有可能需要有可能不需要 （图<span class="number">7</span> 里面的<span class="keyword">if</span>就不知道是否会被执行）</span><br><span class="line">	只有ES6 Module 才能静态分析，实现Tree-Shaking（webpack打包的时候执行，打包的时候代码还没执行）</span><br><span class="line">	webpack只是一个静态分析，静态构建，编译，代码还没正式在线上被用户去运行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、优化产出代码-产品性能  **更重要</span><br><span class="line">	体积更小</span><br><span class="line">    合理分包，不重复加载</span><br><span class="line">    速度更快，内存使用更少</span><br><span class="line">    ****每一个都是优化</span><br><span class="line">    小图片base64编码</span><br><span class="line">    bundle加hash（打包出的bunlde代码时加上hash）</span><br><span class="line">    懒加载</span><br><span class="line">    提前公共代码-&gt;做一个公共的包，不需要重复打包公共的模块</span><br><span class="line">    IgnorePlugin 还能优化产出的体积</span><br><span class="line">    使用CDN加速: 打包出的html 引入的文件前缀都加了cdn 图<span class="number">7</span> 这仅仅是第一步还需要将打包的文件上传到cdn的网址</span><br><span class="line">    使用mode:production:去打包生成环境下的代码 自动开启代码压缩  Vue React 等会自动删掉调试代码（如开发环境的warning )</span><br><span class="line">    					自动开启Tree-<span class="function"><span class="params">shaking</span>=&gt;</span>对未使用的代码删除 只要mode为production即可 </span><br><span class="line">                        ES6 Module才能让tree-shaking生效commonjs就不行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Scope Hosting 将两个文件合并，多个函数放在一个函数里，使得作用域少 使得内存占用少一些，代码体积更小 图<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142134368.png" alt="image-20211214213424143"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142137514.png" alt="image-20211214213751310"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142144545.png" alt="image-20211214214448414"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142148311.png" alt="image-20211214214856230"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142159701.png" alt="image-20211214215938574"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142210863.png" alt="image-20211214221035644"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142215187.png" alt="image-20211214221515068"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142224647.png" alt="image-20211214222435551"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142237194.png" alt="image-20211214223716971"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112142240415.png" alt="image-20211214224034222"></p>
<p><strong>babel</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">前端开发环境必备工具 同webpack，需要了解基本的配置和使用</span><br><span class="line">环境搭建&amp;基本配置</span><br><span class="line">	babel-demo npx babel src/index.js 这样就可以通过babel编译index,js文件</span><br><span class="line">    babel其实就是通过plugin将ES6语法转换为ES5</span><br><span class="line"></span><br><span class="line">babel-polyfill（po里），core-js标准库集成了所有ES6 ES7新语法的polyfill的补丁（兼容性）但是这个库对ES6的generator函数（处理异步），被<span class="keyword">async</span>/<span class="keyword">await</span>代替不支持， 但是regenerator这个库就支持了。 babel-polyfill就是这两个库的集合</span><br><span class="line">                        Babel <span class="number">7.4</span>之后弃用babel</span><br><span class="line">                        推荐直接使用core-js和regenerator				</span><br><span class="line">							问题：会污染全局环境   如果是自己独立开发可以用</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">babel-runtime:不会污染全局环境。产出第三方lib就要用这个，否则会污染全局环境</span><br></pre></td></tr></table></figure>
<h3 id="8、-面试真题演练"><a href="#8、-面试真题演练" class="headerlink" title="8、 面试真题演练"></a>8、 面试真题演练</h3><p><strong>1.前端为何要进行打包和构建</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码层面</span><br><span class="line">    体积更小(Tree-Shaking、压缩、合并），加载更快</span><br><span class="line">    开发而言：编译高级语言或语法（TS，ES6+，模块化，scss )     </span><br><span class="line">    兼容性和错误检查（Polyfill,postcss，eslint）</span><br><span class="line">研发层面（前端工程化）</span><br><span class="line">    统一、高效的开发环境</span><br><span class="line">    统一的构建流程和产出标准</span><br><span class="line">    集成公司构建规范（提测、上线等)</span><br></pre></td></tr></table></figure>
<p><strong>loader和plugin区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loader模块转换器，如less &gt;css</span><br><span class="line">plugin扩展插件，如HtmlWebpackPlugin</span><br><span class="line">常用的loader和plugin有什么？ 之前讲过的能掌握即可</span><br></pre></td></tr></table></figure>
<p><strong>babel和 webpack的区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel - JS新语法编译工具，不关心模块化</span><br><span class="line">webpack-打包构建工具，是多个loader、plugin 的集合</span><br></pre></td></tr></table></figure>
<p><strong>如何产出一个lib</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考webpack.dll.js里面有一个output.library</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112151920950.png" alt="image-20211215192019355"></p>
<p><strong>webpack如何实现懒加载</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>语法</span><br><span class="line">结合Vue React异步组件</span><br><span class="line">结合React-router异步加载路由</span><br></pre></td></tr></table></figure>
<p><strong>为何Proxy不能被Polyfill</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Proxy</span> 的功能用 <span class="built_in">Object</span>.defineProperty 无法模拟</span><br></pre></td></tr></table></figure>
<p><strong>组件和状态设计</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">todoList：</span><br><span class="line"><span class="number">1</span>、用数据描述内容</span><br><span class="line"><span class="number">2</span>、结构化</span><br><span class="line"><span class="number">3</span>、可扩展性</span><br><span class="line"><span class="number">4</span>、功能上拆分层次</span><br><span class="line"><span class="number">5</span>、容器组件（只管理数据）、UI（只显示视图）</span><br></pre></td></tr></table></figure>
<h3 id="9、项目流程"><a href="#9、项目流程" class="headerlink" title="9、项目流程"></a>9、项目流程</h3><p><strong>PM（项目管理）想在项目开发过程中增加需求，该怎么办</strong></p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不能拒绝，走需求变更流程即可</span><br><span class="line">公司如果有规定，按规定走</span><br><span class="line">否则，发起项目组和<span class="built_in">leader</span>的评审，重新评估排期</span><br></pre></td></tr></table></figure>
<p><strong>项目即将延期了，该怎么办</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">项目沟通</span><br><span class="line">多人协作，沟通是最重要的事情</span><br><span class="line">每日一沟通（如站会），有事说事，无事报平安</span><br><span class="line">及时识别风险，及时汇报</span><br></pre></td></tr></table></figure>
<p><strong>你将如何保证项目质量</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">符合开发规范</span></span><br><span class="line"><span class="attr">写出开发文档</span></span><br><span class="line"><span class="attr">及时单元测试</span></span><br><span class="line"><span class="attr">Mock</span> <span class="string">API</span></span><br><span class="line"><span class="attr">Code</span> <span class="string">Review  （让大佬帮你浏览一遍）</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/01/15/%E5%BF%AB%E9%80%9F%E6%90%9E%E5%AE%9A%E5%A4%A7%E5%8E%82%E4%B8%80%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/15/%E5%BF%AB%E9%80%9F%E6%90%9E%E5%AE%9A%E5%A4%A7%E5%8E%82%E4%B8%80%E9%9D%A2/" class="post-title-link" itemprop="url">快速搞定大厂一面</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-15T00:00:00+08:00">2021-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/15/%E5%BF%AB%E9%80%9F%E6%90%9E%E5%AE%9A%E5%A4%A7%E5%8E%82%E4%B8%80%E9%9D%A2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/15/%E5%BF%AB%E9%80%9F%E6%90%9E%E5%AE%9A%E5%A4%A7%E5%8E%82%E4%B8%80%E9%9D%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JavaScript核心原理"><a href="#JavaScript核心原理" class="headerlink" title="JavaScript核心原理"></a>JavaScript核心原理</h2><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162135618.png" alt="image-20211216213550505"></p>
<p><strong>数据类型的判断方法</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162206866.png" alt="image-20211216214052951"></p>
<p><strong>第三种方法最好，Object.prototype.toString  它返回的结果是[object Xxx 就比如object Number]</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'123'</span>==<span class="number">123</span>  <span class="literal">true</span></span><br><span class="line"><span class="string">""</span>==<span class="literal">null</span>   <span class="literal">false</span></span><br><span class="line"><span class="literal">null</span>==<span class="number">0</span>    <span class="literal">false</span></span><br><span class="line"><span class="string">"==0      true</span></span><br><span class="line"><span class="string">[]==0     true</span></span><br><span class="line"><span class="string">[]=="</span>     <span class="literal">true</span></span><br><span class="line">[]==![]   <span class="literal">true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)   <span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>)    <span class="number">0</span></span><br><span class="line">parselnt(<span class="string">''</span>)  <span class="literal">NaN</span></span><br><span class="line">parselnt(</span><br><span class="line">&#123;&#125;+<span class="number">10</span> =<span class="string">'10[object Object]'</span></span><br><span class="line">    </span><br><span class="line"><span class="string">'1'</span>+<span class="literal">undefined</span> = <span class="string">'1undefined'</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162156980.png" alt="image-20211216215624904"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162156884.png" alt="image-20211216215633721"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162159385.png" alt="image-20211216215927226"></p>
<blockquote>
<p>Object.valueOf()方法</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162204796.png" alt="image-20211216220410734"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162204069.png" alt="image-20211216220424019"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162204686.png" alt="image-20211216220432142"></p>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象;但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一种方法通过<span class="built_in">Object</span>.assign方法</span><br><span class="line"><span class="keyword">let</span> target= o;</span><br><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source); <span class="comment">//target为浅拷贝的对象，source是拷贝的来源</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">//&#123;a: &#123; b:1&#125;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target=&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> source =&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="built_in">console</span>.log(target);<span class="comment">//&#123;a:&#123; b: 10&#125;;</span></span><br><span class="line">source.a.b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">//&#123;a:&#123; b: 10&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">//&#123;a: &#123; b: 10&#125;;</span></span><br><span class="line"></span><br><span class="line">第二种方法通过扩展运算符方式</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162222351.png" alt="image-20211216222245203"></p>
<blockquote>
<p>因为a是基本数据类型，只拷贝了值1，但是b是一个对象，拷贝了c：1的地址</p>
<p>因此会有上述结果  也证明了是浅拷贝</p>
<p>如果是深拷贝即便是对象也都不会变 c还是1</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第三种方法:concat方法也是浅拷贝 （只能用于数据的浅拷贝）使用场景比较局限</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162225589.png" alt="image-20211216222513533"></p>
<blockquote>
<p>slice拷贝数组</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162226804.png" alt="image-20211216222657736"></p>
<blockquote>
<p>深拷贝：将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p>
</blockquote>
<p><strong>方法一：JSON.stringfy</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162234878.png" alt="image-20211216223420804"></p>
<blockquote>
<p>用这个方法进行深拷贝的弊端：</p>
<ol>
<li>拷贝的对象的值中如果有函数、undefined、symbol这几种类型，经过JSON.stringify序列化之后的字符串中这个键值对会消失<br>2．拷贝 Date引用类型会变成字符串<br>3．无法拷贝不可枚举的属性<br>4．无法拷贝对象的原型链<br>5．拷贝 RegExp 引用类型会变成空对象<br>6．对象中含有NaN、Infinity 以及-Infinity，JSON序列化的结果会变成null</li>
</ol>
<p>7．无法拷贝对象的循环应用，即对象成环(obj[key]= obj)</p>
</blockquote>
<p><strong>继承方式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JS的继承到底有多少种实现方式呢?</span><br><span class="line">    原型链继承 </span><br><span class="line">		两个实例使用同一个原型对象的话 内存空间是共享的，当一个发生改变的时候，另外一个也随之进行了变化  图<span class="number">1</span></span><br><span class="line">	构造函数继承（借助call）</span><br><span class="line">	它使父类引用的属性不会被共享，优化了第一种继承方式的弊端）但是缺点是只能继承父类的实例属性和方法，不能继承原型属性或者方法</span><br><span class="line">	组合继承（前两种的组合）</span><br><span class="line">	原型式继承 <span class="built_in">Object</span>.create()</span><br><span class="line">    寄生式继承</span><br><span class="line">    寄生组合继承</span><br><span class="line">ES6的extends关键字是用哪种继承方式实现的呢?</span><br><span class="line">    寄生组合继承</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112162243159.png" alt="image-20211216224316214"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171105372.png" alt="image-20211217110552271"></p>
<blockquote>
<p>new关键词的主要作用就是执行一个构造函数、返回一个实例对象，根据构造函数的情况，来确定是否可以接受参数的传递</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171107447.png" alt="image-20211217110749763"></p>
<p><strong>new关键字执行之后总是会返回一个对象，要么是实例对象，要么是return语句指定的对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Jack'</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">18</span>&#125; <span class="comment">//返回与this无关的对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">var</span> p= <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="built_in">console</span>.log(p)<span class="comment">//&#123;age: 18&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(p.name)<span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(p.age)<span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Jack'</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">'tom'</span>; <span class="comment">//不是一个对象</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">var</span> p= <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="built_in">console</span>.log(p)<span class="comment">//&#123;name: 'Jack'&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(p.name)<span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<p><strong>apply call bind都可以改变函数func this的指向，call和apply传参的写法不同，apply的第二个参数为数组，call第2个至第n个都是func的传参，bind和这两个都不同，bind改变this的指向但是不是立马执行，call和apply是立马执行</strong></p>
<blockquote>
<p>A对象有个getName的方法,B对象也需要临时使用同样的方法那么这时候可以借用A对象的getName方法</p>
</blockquote>
<p>![</p>
<p>](<a href="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171245503.png" target="_blank" rel="noopener">https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171245503.png</a>)</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171247928.png" alt="image-20211217124702882"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171248927.png" alt="image-20211217124803739"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171248175.png" alt="image-20211217124853074"></p>
<blockquote>
<p>这两个方法是直接返回执行结果，而bind方法是返回一个函数，因此上面直接用eval执行得到结果</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171250331.png" alt="image-20211217125007222"></p>
<blockquote>
<p>实现bind的核心在于返回的时候需要返回一个函数，因此这里的fbound需要返回，但是在返回的过程中，原型链对象上的属性不能丢失，所以这里需要使用Object.create方法将this.prototype上的属性挂到fbound的原型上面，最后再返回fbound</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112171251996.png" alt="image-20211217125102925"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/01/05/JavaScript%E5%BC%BA%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/05/JavaScript%E5%BC%BA%E5%8C%96/" class="post-title-link" itemprop="url">Javscript强化</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-05T00:00:00+08:00">2021-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">必备知识</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/05/JavaScript%E5%BC%BA%E5%8C%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/05/JavaScript%E5%BC%BA%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript高级"><a href="#JavaScript高级" class="headerlink" title="JavaScript高级"></a>JavaScript高级</h1><h1 id="基础总结深入"><a href="#基础总结深入" class="headerlink" title="基础总结深入"></a>基础总结深入</h1><h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><ul>
<li>基本(值)类型<ul>
<li>Number ——- 任意数值 ———— typeof</li>
<li>String ——- 任意字符串 ——— typeof</li>
<li>Boolean —— true/false ——- typeof</li>
<li>undefined —- undefined ——- typeof/===</li>
<li>null ———— null ————— ===</li>
</ul>
</li>
<li>对象(引用)类型<ul>
<li>Object ——- typeof/instanceof</li>
<li>Array ——— instanceof</li>
<li>Function —— typeof</li>
</ul>
</li>
</ul>
<h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ul>
<li>什么是数据?<ul>
<li>在内存中可读的, 可传递的保存了特定信息的’东东’</li>
<li>一切皆数据, 函数也是数据</li>
<li>在内存中的所有操作的目标: 数据</li>
</ul>
</li>
<li>什么是变量?<ul>
<li>在程序运行过程中它的值是允许改变的量</li>
<li>一个变量对应一块小内存, 它的值保存在此内存中  </li>
</ul>
</li>
<li>什么是内存?<ul>
<li>内存条通电后产生的存储空间(临时的)</li>
<li>一块内存包含2个方面的数据<ul>
<li>内部存储的数据</li>
<li>地址值数据</li>
</ul>
</li>
<li>内存空间的分类<ul>
<li>栈空间: 全局变量和局部变量</li>
<li>堆空间: 对象 </li>
</ul>
</li>
</ul>
</li>
<li>内存,数据, 变量三者之间的关系<ul>
<li>内存是容器, 用来存储不同数据</li>
<li>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </li>
</ul>
</li>
</ul>
<h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ul>
<li>什么是对象?<ul>
<li>多个数据(属性)的集合</li>
<li>用来保存多个数据(属性)的容器</li>
</ul>
</li>
<li>属性组成:<ul>
<li>属性名 : 字符串(标识)</li>
<li>属性值 : 任意类型</li>
</ul>
</li>
<li>属性的分类:<ul>
<li>一般 : 属性值不是function  描述对象的状态</li>
<li>方法 : 属性值为function的属性  描述对象的行为</li>
</ul>
</li>
<li>特别的对象<ul>
<li>数组: 属性名是0,1,2,3之类的索引</li>
<li>函数: 可以执行的</li>
</ul>
</li>
<li>如何操作内部属性(方法)<ul>
<li>.属性名</li>
<li>[‘属性名’]: 属性名有特殊字符/属性名是一个变量</li>
</ul>
</li>
</ul>
<h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul>
<li>什么是函数?<ul>
<li>用来实现特定功能的, n条语句的封装体</li>
<li>只有函数类型的数据是可以执行的, 其它的都不可以</li>
</ul>
</li>
<li>为什么要用函数?<ul>
<li>提高复用性</li>
<li>便于阅读交流</li>
</ul>
</li>
<li>函数也是对象<ul>
<li>instanceof Object===true</li>
<li>函数有属性: prototype</li>
<li>函数有方法: call()/apply()</li>
<li>可以添加新的属性/方法</li>
</ul>
</li>
<li>函数的3种不同角色<ul>
<li>一般函数 : 直接调用</li>
<li>构造函数 : 通过new调用</li>
<li>对象 : 通过.调用内部的属性/方法</li>
</ul>
</li>
<li>函数中的this<ul>
<li>显式指定谁: obj.xxx()</li>
<li>通过call/apply指定谁调用: xxx.call(obj)</li>
<li>不指定谁调用: xxx()  : window</li>
<li>回调函数: 看背后是通过谁来调用的: window/其它</li>
</ul>
</li>
<li>匿名函数自调用:<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span>(<span class="name">w</span>, obj)&#123;</span><br><span class="line">  //实现代码</span><br><span class="line">&#125;)(<span class="name">window</span>, obj)</span><br></pre></td></tr></table></figure>
<ul>
<li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式                          </li>
</ul>
</li>
<li>回调函数的理解<ul>
<li>什么函数才是回调函数?<ul>
<li>你定义的</li>
<li>你没有调用</li>
<li>但它最终执行了(在一定条件下或某个时刻)</li>
</ul>
</li>
<li>常用的回调函数<ul>
<li>dom事件回调函数</li>
<li>定时器回调函数</li>
<li>ajax请求回调函数(后面讲解)</li>
<li>生命周期回调函数(后面讲解)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h1><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><ul>
<li>所有函数都有一个特别的属性:<ul>
<li><code>prototype</code> : 显式原型属性</li>
</ul>
</li>
<li>所有实例对象都有一个特别的属性:<ul>
<li><code>__proto__</code> : 隐式原型属性</li>
</ul>
</li>
<li>显式原型与隐式原型的关系<ul>
<li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li>
<li>实例对象的<strong>proto</strong>: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li>
<li>原型对象即为当前实例对象的父对象</li>
</ul>
</li>
<li>原型链<ul>
<li>所有的实例对象都有<strong>proto</strong>属性, 它指向的就是原型对象</li>
<li>这样通过<strong>proto</strong>属性就形成了一个链的结构——&gt;原型链</li>
<li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li>
<li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li>
</ul>
</li>
</ul>
<h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul>
<li>变量提升与函数提升<ul>
<li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li>
<li>函数提升: 在函数定义语句之前, 就执行该函数</li>
<li>先有变量提升, 再有函数提升</li>
</ul>
</li>
<li>理解<ul>
<li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li>
<li>执行上下文栈: 用来管理产生的多个执行上下文</li>
</ul>
</li>
<li>分类:<ul>
<li>全局: window</li>
<li>函数: 对程序员来说是透明的</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡</li>
<li>函数 : 调用函数时产生, 函数执行完时死亡</li>
</ul>
</li>
<li>包含哪些属性:<ul>
<li>全局 : <ul>
<li>用var定义的全局变量  ==&gt;undefined</li>
<li>使用function声明的函数   ===&gt;function</li>
<li>this   ===&gt;window</li>
</ul>
</li>
<li>函数<ul>
<li>用var定义的局部变量  ==&gt;undefined</li>
<li>使用function声明的函数   ===&gt;function</li>
<li>this   ===&gt; 调用函数的对象, 如果没有指定就是window </li>
<li>形参变量   ===&gt;对应实参值</li>
<li>arguments ===&gt;实参列表的伪数组</li>
</ul>
</li>
</ul>
</li>
<li>执行上下文创建和初始化的过程<ul>
<li>全局:<ul>
<li>在全局代码执行前最先创建一个全局执行上下文(window)</li>
<li>收集一些全局变量, 并初始化</li>
<li>将这些变量设置为window的属性</li>
</ul>
</li>
<li>函数:<ul>
<li>在调用函数时, 在执行函数体之前先创建一个函数执行上下文</li>
<li>收集一些局部变量, 并初始化</li>
<li>将这些变量设置为执行上下文的属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul>
<li>理解:<ul>
<li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li>
<li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li>
</ul>
</li>
<li>分类:<ul>
<li>全局</li>
<li>函数</li>
<li>js没有块作用域(在ES6之前)</li>
</ul>
</li>
<li>作用<ul>
<li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li>
<li>作用域链: 查找变量</li>
</ul>
</li>
<li>区别作用域与执行上下文<ul>
<li>作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</li>
<li>执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失</li>
<li>联系: 执行上下文环境是在对应的作用域中的</li>
</ul>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>理解:</p>
<ul>
<li>当嵌套的内部函数引用了外部函数的变量时就产生了闭包</li>
<li>通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性</li>
</ul>
</li>
<li><p>作用:</p>
<ul>
<li>延长局部变量的生命周期</li>
<li>让函数外部能操作内部的局部变量</li>
</ul>
</li>
<li><p>写一个闭包程序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line">f();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包应用:</p>
<ul>
<li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</li>
<li>循环遍历加监听</li>
<li>JS框架(jQuery)大量使用了闭包</li>
</ul>
</li>
<li><p>缺点:</p>
<ul>
<li>变量占用内存的时间可能会过长</li>
<li>可能导致内存泄露</li>
<li>解决:<ul>
<li>及时释放 : f = null; //让内部函数对象成为垃圾对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ol>
<li><p>内存溢出</p>
<ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li>
</ul>
</li>
<li><p>内存泄露</p>
<ul>
<li>占用的内存没有及时释放</li>
<li>内存泄露积累多了就容易导致内存溢出</li>
<li>常见的内存泄露:<ul>
<li>意外的全局变量</li>
<li>没有及时清理的计时器或回调函数</li>
<li>闭包</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="对象高级"><a href="#对象高级" class="headerlink" title="对象高级"></a>对象高级</h1><h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul>
<li><p>Object构造函数模式</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">'Tom'</span></span><br><span class="line">obj.setName = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>&#123;<span class="keyword">this</span>.name=name&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量模式</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">'Tom'</span>,</span><br><span class="line">  setName : <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>&#123;<span class="keyword">this</span>.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>&#123;<span class="keyword">this</span>.name=name;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'tom'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数+原型的组合模式</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>&#123;<span class="keyword">this</span>.name=name;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'tom'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul>
<li><p>原型链继承 : 得到方法</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span><span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">Parent</span>.<span class="title">prototype</span>.<span class="title">test</span> = <span class="title">function</span><span class="params">()</span><span class="comment">&#123;&#125;</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span><span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">Child</span>.<span class="title">prototype</span> = <span class="title">new</span> <span class="title">Parent</span><span class="params">()</span>;</span> <span class="comment">// 子类型的原型指向父类型实例</span></span><br><span class="line">Child.prototype<span class="function">.<span class="keyword">constructor</span> = <span class="title">Child</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">child</span> = <span class="title">new</span> <span class="title">Child</span><span class="params">()</span>;</span> <span class="comment">//有test()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>借用构造函数 : 得到属性</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Parent(<span class="params">xxx</span>)</span>&#123;this.xxx = xxx&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Parent</span>.</span></span>prototype.test = <span class="keyword">function</span><span class="literal">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Child(<span class="params">xxx</span>,<span class="params">yyy</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Parent</span>.</span></span>call(this, xxx);<span class="comment">//借用构造函数   this.Parent(xxx)</span></span><br><span class="line">&#125;</span><br><span class="line">var child = <span class="keyword">new</span> <span class="constructor">Child('<span class="params">a</span>', '<span class="params">b</span>')</span>;  <span class="comment">//child.xxx为'a', 但child没有test()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组合</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Parent(<span class="params">xxx</span>)</span>&#123;this.xxx = xxx&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Parent</span>.</span></span>prototype.test = <span class="keyword">function</span><span class="literal">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Child(<span class="params">xxx</span>,<span class="params">yyy</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Parent</span>.</span></span>call(this, xxx);<span class="comment">//借用构造函数   this.Parent(xxx)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Child</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">Parent()</span>; <span class="comment">//得到test()</span></span><br><span class="line">var child = <span class="keyword">new</span> <span class="constructor">Child()</span>; <span class="comment">//child.xxx为'a', 也有test()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new一个对象背后做了些什么?</p>
<ul>
<li>创建一个空对象</li>
<li>给对象设置<strong>proto</strong>, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li>
<li>执行构造函数体(给对象添加属性/方法)</li>
</ul>
</li>
</ul>
<h1 id="线性机制和事件机制"><a href="#线性机制和事件机制" class="headerlink" title="线性机制和事件机制"></a>线性机制和事件机制</h1><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul>
<li>进程:<ul>
<li>程序的一次执行, 它占有一片独有的内存空间</li>
<li>可以通过windows任务管理器查看进程</li>
</ul>
</li>
<li>线程:<ul>
<li>是进程内的一个独立执行单元</li>
<li>是程序执行的一个完整流程</li>
<li>是CPU的最小的调度单元</li>
</ul>
</li>
<li>关系<ul>
<li>一个进程至少有一个线程(主)</li>
<li>程序是在某个进程中的某个线程执行的</li>
</ul>
</li>
</ul>
<h2 id="浏览器内核模块组成"><a href="#浏览器内核模块组成" class="headerlink" title="浏览器内核模块组成"></a>浏览器内核模块组成</h2><ul>
<li>主线程<ul>
<li>js引擎模块 : 负责js程序的编译与运行</li>
<li>html,css文档解析模块 : 负责页面文本的解析</li>
<li>DOM/CSS模块 : 负责dom/css在内存中的相关处理 </li>
<li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</li>
</ul>
</li>
<li>分线程<ul>
<li>定时器模块 : 负责定时器的管理</li>
<li>DOM事件模块 : 负责事件的管理</li>
<li>网络请求模块 : 负责Ajax请求</li>
</ul>
</li>
</ul>
<h2 id="js线程"><a href="#js线程" class="headerlink" title="js线程"></a>js线程</h2><ul>
<li>js是单线程执行的(回调函数也是在主线程)</li>
<li>H5提出了实现多线程的方案: Web Workers</li>
<li>只能是主线程更新界面</li>
</ul>
<h2 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题:"></a>定时器问题:</h2><ul>
<li>定时器并不真正完全定时</li>
<li>如果在主线程执行了一个长时间的操作, 可能导致延时才处理</li>
</ul>
<h2 id="事件处理机制-图"><a href="#事件处理机制-图" class="headerlink" title="事件处理机制(图)"></a>事件处理机制(图)</h2><ul>
<li>代码分类<ul>
<li>初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li>
<li>回调执行代码: 处理回调逻辑</li>
</ul>
</li>
<li>js引擎执行代码的基本流程: <ul>
<li>初始化代码===&gt;回调代码</li>
</ul>
</li>
<li>模型的2个重要组成部分:<ul>
<li>事件管理模块</li>
<li>回调队列</li>
</ul>
</li>
<li>模型的运转流程<ul>
<li>执行初始化代码, 将事件回调函数交给对应模块管理</li>
<li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li>
<li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li>
</ul>
</li>
</ul>
<h2 id="H5-Web-Workers"><a href="#H5-Web-Workers" class="headerlink" title="H5 Web Workers"></a>H5 Web Workers</h2><ul>
<li><p>可以让js在分线程执行</p>
</li>
<li><p>Worker</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line">worker.onMessage = <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">event</span>)</span><span class="comment">&#123;event.data&#125;</span> :</span> 用来接收另一个线程发送过来的数据的回调</span><br><span class="line">worker.postMessage(data1) : 向另一个线程发送数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题:</p>
<ul>
<li>worker内代码不能操作DOM更新UI</li>
<li>不是每个浏览器都支持这个新特性</li>
<li>不能跨域加载JS</li>
</ul>
</li>
<li><p>svn版本控制</p>
</li>
<li><p>svn server</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-20T00:00:00+08:00">2021-12-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112282238918.png" alt="image-20211228223836643"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">栈:后进先出</span><br><span class="line">前端与栈=&gt;JS中的函数调用堆栈:最后调用的函数，最先执行完.</span><br><span class="line">栈：对于<span class="number">10</span>进制转<span class="number">2</span>进制可以倒叙输出</span><br><span class="line">JavaScript 中没有栈，但可以用<span class="built_in">Array</span> 实现栈的所有功能。</span><br><span class="line">栈常用操作: push、pop、获取栈顶元素=&gt;stack[stack.length<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">先进先出  JavaScript 中没有队列，但可以用<span class="built_in">Array</span> 实现队列的所有功能。</span><br><span class="line">push和shift方法实现队列的先进先出 队头queue[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> queqe = []</span><br><span class="line">queqe.pop(<span class="number">1</span>)</span><br><span class="line">queqe.pop(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> item = queqe.shift()</span><br><span class="line"><span class="keyword">const</span> item = queqe.shift()</span><br><span class="line">什么场景用队列？</span><br><span class="line">	<span class="number">1</span>、排队食堂打饭</span><br><span class="line">    <span class="number">2</span>、JS异步中的任务队列:JS是单线程，无法同时处理异步中的并发任务。使用任务队列先后处理异步任务。</span><br><span class="line">    <span class="number">3</span>、计算最近<span class="number">3000</span>ms内请求次数</span><br><span class="line">    	输入:inputs = [[],[<span class="number">1</span>],[<span class="number">100</span>],[<span class="number">3001</span>],[<span class="number">3002</span>]]</span><br><span class="line">		输出:[<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">JS异步中的事件循环和任务队列:一段JS代码刚执行的时候会有一个主事件，会放到任务队列里，JS引擎会在任队列里取一个事件执行，因为JS引擎是单线程的，所以每一次只会执行一个事件，在执行事件的过程中，如果里面有异步任务，比如DOM操作，ajax，setTimeout等等，它就会丢到外部API执行，而且丢完就不管了，就会执行后面的代码，而外部API执行异步任务结束的时候，会把回调函数的JS代码放到任务队列里，然后任务队列里面前面的事件都执行完了，那么回调函数的JS代码就会方法哦JS引擎里执行，如果回调函数里面还有异步任务就继续做这个循环，这就是事件循环。</span><br></pre></td></tr></table></figure>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">多个元素组成的列表。</span><br><span class="line">元素存储不连续，用next 指针连在一起。</span><br><span class="line">数组:增删非首尾元素时往往需要移动元素。</span><br><span class="line">链表:增删非首尾元素，不需要移动元素，只需要更改next的指向即可。</span><br><span class="line">JavaScript中没有链表。可以用<span class="built_in">Object</span>模拟链表。</span><br><span class="line"></span><br><span class="line">原型链的本质就是链表</span><br><span class="line">原型链上的节点是各种原型对象，比如</span><br><span class="line"><span class="built_in">Function</span>.prototype、<span class="built_in">Object</span>.prototype....</span><br><span class="line">原型链通过__proto__属性连接各种原型对象。</span><br><span class="line">obj -&gt; <span class="built_in">Object</span>.prototype -&gt; <span class="literal">null</span>  (都是自身的__proto__)</span><br><span class="line">func -&gt;<span class="built_in">Function</span>.prototype -&gt; <span class="built_in">Object</span>.prototype -&gt;<span class="literal">null</span></span><br><span class="line">arr -&gt;<span class="built_in">Array</span>.prototype -&gt; <span class="built_in">Object</span>.prototype -&gt;<span class="literal">null</span> arr的原型链</span><br><span class="line">如果A沿着原型链能找到 B.prototype，那么A <span class="keyword">instanceof</span> B 为<span class="literal">true</span>。</span><br><span class="line">如果在A对象上没有找到×属性，那么会沿着原型链找x属性。</span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">集合:无序且唯一的数据结构  <span class="built_in">Set</span></span><br><span class="line">常用的操作:去重，判断某元素是否在集合中，求交集</span><br><span class="line"></span><br><span class="line">去重:   </span><br><span class="line">		<span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">const</span> arr2=[...new <span class="built_in">Set</span>(arr)]<span class="comment">//集合转数组，答案为1,2 </span></span><br><span class="line">判断元素是否在集合中:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">set</span> = new Set(arr)</span><br><span class="line">        cosnt has = <span class="keyword">set</span>.has(3) //false</span><br><span class="line">求交集:	</span><br><span class="line">		const set2 = new Set([2,3])//&#123;<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">        <span class="keyword">const</span> set3 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">item</span>=&gt;</span>set2.has(item)))<span class="comment">//先将集合set转化为数组之后在利用数组的过滤方法</span></span><br><span class="line">前端与集合：使用ES6的<span class="built_in">Set</span>   </span><br><span class="line">	使用<span class="built_in">Set</span> 对象:<span class="keyword">new</span>、add、<span class="keyword">delete</span>、has、size</span><br><span class="line">	迭代<span class="built_in">Set</span>:多种迭代方法、<span class="built_in">Set</span> 与<span class="built_in">Array</span>互转、求交集/差集</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> mySet) log(item)<span class="comment">//就会把mySet里的值全部打印出来</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> mySet.values()) log(item)<span class="comment">//就会把mySet里的值全部打印出来</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> mySet.keys()) log(item)<span class="comment">//就会把mySet里的值全部打印出来</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> mySet.entries) log(key,value)<span class="comment">//就会把mySet里的值打印两遍，分别是key和value的值</span></span><br><span class="line">		<span class="keyword">const</span> myArr = [...mySet];<span class="comment">//集合转数组</span></span><br><span class="line">		<span class="keyword">const</span> myArr = <span class="built_in">Array</span>.from(mySet);<span class="comment">//集合转数组</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> mySet2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);<span class="comment">//数组转集合</span></span><br><span class="line">		cosnt intersection = <span class="keyword">new</span> <span class="built_in">Set</span>([...mySet].filter(<span class="function"><span class="params">item</span>=&gt;</span>mySet2.has(item))) <span class="comment">//交集</span></span><br><span class="line">		<span class="keyword">const</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...mySet].filter(<span class="function"><span class="params">item</span>=&gt;</span> !mySet2.has(item)))</span><br><span class="line">数组转集合 :  <span class="keyword">set</span> = new Set(arr)</span><br><span class="line">集合转数组: arr2 = [...new Set(arr)]</span><br><span class="line">集合总结:</span><br><span class="line">	集合是一种无序且唯一的数据结构。</span><br><span class="line">	ES6中有集合，名为Set。</span><br><span class="line">	集合的常用操作:去重、判断某元素是否在集合中、求交集</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">也是存储唯一值的数据结构，但是是以键值对的形式来存储的</span><br><span class="line">ES6中有字典，名为<span class="built_in">Map</span> </span><br><span class="line">常用的常用操作，就是键值对的增删改查</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">'a'</span>:<span class="string">'aa'</span>);key为a value为aa</span><br><span class="line">查的话可以通过键来查值 m.get(<span class="string">'a'</span>)就会显示aa</span><br><span class="line">m.delete(<span class="string">'b'</span>)<span class="comment">//删除键</span></span><br><span class="line">m.clear()<span class="comment">//删除所有键</span></span><br><span class="line">m.set(<span class="string">'a'</span>,<span class="string">'aaa'</span>)<span class="comment">//键的值会被覆盖  set get等方法的时间复杂度都是O(1)</span></span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">分层数据的抽象模型 在前端广泛应用</span><br><span class="line">前端DOM树</span><br><span class="line">JS没有树，但可以用<span class="built_in">Object</span>和<span class="built_in">Array</span>构建树</span><br><span class="line">树的深度与广度优先遍历</span><br><span class="line">深度优先遍历:尽可能深的搜索树的分支。 ***** 重点</span><br><span class="line">	访问根节点。</span><br><span class="line">	对根节点的children 挨个进行深度优先遍历。</span><br><span class="line">    <span class="keyword">const</span> tree = &#123;</span><br><span class="line">        val:<span class="string">'a'</span>,</span><br><span class="line">        children:[</span><br><span class="line">            &#123;</span><br><span class="line">                val:<span class="string">'b'</span>,</span><br><span class="line">                children:[</span><br><span class="line">                                &#123;</span><br><span class="line">                            val:<span class="string">'d'</span>,</span><br><span class="line">                            children:[]</span><br><span class="line">                        &#125;&#123;</span><br><span class="line">                            val:<span class="string">'e'</span>,</span><br><span class="line">                            children:[]</span><br><span class="line">                        &#125;</span><br><span class="line">                         ]</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#123;</span><br><span class="line">                val:<span class="string">'c'</span>,</span><br><span class="line">                children:[]</span><br><span class="line">                    &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="keyword">const</span> dfs = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">        log(root.val)</span><br><span class="line">        root.children.forEach(dfs);  <span class="comment">// 输出abdec</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(tree)</span><br><span class="line">广度优先遍历:先访问离根节点最近的节点。先进先出</span><br><span class="line">    新建一个队列，把根节点入队。</span><br><span class="line">    把队头出队并访问。</span><br><span class="line">    把队头的children挨个入队。</span><br><span class="line">    重复第二、三步，直到队列为空。</span><br><span class="line">	<span class="keyword">const</span> bfs = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> q = [root]</span><br><span class="line">        <span class="keyword">while</span>(q.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> n = q.shift()<span class="comment">//队头出队并访问</span></span><br><span class="line">            log(n.val)         <span class="comment">//abcde</span></span><br><span class="line">            n.children.forEach(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">                q.push(child)   </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	bfs(tree)</span><br><span class="line"></span><br><span class="line">递归版的二叉树先中后序遍历</span><br><span class="line">先序遍历:根左右</span><br><span class="line">	<span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        log(root,val)</span><br><span class="line">        preorder(root.left)</span><br><span class="line">        preorder(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(bt)</span><br><span class="line">中序遍历： 左根右</span><br><span class="line">	<span class="keyword">const</span> inorder = <span class="function">(<span class="params">root</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        inorder(root.left)</span><br><span class="line">        log(root,val)</span><br><span class="line">        inorder(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(bt) </span><br><span class="line">后序遍历： 左右根</span><br><span class="line">	<span class="keyword">const</span> postorder = <span class="function">(<span class="params">root</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        postorder(root.left)</span><br><span class="line">        postorder(root.right)</span><br><span class="line">        log(root,val)</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(bt)</span><br><span class="line"></span><br><span class="line">非递归版的二叉树先中后序遍历 **用栈来实现</span><br><span class="line">先序遍历:根左右</span><br><span class="line">	<span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">const</span> stack = [root]</span><br><span class="line">        <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">            log(n.val)=&gt; res.push(n.val)</span><br><span class="line">            <span class="keyword">if</span>(n.right) stack.push(n.right)</span><br><span class="line">            <span class="keyword">if</span>(n.left)  stack,push(n.left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(bt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">中序遍历:左根右</span><br><span class="line">	<span class="keyword">const</span> inorder = <span class="function">(<span class="params">root</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">const</span> stack = [root]</span><br><span class="line">        <span class="keyword">let</span> p = root</span><br><span class="line">        <span class="keyword">while</span>(p||stack.length)&#123;  <span class="comment">//stack.length 会为空的。 遍历完根的全部左节点就空了</span></span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">              stack.push(root) </span><br><span class="line">              p=p.left  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">            log(n.val)</span><br><span class="line">            p = n.right </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    inorder(bt)</span><br><span class="line"></span><br><span class="line">后序遍历:左右根 将其看成先序遍历的倒叙（根左右）根右左和根左右区别</span><br><span class="line">	<span class="keyword">const</span> postorder = <span class="function">(<span class="params">root</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">const</span> stack = [root] <span class="comment">// 先序的</span></span><br><span class="line">        <span class="keyword">const</span> output= []  <span class="comment">// 倒叙的</span></span><br><span class="line">        <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> n = stack.pop()</span><br><span class="line">            output.push(n)</span><br><span class="line">            <span class="keyword">if</span>(n.left)  stack,push(n.left)</span><br><span class="line">            <span class="keyword">if</span>(n.right) stack.push(n.right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(output.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> n = output.pop()</span><br><span class="line">            log(n.val)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(bt)</span><br><span class="line">左右根  </span><br><span class="line"><span class="keyword">const</span> postinder=<span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> stack = [root]</span><br><span class="line">    <span class="keyword">const</span> output = []</span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        n=stack.pop()</span><br><span class="line">        output.push(n)</span><br><span class="line">        <span class="keyword">if</span>(n.left)  stack.push(n.left)</span><br><span class="line">        <span class="keyword">if</span>(n.right) stack.push(n.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(output.length)&#123;</span><br><span class="line">        <span class="keyword">const</span> n = output.pop()</span><br><span class="line">        log(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">图是网络结构的抽象模型，是一组由边连接的节点</span><br><span class="line">JS没有图，但可以用<span class="built_in">Object</span>和<span class="built_in">Array</span>构建图</span><br><span class="line">操作：深度优先遍历和广度优先遍历 和树差不多</span><br><span class="line">**深度优先遍历**</span><br><span class="line"><span class="keyword">const</span> graph = &#123;</span><br><span class="line">    <span class="number">0</span>:[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">    <span class="number">1</span>:[<span class="number">2</span>],</span><br><span class="line">    <span class="number">2</span>:[<span class="number">0</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="number">3</span>:[<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'graph'</span>) <span class="comment">//graph就是下面的箭头图</span></span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">	log(n)</span><br><span class="line">    visited.add(n)<span class="comment">//集合add</span></span><br><span class="line">    graph[n].forEach(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited.has(c))&#123;</span><br><span class="line">            dfs(c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">**广度优先遍历**</span><br><span class="line">新建一个队列，把根节点入队。</span><br><span class="line">把队头出队并访问。</span><br><span class="line">把队头的没访问过的相邻节点入队。</span><br><span class="line">重复二三步，直至队列为空</span><br><span class="line"><span class="keyword">const</span> q = [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">visited.add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">    n = q.shift()</span><br><span class="line">    graph[n].forEach(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited.has(c))&#123;</span><br><span class="line">            q.push(c)</span><br><span class="line">            visited.add(n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LeetCode <span class="number">133</span> 克隆图</span><br><span class="line">图的深度优先遍历算法</span><br><span class="line">	<span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">   	<span class="keyword">const</span> dfs=<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> nodeCopy  = <span class="keyword">new</span> Node(n.val)</span><br><span class="line">        visited.set(n,nodeCopy)</span><br><span class="line">        (n.neighbors||[]).forEach(<span class="function"><span class="params">ne</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.has(ne))&#123;</span><br><span class="line">                dfs(ne)</span><br><span class="line">            &#125;</span><br><span class="line">            nodeCopy.neighbors.push(visited.get(ne))</span><br><span class="line">        &#125;)   </span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node)</span><br><span class="line">	<span class="keyword">return</span> visited.get(node)</span><br><span class="line"></span><br><span class="line">图的广度优先遍历算法</span><br><span class="line">	<span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">const</span> q = [root]</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    visited.set(root,<span class="keyword">new</span> Node(root.val))</span><br><span class="line">    <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">        <span class="keyword">const</span> n = q.shift()</span><br><span class="line">        (n.neighbors||[]).forEach(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.has(c))&#123;</span><br><span class="line">                q.push(c)</span><br><span class="line">                visited.set(c,<span class="keyword">new</span> Node(c.val))</span><br><span class="line">            &#125;</span><br><span class="line">            visited.get(n).neighbors.push(visited.get(c))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited.get(node)</span><br><span class="line"></span><br><span class="line">图总结:  图是网络结构的抽象模型，是一组由边连接的节点</span><br><span class="line">		图可以表示任何二元关系</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112240950518.png" alt="image-20211224095045641"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">堆是一种特殊的完全二叉树（子节点全部填满，没填满也是缺少右边的节点）</span><br><span class="line">JS中通常用数组表示堆</span><br><span class="line">堆能高效、快速地找出最大值和最小值，时间复杂度:O(<span class="number">1</span>).</span><br><span class="line">找出第K个最大（小)元素。</span><br><span class="line">堆的时间复杂度是O(<span class="number">1</span>)</span><br><span class="line">JS实现最小堆内:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHead</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.heap = []  <span class="comment">//声明数组绑定this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(l1,l2)&#123;</span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">this</span>.heap[l1]</span><br><span class="line">        <span class="keyword">this</span>.heap[l1]=<span class="keyword">this</span>.heap[l2]</span><br><span class="line">        <span class="keyword">this</span>.heap[l2]=temp</span><br><span class="line">    &#125;</span><br><span class="line">    getPare(i)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor((i<span class="number">-1</span>)/<span class="number">2</span>)<span class="comment">// 二进制数向右移动一位  等于Math.floor((i-1)/2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    shiftup(index)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">const</span> Pxia  = <span class="keyword">this</span>.getPare(index)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.heap[Pxia]&gt;<span class="keyword">this</span>.heap[index])&#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(Pxia,index)</span><br><span class="line">            <span class="keyword">this</span>.shiftup(Pxia)</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    getleft(i)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    getRight(i)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    shiftDown(index)&#123;</span><br><span class="line">        <span class="keyword">const</span> Lnode = <span class="keyword">this</span>.getleft(index)</span><br><span class="line">        <span class="keyword">const</span> RLoad = <span class="keyword">this</span>.getRight(index)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.heap[index]&gt;<span class="keyword">this</span>.heap[Lnode])&#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(index,Lnode)</span><br><span class="line">            <span class="keyword">this</span>.shiftDown(Lnode)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.heap[index]&gt;<span class="keyword">this</span>.heap[RLoad])&#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(index,RLoad)</span><br><span class="line">            <span class="keyword">this</span>.shiftDown(RLoad)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pop()&#123;       <span class="comment">//删除堆顶</span></span><br><span class="line">        <span class="keyword">this</span>.heap[<span class="number">0</span>] = <span class="keyword">this</span>.heap.pop()</span><br><span class="line">        <span class="keyword">this</span>.shiftDown(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    insert(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.heap.push(value)</span><br><span class="line">        <span class="keyword">this</span>.shiftup(<span class="keyword">this</span>.heap.length<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    peek()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.heap[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    size()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.heap.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h  = <span class="keyword">new</span> MinHead()</span><br><span class="line">h.insert(<span class="number">3</span>)</span><br><span class="line">h.insert(<span class="number">2</span>)</span><br><span class="line">h.insert(<span class="number">1</span>)</span><br><span class="line">h.pop()</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112250952399.png" alt="image-20211225095227038"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112251002871.png" alt="image-20211225100257620"></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">    排序:把某个乱序的数组变成升序或者降序的数组。  冒泡.选择.插入.归并.快速</span><br><span class="line">    搜索:找出数组中某个元素的下标。顺序.二分.</span><br><span class="line"><span class="number">2</span>、</span><br><span class="line">    JS中的排序:数组的sort方法。</span><br><span class="line">    JS中的搜索:数组的indexOf方法。</span><br><span class="line">(<span class="number">1</span>)冒泡排序:</span><br><span class="line">	第一个比第二个大就交换 这样最大的元素在最后一个</span><br><span class="line">    执行n<span class="number">-1</span>轮，就可以完成排序</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span> ; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i += <span class="number">1</span>)&#123; 这是轮数</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="keyword">this</span>.length - <span class="number">1</span>-i; j +=<span class="number">1</span>)&#123;  这是将<span class="number">5</span>放到最后一位 <span class="keyword">this</span>.length - <span class="number">1</span>是为了j+<span class="number">1</span>有值</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j +<span class="number">1</span>])&#123;</span><br><span class="line">		  <span class="keyword">const</span> temp = <span class="keyword">this</span>[j];</span><br><span class="line">          <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j +<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">this</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">	<span class="keyword">const</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">    就完成排序了  两个嵌套循环  时间复杂度为O(n^<span class="number">2</span>)</span><br><span class="line">                                                 </span><br><span class="line">(<span class="number">2</span>)选择排序</span><br><span class="line">    找到数组中的最小值，选中它并将其放置在第一位。</span><br><span class="line">    接着找到第二小的值，选中它并将其放置在第二位。</span><br><span class="line">    以此类推，执行n <span class="number">-1</span>轮。</span><br><span class="line"> <span class="keyword">const</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"> <span class="keyword">const</span> selectionSort  = <span class="function">(<span class="params">array</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex;<span class="comment">//要定义</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; </span><br><span class="line">       <span class="comment">// 更新 minIndex</span></span><br><span class="line">       minIndex = i;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; length; j++) &#123; <span class="comment">//这是第一轮获取下标</span></span><br><span class="line">           <span class="keyword">if</span>(array[minIndex]&gt;array[j])&#123;</span><br><span class="line">              minIndex = j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果该最小值和原最小值不同 则交换其值  相等就没必要交换了</span></span><br><span class="line">       <span class="keyword">if</span>(i!==minIndex)&#123;</span><br><span class="line">           <span class="keyword">var</span> aux = array[i];   </span><br><span class="line">           array[i] = array[minIndex];</span><br><span class="line">           array[minIndex] = aux;   <span class="comment">//这是交换值  交换玩从第二个值开始 所以j=i</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line">两个嵌套循环  时间复杂度为O(n^<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">(<span class="number">3</span>)插入排序:</span><br><span class="line">     从第二个数开始往前比。</span><br><span class="line">	 比它大就往后排。</span><br><span class="line">	 以此类推进行到最后一个数。</span><br><span class="line">第一轮的插入如下</span><br><span class="line"> array = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]                                              </span><br><span class="line"> 	<span class="keyword">const</span> temp = <span class="keyword">this</span>[<span class="number">1</span>]<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.[j<span class="number">-1</span>]&gt;temp)&#123;  <span class="number">5</span>&gt;<span class="number">4</span>  </span><br><span class="line">            <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j<span class="number">-1</span>]  <span class="comment">//55321</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        j-=<span class="number">1</span>  <span class="comment">//j=0</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">this</span>[j]=temp <span class="comment">//45321</span></span><br><span class="line">-----------</span><br><span class="line">         <span class="number">45321</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">        	<span class="keyword">const</span> temp = <span class="keyword">this</span>[i]<span class="comment">//</span></span><br><span class="line">            <span class="keyword">let</span> j = i </span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.[j<span class="number">-1</span>]&gt;temp)&#123;  <span class="number">4</span>&gt;<span class="number">3</span></span><br><span class="line">                    <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j<span class="number">-1</span>]  <span class="comment">//45521</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j-=<span class="number">1</span>  <span class="comment">//j=1          </span></span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">this</span>[j]=temp <span class="comment">//43521      </span></span><br><span class="line">    &#125;</span><br><span class="line"> 所以就完成了<span class="comment">// 时间复杂度为O(n^2)</span></span><br><span class="line"> </span><br><span class="line">(<span class="number">4</span>)归并排序:</span><br><span class="line">    分:把数组劈成两半，再递归地对子数组进行“分”操作，直到分成一个个单独的数。</span><br><span class="line">    合:把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组。</span><br><span class="line"></span><br><span class="line">	新建一个空数组res，用于存放最终排序后的数组。</span><br><span class="line">	比较两个有序数组的头部，较小者出队并推入res中。</span><br><span class="line">	如果两个数组还有值，就重复第二步。</span><br><span class="line">    [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">    rec=<span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length===<span class="number">1</span>)&#123;<span class="keyword">return</span> res;&#125;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>,mid)[<span class="number">5</span>,<span class="number">4</span>]     </span><br><span class="line">        <span class="keyword">const</span> right = arr.slic(mid,arr.length)[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">const</span> leftcount = rec(left) </span><br><span class="line">        <span class="keyword">const</span> rightcount = rec(right)  </span><br><span class="line">        <span class="keyword">const</span> res= []</span><br><span class="line">        <span class="keyword">while</span>(leftcount.length||rightcount.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rightcount.length&amp;&amp;leftcount.length)&#123;</span><br><span class="line">                res.push(leftcount[<span class="number">0</span>]&lt;rightcount[<span class="number">0</span>]?leftcount.shift():rightcount.shift())</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightcount.length)&#123;</span><br><span class="line">                res.push(rightcount.shift())</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftcount.length)&#123;</span><br><span class="line">                res.push(leftcount.shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"> logN 是求<span class="number">2</span>的多少次方  因为是对半劈所以分的时间复杂度为O(logN),合的复杂度是O(n) 分合是嵌套关系所以复杂度就是O(nlogN)</span><br><span class="line">    </span><br><span class="line">(<span class="number">5</span>)快速排序</span><br><span class="line"> 分区:从数组中任意选择一个“基准”，所有比基准小的元素放在基准前面，比基准大的元素放在基准的后面。</span><br><span class="line"> 递归:递归地对基准前后的子数组进行分区。</span><br><span class="line"> 	 rec = <span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> left = []</span><br><span class="line">        <span class="keyword">const</span> right = []</span><br><span class="line">        <span class="keyword">const</span> mid = arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;arr.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;mid)&#123;</span><br><span class="line">                left.push(arr[i])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [...res[left],mid,...res[right]]</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">const</span> res = rec(<span class="keyword">this</span>)</span><br><span class="line">    时间复杂度:递归的时间复杂度是O(logN)=&gt;劈两半 分区操作的时间复杂度是O(n)=&gt;写一个<span class="keyword">for</span>循环比较与基准值大还是小的元素</span><br><span class="line">   [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">rec=<span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> left=[]<span class="comment">//45</span></span><br><span class="line">    <span class="keyword">const</span> right=[]<span class="comment">//21</span></span><br><span class="line">    <span class="keyword">const</span> mid = arr[<span class="number">0</span>]<span class="comment">//3 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;mid)&#123;</span><br><span class="line">            right.push(arr[i])<span class="comment">//45</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left.push(arr[i])<span class="comment">//21 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...rec(left),mid,...rec(right)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>)顺序搜索</span><br><span class="line"><span class="keyword">for</span>遍历 如果找到值相同就返回下标  否则返回<span class="number">-1</span>    时间复杂度为O(n)</span><br><span class="line">(<span class="number">7</span>)二分搜索-折半搜索(前提是有序)</span><br><span class="line">   从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束。</span><br><span class="line">   如果目标值大于或者小于中间元素，则在大于或小于中间元素的那一半数组中搜索。</span><br><span class="line">	binarySearch=<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> right = arr.length<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">const</span> element = arr[mid]</span><br><span class="line">            <span class="keyword">if</span>(element&lt;item)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element&gt;item)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  时间复杂度为O(logN) 每一次比较都使搜索范围缩小一半    </span><br><span class="line">  </span><br><span class="line">LeetCode21.合并两个有序链表  </span><br><span class="line">                                                 输入<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>,<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">                                                 输出<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br><span class="line">新建一个新链表，作为返回结果。</span><br><span class="line">用指针遍历两个有序链表，并比较两个链表的当前节点，较小者先接入新链表，并将指针后移一步。</span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1,l2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> p1 = res</span><br><span class="line">    <span class="keyword">let</span> p2 = l1</span><br><span class="line">    <span class="keyword">let</span> p3 = l2 </span><br><span class="line">    <span class="keyword">while</span>(p2&amp;&amp;p3)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p2.val&lt;p3.val)&#123;</span><br><span class="line">            p1.next=p2</span><br><span class="line">            p2=p2.next <span class="comment">//p1用过了 所以要后移一位</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p1.next = p3</span><br><span class="line">            p3=p3.next</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p2)&#123;</span><br><span class="line">        p1.next = p2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p2)&#123;</span><br><span class="line">        p1.next = p3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度因为有一个<span class="keyword">while</span>循环体 所以为O(n) n为两个链表的长度只和</span><br><span class="line">空间复杂度为O(<span class="number">1</span>),是个常量级别的。新建的临时变量是指针，不是数组，不是矩阵，更不是链表，用的是常量级别的变量来完成操作的</span><br><span class="line"><span class="number">374</span>:猜数字大小=&gt;二分搜索</span><br><span class="line">唯一的不同是通过调用guess函数，来判断中间元素是否是目标值 而之前的是目标值已给定</span><br><span class="line"><span class="keyword">var</span> guessNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">10</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((right+left)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> result = guess(mid)</span><br><span class="line">        <span class="keyword">if</span>(result===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result === <span class="number">1</span>)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">时间复杂度:每次搜索区别都缩半 所以是O(logN)</span><br><span class="line">空间复杂度为:O(<span class="number">1</span>),没有新建临时变量时数组，矩阵线性增长的需要    </span><br><span class="line">总结:</span><br><span class="line">    排序:把某个乱序的数组变成升序或者降序的数组。</span><br><span class="line">    搜索:找出数组中某个元素的下标。</span><br><span class="line">    JS中的排序:数组的sort方法。</span><br><span class="line">    JS中的搜索:数组的indexOf方法。</span><br></pre></td></tr></table></figure>
<h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">算法设计的一种方法</span><br><span class="line">把一个问题分成多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题</span><br><span class="line">分:把数组从中间一分为二。</span><br><span class="line">解:递归地对两个子数组进行归并排序。</span><br><span class="line">快排也是分而治之的思想              **归并排序，快速排序，二分搜索，翻转二叉树都可以用分而治之的思想进行求解</span><br><span class="line"><span class="number">226</span>翻转二叉树</span><br><span class="line">先翻转左右子树，再将子树换个位置</span><br><span class="line">分：获取左右子树</span><br><span class="line">解：递归地翻转左右子树</span><br><span class="line">合：将翻转后的左右子树换个位置放到根节点上</span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span> <span class="literal">null</span>&#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        val:root.val</span><br><span class="line">        left:invertTree(right)</span><br><span class="line">        right:invertTree(left)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100.</span>两棵相同的树</span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p1&amp;&amp;!p2)&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="keyword">if</span>(p&amp;&amp;q&amp;&amp;p.val===q.val&amp;&amp;isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">时间复杂度：递归遍历树的节点 O（n）n就是树的节点树</span><br><span class="line">空间复杂度：由于是递归，在内部形成了堆栈，所以说空间复杂度为O(n)</span><br><span class="line"><span class="number">101.</span>对称二叉树</span><br><span class="line">转化为:左右子树是否镜像。</span><br><span class="line">分解为:树<span class="number">1</span>的左子树和树<span class="number">2</span>的右子树是否镜像，树<span class="number">1</span>的右子树和树<span class="number">2</span>的左子树是否镜像。</span><br><span class="line">符合“分、解、合”特性，考虑选择分而治之。</span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span> ture&#125;</span><br><span class="line">    <span class="keyword">const</span> isMirror = <span class="function">(<span class="params">l,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l&amp;&amp;!r)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(l&amp;&amp;r&amp;&amp;l.val===r.val&amp;&amp;isMirror(l.left,r.right)&amp;&amp;isMirror(l.right,r.left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left,root.right)</span><br><span class="line">&#125;</span><br><span class="line">空间复杂度:O(n) 访问所有节点</span><br><span class="line">时间复杂度:堆栈的高度 树的高度O(n) 如果二叉树分布均匀的话就是O(logN)</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">动态规划是算法设计中的一种方法 是将一个问题分解为相互重叠的子问题，通过反复求解子问题，来解决原来的问题</span><br><span class="line">分而治之是子问题相互独立</span><br><span class="line">例如斐波那契数列</span><br><span class="line">定义子问题 F(n)=F(n<span class="number">-1</span>)+F(n<span class="number">-2</span>)</span><br><span class="line">反复执行，从<span class="number">2</span>循环到n，执行上述公式</span><br><span class="line">LeetCode70、爬楼梯</span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">const</span> dp = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>循环 时间复杂度为O(n)</span><br><span class="line">创建了一个数组，数组会线性增加 O(n)  想要降低空间复杂度</span><br><span class="line">可以</span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">let</span> dp0 = <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">let</span> dp1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> temp = dp0</span><br><span class="line">        dp0=dp1</span><br><span class="line">        dp1 = dp1+temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp1</span><br><span class="line">&#125;</span><br><span class="line">LeetCode198 打家劫舍</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>] <span class="comment">// 最大金额为6 1+5=6</span></span><br><span class="line">f(k) = 从前k个房屋中能偷窃到的最大数额。     输入:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]    输出:<span class="number">4</span></span><br><span class="line">Ak   =  第k个房屋的钱数。</span><br><span class="line">f(k) = max(f(k - <span class="number">2</span>)+Ak, f(k - <span class="number">1</span>))。</span><br><span class="line">考虑使用动态规划。</span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length ===<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> dp = [<span class="number">0</span>,nums[<span class="number">0</span>]]  <span class="comment">//只有一个房屋和两个房屋的金额</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span> ;i&lt;nums.length;i++)&#123;</span><br><span class="line">        dp[i]=<span class="built_in">Math</span>.max(dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>],dp(i<span class="number">-1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length]</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度、空间复杂度为O(n) </span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length ===<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span>  dp0=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span>  dp1=nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span> ;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> dp[<span class="number">2</span>]=<span class="built_in">Math</span>.max(dp[<span class="number">0</span>]+nums[i<span class="number">-1</span>],dp(<span class="number">1</span>))</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">空间复杂度可以优化 没有存任何的数组和矩阵 空间复杂度为O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">贪心算法是算法设计中的一种方法 </span><br><span class="line">期盼通过每个阶段的局部最优选择，从而达到全局的最优。</span><br><span class="line">结果并不一定是最优。  </span><br><span class="line"><span class="number">455</span> 分饼干</span><br><span class="line">对饼干数组和胃口数组升序排序。</span><br><span class="line">遍历饼干数组，找到能满足第一个孩子的饼干。</span><br><span class="line">然后继续遍历饼干数组，找到满足第二、三、.....、n个孩子的饼干。</span><br><span class="line"><span class="keyword">var</span> findContentChildren = <span class="function"><span class="keyword">function</span>(<span class="params">g, s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> sortFunc = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-b</span><br><span class="line">        &#125;</span><br><span class="line">        g.sort(sortFunc)<span class="comment">//78910   这一部分的时间复杂度是O(nlogn) + for循环O(n) 所以时间复杂度是O(nlogn)</span></span><br><span class="line">        s.sort(sortFunc)<span class="comment">//5678    虽然说有gs两个数组但是都是已有的数组，中间没有临时存储任何线性增长的变量包括链表矩阵O(1)</span></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">        s.forEach(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;=g[i])&#123;</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">122</span> 买卖股票的最佳时机</span><br><span class="line">前提:上帝视角，知道未来的价格。</span><br><span class="line">局部最优:见好就收，见差就不动，不做任何长远打算。</span><br><span class="line">输入:[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]   输出:<span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">            profit += prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度是O(n) 空间复杂度为O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20.</span>有效的括号</span><br><span class="line">用栈来做:</span><br><span class="line"><span class="number">1.</span>新建一个栈</span><br><span class="line"><span class="number">2.</span>扫描字符串，遇左括号入栈，遇到和栈顶的左括号匹配的右括号就出栈，类型不匹配就直接判定不合法 （[&#125;）</span><br><span class="line"><span class="number">3.</span>最后判断栈是否为空，不为空也判定不合法</span><br><span class="line"><span class="keyword">if</span>(s.length%<span class="number">2</span>!==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">const</span> stack = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span> ;i&lt;s.length;i++&#125;&#123;</span><br><span class="line">    <span class="keyword">const</span> c = s[i]</span><br><span class="line">    <span class="keyword">if</span>(c===<span class="string">'('</span>||c===<span class="string">'['</span>||c===<span class="string">'&#123;'</span>))&#123;</span><br><span class="line">    	stack.push(c)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> top = stack[stack.length<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(top===<span class="string">'('</span>&amp;&amp;c===<span class="string">')'</span>)||</span><br><span class="line">        (top===<span class="string">'&#123;'</span>&amp;&amp;c===<span class="string">'&#125;'</span>)||</span><br><span class="line">        (top===<span class="string">'['</span>&amp;&amp;c===<span class="string">']'</span>)&#123;</span><br><span class="line">             stack.pop()     </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> stack.length===<span class="number">0</span>  <span class="comment">//判断最后栈是否为空 为空就为true 因为是栈</span></span><br><span class="line"></span><br><span class="line">用字典来做:</span><br><span class="line"><span class="keyword">if</span>(s.length%<span class="number">2</span>!==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">const</span> stack = []</span><br><span class="line"><span class="keyword">const</span> map  = <span class="keyword">new</span> <span class="built_in">Map</span></span><br><span class="line">map.set(<span class="string">'('</span>,<span class="string">')'</span>)</span><br><span class="line">map.set(<span class="string">'['</span>,<span class="string">']'</span>)</span><br><span class="line">map.set(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span> ;i&lt;s.length;i++&#125;&#123;</span><br><span class="line">    <span class="keyword">const</span> c = s[i]</span><br><span class="line">    <span class="keyword">if</span>(map.has(c))&#123;</span><br><span class="line">    	stack.push(c)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> top = stack[stack.length<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(map.get(top)===c)&#123;</span><br><span class="line">             stack.pop()     </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">933.</span>最近的请求次数（队列先进先出）</span><br><span class="line">    有新请求就入队，<span class="number">3000</span>ms前发出的请求出队。</span><br><span class="line">    队列的长度就是最近请求次数。</span><br><span class="line"> 在构造函数内将队列挂载<span class="keyword">this</span>上</span><br><span class="line"> 										输入:inputs = [[],[<span class="number">1</span>],[<span class="number">100</span>],[<span class="number">3001</span>],[<span class="number">3002</span>]]</span><br><span class="line">										输出:[<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">var</span> RecentCounter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.q = []  <span class="comment">//将队列挂载在构造函数自身</span></span><br><span class="line">  &#125;</span><br><span class="line">  RecentCount.prototype.ping = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;  <span class="comment">//每一次都会调用ping方法</span></span><br><span class="line">   	<span class="keyword">this</span>.q.push(t);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.q[<span class="number">0</span>]&lt;t<span class="number">-3000</span>)&#123;  时间复杂度，空间复杂度都是O(n)  队头是<span class="number">1</span>        </span><br><span class="line">    	<span class="keyword">this</span>.q.shift()<span class="comment">//踢掉队头</span></span><br><span class="line">    &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.q.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">237.</span>删除链表中的节点</span><br><span class="line"><span class="number">1</span>、将被删节点的值改为下个节点的值。node.val = node.next.val  <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">8</span>   =&gt;   <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">9</span>-&gt;<span class="number">9</span>-&gt;<span class="number">8</span></span><br><span class="line"><span class="number">2</span>、删除下个节点。 node.next = node.next.next  </span><br><span class="line"></span><br><span class="line"><span class="number">206.</span>反转链表 </span><br><span class="line"><span class="number">1</span>、反转两个节点只需要把n+<span class="number">1</span>个节点的next指针指向n</span><br><span class="line"><span class="number">2</span>、反转多个节点：双指针遍历链表，重复上述操作</span><br><span class="line">	输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">	输出：<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">	双指针一前一后遍历链表</span><br><span class="line">    反转双指针</span><br><span class="line">    <span class="keyword">let</span> p1=head;</span><br><span class="line">	<span class="keyword">let</span> p2=NULL;</span><br><span class="line">	<span class="keyword">while</span>(p1)&#123;</span><br><span class="line">       <span class="comment">//后写</span></span><br><span class="line">        <span class="keyword">const</span> temp = p1.next</span><br><span class="line">        p1.next = p2</span><br><span class="line">        <span class="comment">//先写双指针的遍历</span></span><br><span class="line">        p2=p1</span><br><span class="line">        p1=temp</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> p2 <span class="comment">//最后p1指向NULL p2才是那个头节点</span></span><br><span class="line"><span class="number">2.</span>两数相加 （遍历链表）</span><br><span class="line">	<span class="keyword">var</span> addCounts = <span class="function"><span class="keyword">function</span>(<span class="params">l1,l2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>) <span class="comment">//创建一个新的链表节点</span></span><br><span class="line">        <span class="keyword">let</span> p1 = l1</span><br><span class="line">        <span class="keyword">let</span> p2 = l2</span><br><span class="line">        <span class="keyword">let</span> p3 = l3</span><br><span class="line">        <span class="keyword">let</span> carry=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(p1||p2)&#123;</span><br><span class="line">            <span class="keyword">const</span> v1 = p1?p1.val:<span class="number">0</span></span><br><span class="line">            <span class="keyword">const</span> v2 = p2?p2.val:<span class="number">0</span></span><br><span class="line">            <span class="keyword">const</span> v3 = v1+v2+carry</span><br><span class="line">            carry = <span class="built_in">Math</span>.floor(v3/<span class="number">10</span>)</span><br><span class="line">            p3.next = <span class="keyword">new</span> List(v3%<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span>(p1) p1=p1.next</span><br><span class="line">            <span class="keyword">if</span>(p2) p2=p2.next</span><br><span class="line">            p3=p3.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            p3.next = <span class="keyword">new</span> ListNode(carry)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3.next</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">83.</span>删除排序链表中的重复元素    </span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> p = head</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;p.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val===p.next.val)&#123;</span><br><span class="line">            p.next = p.next.next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p=p.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="number">141.</span>环形链表</span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow = head</span><br><span class="line">    <span class="keyword">let</span> fast = head</span><br><span class="line">    <span class="keyword">while</span>(slow&amp;&amp;fast&amp;&amp;fast.next)&#123;</span><br><span class="line">        slow =slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span>(slow === fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">349.</span>两个数组的交集</span><br><span class="line">用集合来做:</span><br><span class="line">	解题思路:求交集且无序唯一。nums1=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],nums2=[<span class="number">2</span>,<span class="number">2</span>] 输出[<span class="number">2</span>]</span><br><span class="line">	<span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>(nums1)</span><br><span class="line">    <span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(nums2)</span><br><span class="line">    <span class="comment">//return [...set1].filter(item=&gt;set2.has(item)) </span></span><br><span class="line">    <span class="keyword">return</span> [...set1].filter(<span class="function"><span class="params">item</span>=&gt;</span>nums2.includes(item)) <span class="comment">//时间复杂度filter循环为O(n)，n为set1的长度，has和includes方法是O(m),m为num2的长度因此嵌套时间复杂度为为O(n*m)  空间复杂度就是一个去重后的数组，因为位O(m)</span></span><br><span class="line"></span><br><span class="line">用字典来做:</span><br><span class="line">	<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    nums1.forEach(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">        map.set(n,<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    nums2.forEach(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(n))&#123;</span><br><span class="line">            res.push(n)  </span><br><span class="line">            map.delete(n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment">//时间复杂度为O(m+n) =&gt;遍历没有嵌套一个为nums1的长度，一个为nums2的长度</span></span><br><span class="line">	<span class="comment">//算法的输入输出都是数组，但是不能计算在内，空间复杂度指的是临时变量的内存消耗，中间的临时变量时一个字典，字典虽然不是数组也不是矩阵，但是存储的值也可能是线性增长的，所以说这个算法的空间复杂度是O(m)</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>两数之和</span><br><span class="line">	<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> n = nums[i]  </span><br><span class="line">        <span class="keyword">const</span> n2 = target-n</span><br><span class="line">        <span class="keyword">if</span>(map.has(n2))&#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(n2),i]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(n,i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//时间和空间复杂度都为O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>无重复字符的最长子串</span><br><span class="line">	<span class="number">1</span>、先找出所有的不包含重复字符的子串。</span><br><span class="line">	<span class="number">2</span>、找出长度最大那个子串，返回其长度即可。</span><br><span class="line">    用双指针维护一个滑动窗口，用来剪切子串。</span><br><span class="line">	不断移动右指针，遇到重复字符，就把左指针移动到重复字符的下一位。</span><br><span class="line">    过程中，记录所有窗口的长度，并返回最大值<span class="number">0</span> </span><br><span class="line">	<span class="keyword">const</span> l = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">	<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> r= <span class="number">0</span>,r&lt;s.length,r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(s[r])&amp;&amp;map.get(s[r]&gt;=l))&#123;  <span class="comment">//妙呀，因为字典里已经有a了</span></span><br><span class="line">            l=map.get(s[r])+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">Math</span>.max(res,r-l+<span class="number">1</span>)</span><br><span class="line">        map.set(s[r],r)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"><span class="comment">//abbcdea  </span></span><br><span class="line">时间复杂度为O(n),空间复杂度为O(m),m为字符串中不重复的字符</span><br><span class="line"></span><br><span class="line"><span class="number">76</span>、最小覆盖子串</span><br><span class="line">	先找出所有的包含T的子串。</span><br><span class="line">	找出长度最小那个子串，返回即可。</span><br><span class="line">    用双指针维护一个滑动窗口。</span><br><span class="line">    移动右指针，找到包含T的子串，移动左指针，尽量减少包含T的子串的长度。</span><br><span class="line">    循环找到最小子串</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> t)&#123;</span><br><span class="line">        need.set(c,need.has(c)?need.get(c)+<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res= <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> needType=need.size </span><br><span class="line">    <span class="keyword">while</span>(r&lt;s.length)&#123;</span><br><span class="line">        c1 = s[r]</span><br><span class="line">        <span class="keyword">if</span>(need.has(c1))&#123;</span><br><span class="line">            need.set(c1,need.get(c1)<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(need.get(c1)===<span class="number">0</span>) needType-=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(needType===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> newStr = s.substring(l,r+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(!res||newStr.length&lt;res.length) res = newStr</span><br><span class="line">            c2=s[l]</span><br><span class="line">            <span class="keyword">if</span>(need.has(c2))&#123;</span><br><span class="line">                need.set(c2,need.get(c2)+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span>(need.get(c2)===<span class="number">1</span>) needType+=<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            l+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        r+=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">104.</span>二叉树的最大深度</span><br><span class="line">解题思路</span><br><span class="line"><span class="number">1</span>、最大深度，考虑使用深度优先遍历。</span><br><span class="line"><span class="number">2</span>、深度优先遍历过程中，记录每个节点所在的层级，找出最大的层级即可。</span><br><span class="line"><span class="number">1.</span>一个变量，记录最大深度。</span><br><span class="line"><span class="number">2.</span>优先遍历整棵树，并记录每个节点的层级，同时不断刷新最大深度这个变量。</span><br><span class="line"><span class="number">3.</span>遍历结束返回最大深度这个变量</span><br><span class="line">先验证深度优先遍历的结果有没有问题</span><br><span class="line">	<span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">     		<span class="keyword">if</span>(!n)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">            log(n.val)</span><br><span class="line">            dfs(n.left)</span><br><span class="line">            dfs(n.right)</span><br><span class="line">        &#125; </span><br><span class="line">        dfs(root)</span><br><span class="line">     &#125;</span><br><span class="line">    -------</span><br><span class="line">	<span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n,l</span>)=&gt;</span>&#123;</span><br><span class="line">     		<span class="keyword">if</span>(!n)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">            log(n.val,l)=&gt;替换res = <span class="built_in">Math</span>.max(res,l);</span><br><span class="line">            dfs(n.left,l+<span class="number">1</span>)</span><br><span class="line">            dfs(n.right,l+<span class="number">1</span>)</span><br><span class="line">        &#125; </span><br><span class="line">        dfs(root,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">     &#125;</span><br><span class="line">这样执行用时很高这是因为它每次都去遍历每个节点的时候都去刷新res</span><br><span class="line">没必要刷新，只要是叶子节点再去刷新就可以了</span><br><span class="line"><span class="keyword">if</span>(!n.left&amp;&amp;!n.right)&#123;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res,l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">111.</span>二叉树的最小深度</span><br><span class="line"><span class="number">1</span>、求最小深度，考虑使用广度优先遍历。</span><br><span class="line"><span class="number">2</span>、在广度优先遍历过程中，遇到叶子节点,停止遍历，返回节点层级。</span><br><span class="line"><span class="number">1.</span>广度优先遍历整棵树，并记录每个节点的层级。</span><br><span class="line"><span class="number">2.</span>遇到叶子节点，返回节点层级，停止遍历。</span><br><span class="line">	<span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">const</span> q = [root]</span><br><span class="line">        <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> n = q.shift()</span><br><span class="line">            log(n.val)</span><br><span class="line">            <span class="keyword">if</span>(n.left)  q.push(n.left)</span><br><span class="line">            <span class="keyword">if</span>(n.right) q.push(n.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --------------</span><br><span class="line">    	<span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">const</span> q = [[root,<span class="number">1</span>]]<span class="comment">//添加层级</span></span><br><span class="line">        <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> [n,l] = q.shift()</span><br><span class="line">            log(n.val,l)=&gt;</span><br><span class="line">            <span class="keyword">if</span>(!n.left&amp;&amp;!n.right)&#123;</span><br><span class="line">                <span class="keyword">return</span> l</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n.left)  q.push([n.left,l+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span>(n.right) q.push([n.right,l+<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="number">102.</span>二叉树的层序遍历</span><br><span class="line"><span class="number">1</span>、层序遍历顺序就是广度优先遍历。</span><br><span class="line"><span class="number">2</span>、不过在遍历时候需要记录当前节点所处的层级，方便将其添加到不同的数组中。</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span> []</span><br><span class="line">	<span class="keyword">const</span> q = [[root,<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">        <span class="keyword">const</span> [n,l] = q.shift()</span><br><span class="line">        log(n,val)=&gt;</span><br><span class="line">        <span class="keyword">if</span>(!res[l])&#123;</span><br><span class="line">            res.push([n.val]) <span class="comment">//先推第二层的左节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[l].push(n.val) <span class="comment">//再推第二层的右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n.left)  q.push([n,left,l+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span>(n.right) q.push([n.right,l+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span> []</span><br><span class="line">	<span class="keyword">const</span> q = [root]</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> len =q.length</span><br><span class="line">        res.push([])</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">          <span class="keyword">const</span> n = q.shift()</span><br><span class="line">          res[res.length<span class="number">-1</span>].push(n.val)</span><br><span class="line">          <span class="keyword">if</span>(n.left)  q.push(n.left)</span><br><span class="line">          <span class="keyword">if</span>(n.right) q.push(n.right) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">112</span> 路径之和</span><br><span class="line"><span class="number">215.</span>数组中第K个最大元素(最小堆)</span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h  = <span class="keyword">new</span> MinHead()</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">        h.insert(n)</span><br><span class="line">        <span class="keyword">if</span>(h.size()&gt;k)&#123;</span><br><span class="line">            h.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> h.peek()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">347.</span>前K个高频元素</span><br></pre></td></tr></table></figure>
<p><strong>2.两数相加</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112211440438.png" alt="image-20211221143956591"></p>
<p><strong>83.删除排序链表中的重复元素</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112211511909.png" alt="image-20211221151123774"></p>
<p><strong>141.环形链表</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202112211506407.png" alt="image-20211221150620235"></p>
<blockquote>
<p>算法里没有额外的线性增长的数据结构，没有数组，没有矩阵，没有链表 空间复杂度为O（1）</p>
</blockquote>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instanceof</span>的原理，并用代码实现</span><br><span class="line">	知识点:如果A沿着原型链能找到 B.prototype，那么A <span class="keyword">instanceof</span> B 为<span class="literal">true</span>。</span><br><span class="line">    解法:遍历A的原型链，如果找到B.prototype，返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">instanceof</span>(A,B)&#123;</span><br><span class="line">    <span class="keyword">const</span> p = A</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p===B.prototype)&#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">    &#125;</span><br><span class="line">    	 p=p.__prop__</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用链表指针获取<span class="built_in">JSON</span>的节点值</span><br><span class="line"><span class="keyword">const</span> json=&#123;</span><br><span class="line">    a:&#123;<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">    d:&#123;<span class="attr">e</span>:<span class="number">2</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> path = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = json;</span><br><span class="line">path.forEach(<span class="function"><span class="params">k</span>=&gt;</span>&#123; <span class="comment">//遍历abc </span></span><br><span class="line">    p=p[k] <span class="comment">//p=1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">前端与树的内容:</span><br><span class="line">遍历<span class="built_in">JSON</span>的所有节点值</span><br><span class="line"><span class="keyword">const</span> json=&#123;</span><br><span class="line">    a:&#123;<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">    d:[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dfs=<span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">    log(n,path)</span><br><span class="line">    <span class="comment">//通过Object.keys(n)就可以拿到root的孩子节点</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(n).forEach(<span class="function"><span class="params">k</span>=&gt;</span>&#123;</span><br><span class="line">        dfs(n[k],path,path.concat(k))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">dfs(json,[])</span><br><span class="line"></span><br><span class="line">渲染Antd的树组件</span><br><span class="line"><span class="keyword">const</span> &#123;Tree&#125; = antd</span><br><span class="line"><span class="keyword">const</span> &#123;TreeNode&#125; = Tree</span><br><span class="line"><span class="keyword">const</span> json=[</span><br><span class="line">    &#123;</span><br><span class="line">        title:<span class="string">'一'</span></span><br><span class="line">        key:<span class="string">'1'</span></span><br><span class="line">        children:[&#123;<span class="attr">title</span>:<span class="string">'三'</span>，key=<span class="string">'3'</span>,<span class="attr">children</span>:[]&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">     &#123;</span><br><span class="line">        title:<span class="string">'二'</span></span><br><span class="line">        key:<span class="string">'2'</span></span><br><span class="line">        children:[&#123;<span class="attr">title</span>:<span class="string">'四'</span>，key=<span class="string">'4'</span>,<span class="attr">children</span>:[]&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    dfs=<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        	&lt;TreeNode title =&#123;n.title&#125; key=&#123;n.key&#125;&gt;</span><br><span class="line">    			&#123;n.children.map(<span class="keyword">this</span>.dfs)&#125;</span><br><span class="line">        	&lt;<span class="regexp">/TreeNode&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    render()&#123;</span></span><br><span class="line"><span class="regexp">        return &lt;Tree&gt; &#123;json.map(this.dfs)&#125;&lt;/</span>Tree&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">RaeactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">**树**</span><br><span class="line">   	<span class="keyword">const</span> dfs = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">        log(root.val)</span><br><span class="line">        root.children.forEach(dfs);  <span class="comment">// 输出abdec</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(tree)    </span><br><span class="line">   </span><br><span class="line">**图**</span><br><span class="line">    <span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'graph'</span>) <span class="comment">//graph就是下面的箭头图</span></span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">        log(n)</span><br><span class="line">        visited.add(n)<span class="comment">//集合add</span></span><br><span class="line">        graph[n].forEach(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.has(c))&#123;</span><br><span class="line">                dfs(c)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">**树**</span><br><span class="line">    	<span class="keyword">const</span> bfs = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> q = [root]</span><br><span class="line">            <span class="keyword">while</span>(q.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">const</span> n = q.shift()<span class="comment">//队头出队并访问</span></span><br><span class="line">                log(n.val)         <span class="comment">//abcde</span></span><br><span class="line">                n.children.forEach(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">                    q.push(child)   </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    bfs(tree)</span><br><span class="line">**图**</span><br><span class="line">        <span class="keyword">const</span> q = [<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        visited.add(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span>(q.length)&#123;</span><br><span class="line">            n = q.shift()</span><br><span class="line">            graph[n].forEach(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited.has(c))&#123;</span><br><span class="line">                    q.push(c)</span><br><span class="line">                    visited.add(n)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/12/05/Git%E6%95%99%E7%A8%8B%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/05/Git%E6%95%99%E7%A8%8B%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/" class="post-title-link" itemprop="url">Git教程</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-05T00:00:00+08:00">2021-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/05/Git%E6%95%99%E7%A8%8B%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/05/Git%E6%95%99%E7%A8%8B%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><blockquote>
<p>什么是版本控制</p>
</blockquote>
<p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<blockquote>
<p>Github 和 Git区别。</p>
</blockquote>
<p>Git是版本控制系统，Github是在线的基于Git的代码托管服务。GitHub是2008年由Ruby on Rails编写而成。 GitHub同时提供付费账户和免费账户。 这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。 为什么现在Github这么火，以至于世界顶级公司和项目的源码很多都托管在Github上——颜值高！ 现在这世代还是得看看颜值的。 你说Sourceforge等代码托管网站也年岁很久了，为什么没有Github那么火呢？ 关键是Github长得好看（你长这么好看，说什么都是对的）。 Linus Torvalds的Github页面,打开看看吧，Linux的源码就在上面，随时在更新！</p>
<blockquote>
<p>常见的版本控制工具</p>
</blockquote>
<ul>
<li>Git</li>
<li>SVN</li>
<li>CVS</li>
<li>VSS</li>
<li><p>TFS<br>版本控制的产品非常多，现在影响力最大且使用最广泛的是Git与SVN</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/05/Git%E6%95%99%E7%A8%8B%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/11/30/react%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/30/react%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">React 简书实战</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-30T00:00:00+08:00">2021-11-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/30/react%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/30/react%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="react简书实战"><a href="#react简书实战" class="headerlink" title="react简书实战"></a>react简书实战</h1><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><p><strong>实战环节</strong></p>
<blockquote>
<p>环境的搭建-&gt;Header组件的编写-&gt;首页的编写-&gt;详情页的编写-&gt;登陆相关业务逻辑的处理-&gt;项目开发结束上线</p>
</blockquote>
<p><strong>核心技术点</strong></p>
<ol>
<li><p>creat-react-app脚手架工具进行项目的搭建</p>
</li>
<li><p>组件化思维进行项目开发</p>
</li>
<li><p>深入学习jsx模板语法</p>
</li>
<li><p>项目的开发调试</p>
</li>
<li><p>虚拟DOM和diff算法，生命周期</p>
</li>
<li><p>项目react-transition-group第三方的模块实现复杂的动画效果</p>
</li>
<li><p>Redux  Antd UI组件 容器组件 无状态组件等等内容</p>
</li>
<li><p>redux使用之中的redux中间键 比如redux-thunk、redux-saga这些新的技术</p>
</li>
<li><p>项目样式布局采用最新的Styled-components技术来实现CSS样式的编码，避免组件之间样式的互相影响</p>
</li>
<li><p>在进行redux之中数据管理的时候，使用react推出的数据框架 Immutable.js，这个库有效的避免我们对数据的误操作</p>
<p>如果使用这个库还会涉及redux-immutable这个redux的中间键</p>
</li>
<li><p>使用axios这个工具发送ajax请求</p>
</li>
</ol>
<p><strong>react基础知识的巩固</strong></p>
<blockquote>
<p>React开发环境的准备：引入.js文件来使用React-&gt;通过脚手架工具来编码-&gt;Create-react-app官网提供的脚手架</p>
</blockquote>
<ul>
<li><p>创建脚手架： </p>
<ol>
<li><p>检查node -v的版本 和 npm -v的版本 </p>
</li>
<li><p>输入命令<code>npm install -g create-react-app</code></p>
</li>
<li><p>输入命令<code>create-react-app 文件夹名</code>   </p>
</li>
<li><p>创建之后切换到创建的文件夹 <code>cd 文件名夹</code></p>
</li>
<li><p>运行yarn start即可显示 React 主界面 </p>
</li>
</ol>
</li>
<li><p>三个文件：</p>
<p>   （1）public下的index.html文件 ：页面上显示的html的内容</p>
<p>​      （2）src下的index.js： 整个react项目的入口文件 会引入App文件</p>
<p>​      （3）src下的App.js ： 负责页面上显示Hello Word的内容</p>
</li>
</ul>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><blockquote>
<p>React中的组件</p>
</blockquote>
<p>​    定义组件：定义的那个类继承<code>React.Component</code></p>
<ul>
<li><p>只要是jsx语法想在react之中正常的运行，就要引入react   例如 组件<APP/>（组件标签都需要大写开头）  render()下的<div> （小写开头的就是h5标签）这些都属于jsx语法</p>
</li>
<li><p><code>index.js ``文件中通过ReactDOM将APP这个组件显示在``id=root</code>这个标签下面</p>
</li>
<li><p><code>render</code>返回的必须是在一个大的元素之中，但是有时候又不想让这个div显示就可以用<Fragmrnt></Fragmrnt>的占位符来替代最外层的div，不会渲染为任何标签</p>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input </span><br><span class="line">	value=&#123;<span class="keyword">this</span>.state.inputvalue&#125; --inputvalue就是输入框的值</span><br><span class="line">	onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; --通过调用该函数来改变改值</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">handleInputChange=(e)=&gt;&#123;</span><br><span class="line">   <span class="keyword">this</span>.state.inputValue = e.<span class="keyword">target</span>.vaue</span><br><span class="line">   console.log(e.<span class="keyword">target</span>.value)  --e.<span class="keyword">target</span>是Input框返回的DOM节点，e.<span class="keyword">target</span>.value返回的就是value值</span><br><span class="line">   console.log(<span class="keyword">this</span>)</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">   		inputValue:e.<span class="keyword">target</span>.value</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">/*如果需要实现改变inputvalue的值就在handleInputChange函数里写<span class="keyword">this</span>.state.inputValue = e.<span class="keyword">target</span>.vaue</span><br><span class="line">如果handleInputChange这个函数没有使用箭头函数,此时的<span class="keyword">this</span>为undefined，可以使用ES6的语法将<span class="keyword">this</span>的指向指向为Todolist组件</span><br><span class="line">onChange=&#123;<span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>)&#125;即可。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>改变state里的数据不能像上述引用的方式去改变，必须调用setState的方法去改变state里的数据。</p>
</li>
<li><p>由于react中state是不允许做任何的改变的immutable的特性，因此我们在做list操作的时候需要先做一个拷贝，对拷贝的数据进行处理 如果改变之后做性能优化的时候就会出现问题。</p>
</li>
</ul>
<blockquote>
<p>JSX细节语法补充</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>两种注释方法:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注释内容 </span></span><br><span class="line">    &#125;</span><br><span class="line">    或者</span><br><span class="line">    &#123;<span class="comment">/*注释内容*/</span>&#125;</span><br><span class="line"><span class="number">2.</span>为了防止某些标签的内容不被转义  也就是在输入框输入&lt;h1&gt;啦啦啦&lt;h1/&gt;点击提交的时候是显示啦啦啦</span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handledelete&#125;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:item&#125;&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="number">3.</span>在输入框前添加label标签的时候 点击babel标签的内容光标会自动聚焦到输入框上</span><br><span class="line">    &lt;label htmlFor=<span class="string">'insertArea'</span>&gt;输入内容&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">	&lt;input id='insertArea' className='input' value=&#123;inputvalue&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新版的react  setState返回的不是一个对象了 要把对象替换成函数</span><br><span class="line">之前: handlechange=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">      &#123;<span class="attr">inputvalue</span>:e.target.value&#125;</span><br><span class="line">    )&#125; </span><br><span class="line"></span><br><span class="line">现在:  <span class="keyword">const</span> value = e.target.value  <span class="comment">//对value值做保存 </span></span><br><span class="line">	  <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span>=&gt;</span>(&#123;</span><br><span class="line">          inputvalue:value&#125;)) <span class="comment">//写成函数就会变成异步的setState 如果直接写e.target.value就会有问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>React优点</strong></p>
<ol>
<li>声明式开发：使得我们能减少大量DOM操作代码量</li>
<li>可以与其他框架并存</li>
<li>组件化</li>
<li>单向数据流</li>
<li>视图层框架</li>
<li>函数式编程  好处：用react写出来的项目更容易实现前端自动化测试</li>
</ol>
<p><strong>思考</strong></p>
<blockquote>
<p>单向数据流：父组件可以向子组件传值，但是子组件不能改变这个值，只能单向进行传递，不能反过来修改。这就说明为什么在修改item项目的时候，为什么不向子组件传递一个list，而要传递index与item了。</p>
<p>再或者说如果一个父组件有很多个子组件且子组件都共用list，如果将list传给某一个子组件且在该子组件进行修改，会导致其余四个组件中list也发生变化，这样页面出现bug的时候，就不知如何去定位这个bug，对代码的调试是很不方便的，因此要有单向数据流的概念。</p>
<p>如果真的想修改：首先父组件传递给子组件一个方法，在子组件去调用父组件传的这个方法，然后去做删除。</p>
<p>React是一个视图层的框架:react并不是什么问题都解决，只帮助你解决数据和页面渲染上的一些东西，至于组件之间怎么传值（就如1给2传递的话就不能按一层一层传了），并不负责，交给其他组件来做，做到大型项目时，react不够用，只能借助它去搭建视图，做组件传值的时候还要借助redux等的数据层的框架来做额外的支撑。</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111171547264.png" alt="image-20211117154738062"></p>
<p><strong>巩固知识</strong></p>
<ul>
<li>父组件给子组件传值的时候，子组件要对传来的值做类型的限制。如果对传来的值做了isRequired的限制，如果不传就会报错。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">限制类型有两种放置方法:</span><br><span class="line">    <span class="number">1.</span>TodoItem.propTypes=&#123;</span><br><span class="line">           item:PropTypes.string,</span><br><span class="line">           dele:PropTypes.func,</span><br><span class="line">           index:PropTypes.number</span><br><span class="line">       &#125; --放置在定义完组件的下方（最下方）</span><br><span class="line">    <span class="number">2.</span>TodoItem.propTypes=&#123;</span><br><span class="line">           item:PropTypes.string,</span><br><span class="line">           dele:PropTypes.func,</span><br><span class="line">           index:PropTypes.number</span><br><span class="line">       &#125; --放置在render的上方</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当组件的state和props发生改变的时候，render函数就会重新执行。</p>
</li>
<li><p>当父组件的render函数被运行时，它的子组件的render都将重新运行一次。</p>
</li>
</ul>
<p><strong>虚拟DOM</strong>(本质上就是一个js对象，之所以能提高性能，因为js去比较js对象不怎么耗性能，去比较真实的DOM很耗性能)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">真实DOM和虚拟DOM性能的差异:</span><br><span class="line">    使用真实DOM</span><br><span class="line">    <span class="number">1.</span> state数据 **初始数据state</span><br><span class="line">    <span class="number">2.</span> JSX 模版  **对应render里的jsx代码</span><br><span class="line">    <span class="number">3</span>．数据+模版结合，生成真实的DOM，来显示</span><br><span class="line">    <span class="number">4.</span> state 发生改变</span><br><span class="line">    <span class="number">5</span>．数据＋模版结合，生成真实的DOM，并不直接替换原始的DOM</span><br><span class="line">    <span class="number">6</span>．新的DOM 和原始的DOM做比对，找差异</span><br><span class="line">    <span class="number">7.</span>找出input框发生了变化</span><br><span class="line">    <span class="number">8.</span>只用新的DOM中的input元素，替换掉老的DOM中的input元素  </span><br><span class="line">        **相比全部替换原始DOM性能提升 </span><br><span class="line">		**但是还是消耗了一部分性能:新的DOM和原始DOM做比对的性能 性能提升也不是很明显</span><br><span class="line"></span><br><span class="line">    使用虚拟DOM:</span><br><span class="line">    <span class="number">1.</span> state数据</span><br><span class="line">    <span class="number">2.</span> JSX 模版</span><br><span class="line">    <span class="number">3.</span> 数据+模版结合,生成真实的DOM，来显示</span><br><span class="line">    假设真实DOM为:<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'abc'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="number">4</span>．生成虚拟DOM(虚拟DOM就是一个JS对象，用它来描述真实DOM)(相比上面第四步没有生成虚拟DOM 实看是损耗了性能)</span><br><span class="line">    [ <span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'abc'</span>&#125;, [ <span class="string">'span'</span>,&#123;&#125;,<span class="string">'hello world '</span>]]  <span class="comment">//标签名 标签属性  标签内容  **JS对象 也就是虚拟DOM</span></span><br><span class="line">    <span class="number">5.</span> state 发生变化</span><br><span class="line">    <span class="number">6.</span> 数据+模版生成新的虚拟DOM(极大的提升了性能相比创建真实DOM，js对象创建的过程性能是极低的)</span><br><span class="line">    [ <span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'abc'</span>&#125;,[ <span class="string">'span'</span>, &#123;&#125;,<span class="string">'bye bye'</span> ]]</span><br><span class="line">    <span class="number">7</span>．比较原始虚拟DOM和新的虚拟DOM的区别,找到区别是span中内容(极大的提升性能)</span><br><span class="line">        **比对的是原始的js对象和新的js对象两个js对象的比较是极不损耗性能的。</span><br><span class="line">    <span class="number">8</span>．直接操作DOM，改变span中的内容</span><br></pre></td></tr></table></figure>
<p><strong>深入了解虚拟DOM</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">实际的流程是:</span><br><span class="line">    <span class="number">1.</span> state数据</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span> JSX 模版（类似于div）</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*JSX -&gt; createElement方法 -&gt; JS对象 -&gt; 真实的DOM</span></span><br><span class="line"><span class="comment">      return &lt;div&gt;item&lt;div&gt; =&gt;等价为</span></span><br><span class="line"><span class="comment">      return React.createElement('div',&#123;&#125;,'item')</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">3</span>．数据 + 模板 生成虚拟DOM(虚拟DOM就是一个JS对象，用它来描述真实DOM)(损耗了性能)</span><br><span class="line">    [ <span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'abc'</span>&#125;, [ <span class="string">'span'</span>,&#123;&#125;,<span class="string">'hello world '</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="number">4.</span> 用虚拟DOM的结构生成真实的DOM，来显示</span><br><span class="line">    &lt;div id=<span class="string">'abc'</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    5. state 发生变化</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    6. 数据+模版生成新的虚拟DOM(极大的提升了性能)</span></span><br><span class="line"><span class="regexp">    [ 'div', &#123;id: 'abc'&#125;,[ 'span', &#123;&#125;,'bye bye' ]]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    7．比较原始虚拟DOM和新的虚拟DOM的区别,找到区别是span中内容(极大的提升性能)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    8．直接操作DOM，改变span中的内容</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">虚拟DOM的好处: 1.性能提升:因为生成真实DOM要耗费很大的性能</span></span><br><span class="line"><span class="regexp">			 2.它使得跨端应用得以实现</span></span><br><span class="line"><span class="regexp">             </span></span><br><span class="line"><span class="regexp">第2点好处的底层原理:没有虚拟DOM React是无法写原生应用的，根本无法在原生（React Native）的应用里被使用。</span></span><br><span class="line"><span class="regexp">例如:没有虚拟DOM，流程就是准备好state数据和模板之后就会渲染DOM，渲染DOM在浏览器是没有问题的，可是在移动端的原生应用里，比如安卓或者ios机器上的代码是不存在DOM这个概念的，所以没有虚拟DOM，在原生的应用里根本无法被使用，所以代码只能运行在浏览器里面，但是有虚拟DOM就不一样了，代码首先会被转化为虚拟DOM（是个js对象）js对象在浏览器可以被识别，在原生的应用里也可以被识别。</span></span><br><span class="line"><span class="regexp">换句话说:虚拟DOM生成好了在浏览器下面，可以将虚拟DOM变成真实DOM，浏览器下面会显示出真实的页面。假设在原生应用里，虚拟DOM生成之后可以不生成真实DOM，而让虚拟DOM生成些原生的组件，这样的话同样的代码包括state，jsx的代码都可以被复用，原生的应用里面可以把对应的页面展示出来。因为生成的虚拟DOM，在哪里都可以运行，只需要在网页上将虚拟DOM转化为真实DOM，这样的话网页就可以跑起来。这使得React既能开发网页应用，还可以开发原生应用</span></span><br></pre></td></tr></table></figure>
<p><strong>虚拟DOM中的Diff算法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">比较原始虚拟DOM和新的虚拟DOM的区别,找到区别是span中内容(极大的提升性能)</span><br><span class="line">当数据发生改变的时候（state和props的改变，其实props的改变实际上也是父组件的state发生改变），虚拟DOM和真实DOM才会发生比对。</span><br><span class="line">归根到底，当你调用setState的时候，数据才发生改变，然后虚拟DOM才发生比对。（setState是异步的，实际上是为了提升react底层的性能，原因:假设连续调用三次setState，变更三组数据，React会把三次setState合并成一次，只是做了一次虚拟DOM的比对，然后去更新一次DOM，可以额外减去那两次DOM比对带来的性能上的耗费）--性能优化</span><br><span class="line">Diff算法就是两个虚拟DOM比对的算法，React采用的是同层的虚拟DOM比对的算法。左边的为虚拟DOM，当数据改变的时候会生成新的虚拟DOM。同层比对，如果一层不满足要求，之后的也不比对了，后面的就直接废弃掉，整个就替换掉，这样会提升性能。（直观上如果第一层不一样后面都一样，导致后面一样的节点没办法复用，性能很低，怎么会提升性能。实际上是因为同层比对的算法很简单，算法简单带来的是比对的速度会非常快。虽然可能会导致DOM重新渲染上的浪费，但是它大大的减少了两个虚拟DOM之间比对的算法上性能的消耗。） </span><br><span class="line">key值要保持相对稳定，在项目中能不用index做key值就不用。</span><br><span class="line">同层比对和key值比对这些比对的方式都是Diff算法的一部分。--性能优化</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111302200890.png" alt="image-20211130220031980"></p>
<p><strong>ref</strong></p>
<blockquote>
<p>如果ref和setState一起使用的时候，要注意setState是异步函数，不会立马执行。有时候会使得无法正确输出页面DOM的真实情况</p>
<p>为了避免这种情况，setState还有第二个参数，它是一个回调函数，执行的时机是在等异步的完全结束了再执行。</p>
</blockquote>
<p><strong>生命周期函数</strong></p>
<blockquote>
<p>生命周期函数指在某一个时刻组件会自动调用的函数（当state和pros变化的时候render就会被调用，render函数就是生命周期函数）  组件一创建就会被调用 constructor函数和生命周期函数</p>
<p>每一个组件都可以有生命周期函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps,nextState) &#123;</span><br><span class="line">	<span class="keyword">if</span>(nextProps.content !==<span class="keyword">this</span>.props.content) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">设置shouldComponentUpdate这个声明周期函数提升了组件的性能，性能提升在避免组件做无谓的render操作。render重新执行就意味着react底层需要对组件重新生成一份虚拟DOM，这样就要和之前的虚拟DOM做比对，虽然虚拟DOM的比对比真实DOM的比对性能要快的多，但是能省略这个比对过程，当然可以节约更多的性能。--性能优化</span><br><span class="line"></span><br><span class="line"> 一般把ajax请求放到ComponentDidMount（）来做</span><br><span class="line"></span><br><span class="line"> 如何发送ajax请求，首先我们要借助一个库  在todolist输入命令行：yarn add axios   </span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line"> 	axios.get(<span class="string">'/api/todolist'</span>)</span><br><span class="line"></span><br><span class="line">    .then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;alert( <span class="string">'success'</span> )&#125;)</span><br><span class="line"></span><br><span class="line">	.catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;alert( <span class="string">'error'</span> )&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><p><strong>CSS过渡动画</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">可以使用关键帧</span><br><span class="line">@keyframes identifier &#123;  </span><br><span class="line">    <span class="number">0</span>% &#123;</span><br><span class="line">        opacity: <span class="number">1</span>;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50</span>% &#123;</span><br><span class="line">        opacity: <span class="number">0.5</span>;</span><br><span class="line">        color: salmon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100</span>%&#123;</span><br><span class="line">        opacity: <span class="number">0</span>;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.hide&#123;</span><br><span class="line">   animation: identifier <span class="number">2</span>s ease-<span class="keyword">in</span> forwards; <span class="comment">//如果没有forwards 动画执行结束</span></span><br><span class="line">&#125;</span><br><span class="line">注意:关键帧当动画执行结束后，最后一帧动画的CSS效果不会被保存下来。加了forwards属性就可以保存下来了</span><br><span class="line">实际上用CSS3开发出的动画具有局限性，涉及js动画的时候就没法处理了。因此得使用下方的模块</span><br></pre></td></tr></table></figure>
<p><strong>使用react-transition-group实现动画</strong></p>
<blockquote>
<p>使用这个可能实现更加复杂的动画效果</p>
<p>[官网文档API网址]（<a href="https://reactcommunity.org/react-transition-group/" target="_blank" rel="noopener">React Transition Group (reactcommunity.org)</a>）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">App.js文件里</span><br><span class="line">对单个元素实现效果:</span><br><span class="line">&lt;CSSTransition&gt;组件 </span><br><span class="line"></span><br><span class="line">	&lt;CSSTransition</span><br><span class="line">            <span class="keyword">in</span>=&#123;<span class="keyword">this</span>.state.show&#125; <span class="comment">//显示的属性</span></span><br><span class="line">            timeout=&#123;<span class="number">1000</span>&#125;       <span class="comment">//显示的时间</span></span><br><span class="line">            classNames=<span class="string">'fade'</span>    <span class="comment">//入场和出场动画属性名匹配</span></span><br><span class="line">            unmountOnExit</span><br><span class="line">            onEntered=&#123;(el)=&gt;&#123;el.style.color=<span class="string">'blue'</span>&#125;&#125;<span class="comment">//入场动画结束时显示的</span></span><br><span class="line">            appear=&#123;<span class="literal">true</span>&#125;<span class="comment">//在入场动画开始前就显示样式  同时在style.css要加上appear属性           </span></span><br><span class="line">     &gt;</span><br><span class="line">            &lt;div&gt;hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>CSSTransition&gt; </span><br><span class="line">style.css文件里</span><br><span class="line">.fade-enter, .fade-appear &#123;</span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.fade-enter-active , .fade-appear-active&#123;</span><br><span class="line">    opacity: <span class="number">1</span>;</span><br><span class="line">    transition: opaciy <span class="number">1</span>s ease-<span class="keyword">in</span> ;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.fade-enter-done &#123;</span><br><span class="line">    opacity: <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">补充:很多相关的API都可以展示效果（例如出场动画第一帧，中间帧等等）</span><br><span class="line"></span><br><span class="line">对多个元素实现效果: </span><br><span class="line">        &lt;TransitionGroup&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="keyword">return</span>( <span class="xml"><span class="tag">&lt;<span class="name">CSSTransition</span></span></span></span><br><span class="line"><span class="xml">                    timeout=&#123;1000&#125; </span></span><br><span class="line"><span class="xml">                    classNames='fade'  </span></span><br><span class="line"><span class="xml">                    unmountOnExit</span></span><br><span class="line"><span class="xml">                    onEntered=&#123;(el)=&gt;&#123;el.style.color='blue'&#125;&#125;</span></span><br><span class="line"><span class="xml">                    appear=&#123;true&#125;</span></span><br><span class="line"><span class="xml">                    key=&#123;index&#125;             </span></span><br><span class="line"><span class="xml">        				&gt;</span></span><br><span class="line"><span class="xml">            		<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       				 <span class="tag">&lt;/<span class="name">CSSTransition</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">        			&#125;)&#125;</span><br><span class="line">        &lt;<span class="regexp">/TransitionGroup&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果<code>CSSTransition</code>实现不了的效果就可以去浏览<code>Transition</code>API。(API位置在官网文档最下方)</p>
<p><strong>redux</strong>（数据层框架）</p>
<blockquote>
<p>用一张图很好的表示有无Redux之间的区别（数据的传递更加简化，便捷）</p>
<p>有Redux不管组件的层次结构有多深，走的流程都是一样的。组件改变-&gt;数据修改-&gt;其余组件取用</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111181216252.png" alt="img"></p>
<blockquote>
<p>整体redux流程：react要去改变store里的数据，首先要一个派发action，action会通过dispatch方法传递给store，store再把之前的数据state和action转发给reducers，reducers是一个函数，当reducers接收到state和action之后，做一些处理之后，会返回一个新的state给到store，store用这个新的state替换掉之前store里的数据，store数据发生改变之后，react组件会感知到store发生改变（用的是<code>store.subcribe()</code>来监测store里状态的改变）这个时候就会从store里面重新取出数据更新组件的内容，页面就发生变化了（<code>this.setState(store.getState())</code>）。 </p>
</blockquote>
<p><strong>对于todolist的案例要使点击某项实现删除某项的功能 首先先绑定一个删除的回调函数，派发一个action（某项的索引index会传进去）之后在reducers值删除（由于reduces可以接收state，但是决不能修改state）这里就要对之前的状态做一个深拷贝</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(action.type === <span class="string">'delete_todo_item'</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newstate = <span class="built_in">JSON</span>，parse(<span class="built_in">JSON</span>.stringfy(state));</span><br><span class="line">    newState.list.splice(action.index,<span class="number">1</span>)<span class="comment">//做删除</span></span><br><span class="line">    <span class="keyword">return</span> newstate</span><br><span class="line">&#125;</span><br><span class="line">**注意** 讲解简书这个项目的老师和尚硅谷的老师（好像不需要深拷贝，用的另外一个方法）对redux基础知识的讲解有点出处。</span><br><span class="line">之后会做整合的博客</span><br></pre></td></tr></table></figure>
<p><strong>对ActionTypes的拆分：目的是为了拼写错误难以找出错误，有了拆分的文件就拼写错误控制台就会直接定位报错的位置</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_INPUT_VALUE=<span class="string">'change_input_value'</span></span><br></pre></td></tr></table></figure>
<p><strong>利用actionCreators对action进行管理：目的提高代码的可维护性，加上前端有自动化测试的工具，如果你把action写在一个文 件里，自动化测试也会非常方便。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">管理前:handleInputChange(e)&#123;</span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">    type:CHANGE_INPUT_VALUE,</span><br><span class="line">    value:e.target.value</span><br><span class="line">&#125;;</span><br><span class="line">store.dispatch(action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">管理后:在actionCreators文件内:</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getInputChangeAction=<span class="function">(<span class="params">value</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:CHANGE_INPUT_VALUE,</span><br><span class="line">    valuee.target.value</span><br><span class="line">&#125;)</span><br><span class="line">handleInputChange(e)&#123;</span><br><span class="line"><span class="keyword">const</span> action = getInputChangeAction(e.target.value)</span><br><span class="line">store.dispatch(action);</span><br><span class="line">&#125;</span><br><span class="line">**高代码的可维护性</span><br><span class="line">*自动化测试也会非常方便</span><br></pre></td></tr></table></figure>
<p><strong>补充</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> store是唯一的。</span><br><span class="line"><span class="number">2.</span> 只有store能改变自己的内容。</span><br><span class="line"><span class="number">3.</span> Reducer必须是纯函数：给定固定的输入，就一定会有固定的输出，而且不会有副作用。</span><br><span class="line"><span class="number">4</span>。rudux核心API </span><br><span class="line">	-creatStore  帮助创建一个store</span><br><span class="line">	-store.dispatch 帮助派发action，action会传递给store</span><br><span class="line">	-store.getState 帮助获取store里的数据内容</span><br><span class="line">	-store.subscribe 帮助订阅store里的改变，只要store改变，store.subscribe接收的这个函数里的回调函数就会执行</span><br></pre></td></tr></table></figure>
<p><strong>UI组件和容器组件</strong></p>
<blockquote>
<p>UI组件负责页面的渲染，容器组件负责页面的逻辑</p>
</blockquote>
<p><strong>无状态组件</strong></p>
<blockquote>
<p>当一个组件只有render函数的时候，就可以使用无状态组件去替换这个普通组件</p>
<p>无状态组件相对于普通组件的优势在于：性能比较高，因为无状态组件仅仅是一个函数，普通组件是js的一个类，类生成的对象还有生命周期函数render，执行的东西要远比无状态组件要多得多。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">无状态组件:</span><br><span class="line"><span class="keyword">const</span> 组件名 = （props）=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">普通组件</span><br><span class="line"><span class="class"><span class="keyword">class</span> 组件名 <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">前提:一个组件只有一个render的时候就可以用无状态组件去替换普通组件</span><br></pre></td></tr></table></figure>
<p><strong>Redux中发送异步请求获取数据  </strong></p>
<blockquote>
<p>通过axios发送请求，将后台返回的数据传给store，但是传之前要做几个流程。首先，创建一个actionCreartors的一个函数initListAction，然后在actionTypes（防止拼写错误的文件）定义一个常量</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'./list.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = res.data;</span><br><span class="line">    <span class="keyword">const</span> action = initListAction(data)</span><br><span class="line">    store.dispatch(action)</span><br><span class="line">&#125;)</span><br><span class="line">然后在reducers文件里写</span><br><span class="line"><span class="keyword">if</span>(action.type === INIT_LIST_ACTION)&#123;</span><br><span class="line">    <span class="keyword">const</span> newstate = <span class="built_in">JSON</span>，parse(<span class="built_in">JSON</span>.stringfy(state));</span><br><span class="line">    newState.list = action.data;<span class="comment">//这里的data就是后台传过来的数据</span></span><br><span class="line">    <span class="keyword">return</span> newstate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用Redux-thunk中间件进行ajax请求发送</strong></p>
<blockquote>
<p>这个中间件可以使我们把异步请求或者复杂的逻辑放到action里处理</p>
<p>使用redux-thunk可使得创建actionCreartors定义的函数返回的结果可以是一个函数（之前返回的是一个对象），这样就可以发异步请求。 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">const</span> action = getTodoList();</span><br><span class="line">    store.dispatch(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getTodoList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span>&#123;</span><br><span class="line">	axios.get( <span class="string">'/list.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">	  <span class="keyword">const</span> data = res.data;</span><br><span class="line">	  <span class="keyword">const</span> action = initListAction(data);</span><br><span class="line">      dispatch(action);  ***最终执行的</span><br><span class="line">&#125;)</span><br><span class="line">解释:componentDidMount当组件挂载时执行，store派发函数的action实则是派发给store，但是它先会默认自动执行getTodoList()这个函数，随之就会去执行那个异步action，最终派发的也就是dispatch(action)</span><br></pre></td></tr></table></figure>
<h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p><strong>redux的标准流程</strong></p>
<blockquote>
<p>view在redux之中会派发一个action，action通过store的dispatch方法，分发给store，store接收到action连同之前的state一起传给reducer，reducer返回一个新的数据给store，store拿到新的状态去更新旧的状态。</p>
</blockquote>
<p> <strong>redux的中间件（redux-saga中间件的使用）</strong></p>
<blockquote>
<p>中间件的概念是指action和store之间的中间，指的是redux的中间键（dispatch的升级）因为只有redux有action和store的概念。</p>
<p>redux-sage远比redux-thunk复杂的多，里面内置了很多API</p>
<p>有一点区别的是如果上方<code>store.dispatch(action)</code>store传递的action是一个函数，store接收到action之后它不仅可以派发到reducer还可以派发到一个sagas.js的文件里，可以在sagas.js文件里做一些异步逻辑的操作。 </p>
</blockquote>
<p><strong>React-Redux的使用</strong></p>
<ol>
<li><p>给组件包裹一个<Provider store={store}></Provider>即可让组件使用store里的数据，是react-redux的核心组件。</p>
</li>
<li><p>通过redux的connect方法，将组件和store做一个连接 <code>export default connect(mapStateToProps,null)(组件)</code></p>
</li>
<li><p>做连接就有一个规则，规则就在第一个参数<code>mapStateToProps</code>（翻译过来就是把store里的数据映射给组件，变成组件的props）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123; <span class="comment">//state就是store里的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inputvalue:state.inputvalue<span class="comment">//  这一步映射到组件的props &lt;input value=&#123;this.props.inputValue&#125;/&gt;</span></span><br><span class="line">        list:state.list </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>connect的第二个参数是<code>mapDispatchToProps</code>(把store的diapatch方法挂载到props)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123; <span class="comment">//state就是store里的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        changeInputvalue(e)&#123;</span><br><span class="line">           <span class="keyword">const</span> action=&#123;</span><br><span class="line">               type:<span class="string">'change_input_value'</span>  <span class="comment">//组件里就是onclick=&#123;this.props.changeInputvalue&#125;</span></span><br><span class="line">               value:e.target.value</span><br><span class="line">           &#125;</span><br><span class="line">           dispatch(action); <span class="comment">//这一派发就要去写reducer了（匹配类型返回一个新的newState-&gt;newState有inputvalue和list）</span></span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上述的代码还需像之前一样创建actiontypes和actionCreaters文件</span><br><span class="line">connect生成返回的结果就是一个容器组件（可以理解成业务逻辑，数据，方法对UI组件进行包装）</span><br></pre></td></tr></table></figure>
<h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><h2 id="开始实战"><a href="#开始实战" class="headerlink" title="开始实战"></a>开始实战</h2><p><strong>1、引入reset.css文件</strong></p>
<blockquote>
<p>使用reset.css的好处：不同浏览器的内核里面对html，body这样的标签，默认样式得设置是不同的，有可能在某一个浏览器上margin间距值是10，而在另外一个浏览器上这个间距值可能就是8。为了能让我们代码在所有浏览器表现形式都是一致的，首先就得对这些浏览器默认对这些标签的实现进行统一，reset.css就是干这个活，使得这些标签在任何浏览器上的margin padding默认都是一样的。一般在开发项目的时候，首先就要先引入reset.css文件。</p>
</blockquote>
<hr>
<p><strong>2、简书网站头部区块的编写</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">与之前不一样的是，对样式的处理需要创建一个style.js文件（样式写在这个文件里，实际上是一个个的组件，不会影响其他页面的组件样式）</span><br><span class="line">也就是我们这个页面用这个组件时候。这些样式只作用这个组件上面，对其他任何地方都没有影响，有效避免写项目潜在的可能css样式冲突的问题</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HeaderWrapper = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">    height:56px;</span></span><br><span class="line"><span class="string">    background:red;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"> HeaderWrapper是带样式的div标签 </span><br><span class="line"> 用法在header组件里引入后使用  &lt;HeaderWrapper&gt;header&lt;<span class="regexp">/HeaderWrapper&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">注意点:</span></span><br><span class="line"><span class="regexp">	1.在style.js写的样式都要加分号``;``不然样式显示不出来</span></span><br><span class="line"><span class="regexp">	2.a标签不能设置宽高，必须转换为块元素</span></span><br><span class="line"><span class="regexp">    3.头部导航条设置padding 不然会导致设置的图标重合</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111201038700.png" alt="image-20211120103759703"></p>
<blockquote>
<p>就像这样 因此需要去设置头部导航条</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  width:<span class="number">960</span>px;</span><br><span class="line">  height:<span class="number">100</span>%;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line"> +padding-right:<span class="number">70</span>px;</span><br><span class="line"> +box-sizing:border-box</span><br><span class="line">+号为添加的代码，设置一个内聚变以便使其隔开，但是为了保证盒子宽度不变，还得将盒子设置成border-box</span><br><span class="line"></span><br><span class="line">由于搜索框和图标是独立的，因此需要&lt;SearchWrapper&gt;&lt;<span class="regexp">/SearchWrapper&gt;标签将其包裹</span></span><br><span class="line"><span class="regexp">由于该标签被Nav标签包裹且在Nav标签里的子标签都设置了浮动，宽度失效。如果SearchWrapper不设置浮动，宽度就会继承Nav的宽度</span></span><br><span class="line"><span class="regexp">就与搜索框的宽度不一致，因此也得将SearchWrapper设置浮动。</span></span><br></pre></td></tr></table></figure>
<h2 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h2><p><strong>整体交换的流程</strong></p>
<blockquote>
<p>创建store文件夹-&gt;创建index.js ,reducer.js-&gt;编写相应的内容如下</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">index.js:</span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line">reducer.js:</span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState,action)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后回到App.js引入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 回到header组件引入connect,，将组件和store做一个连接</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(Header)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于初始化的数据需要放在reducer.js上 所以将组件里的数据进行转移      —&gt;形成版本1</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Header/index.js 将状态转移后删除</span><br><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            focused:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">reduer.js</span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    focused:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于header组件里有很多是用到state里的focused,因此得将从state拿改成从props拿， 此时就需要mapState…方法</p>
<p>将store里状态的focused映射到组件的Props里去,因此就可以将下方图中的state替换成props</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111220951787.png" alt="image-20211122095058838"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleInputFocus=<span class="function"><span class="params">()</span>=&gt;</span>&#123;     </span><br><span class="line">     <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            focused:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">handleInputBlur=<span class="function"><span class="params">()</span>=&gt;</span>&#123;  </span><br><span class="line">     <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            focused:<span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">这两个方法之前是为了去改变state里的数据 现在数据都不在state里存放了因此就可以连同方法删掉</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后我们要实现当聚焦的时候要改变focused的值 -&gt;一整套流程</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">当你聚焦的时候，改变store里的数据，就要去调用store的dispatch方法，就要把方法定义在mapDispatch...里</span><br><span class="line">Focus=&#123;<span class="keyword">this</span>.handleInputFocus&#125;</span><br><span class="line">onBlur=&#123;<span class="keyword">this</span>.handleInputBlur&#125;</span><br><span class="line">改成</span><br><span class="line">onFocus=&#123;<span class="keyword">this</span>.props.handleInputFocus&#125;</span><br><span class="line">onBlur=&#123;<span class="keyword">this</span>.props.handleInputBlur&#125;</span><br><span class="line">有这个方法之后，首先要改变store里的数据首先要创建一个action</span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps=<span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        handleInputFocus()&#123;</span><br><span class="line">            <span class="keyword">const</span> action = &#123;</span><br><span class="line">                type:<span class="string">'search_focus'</span></span><br><span class="line">            &#125;;</span><br><span class="line">        	dispatch(action)  </span><br><span class="line">        &#125;,</span><br><span class="line">        handleInputBlur()&#123;</span><br><span class="line">            <span class="keyword">const</span> action = &#123;</span><br><span class="line">                type:<span class="string">'search_blur'</span></span><br><span class="line">            &#125;;</span><br><span class="line">            dispatch(action)</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">reducers.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  (state = defaultState,action)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.type===<span class="string">'search_focus'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.type===<span class="string">'search_blur'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<blockquote>
<p>我们把之前组件里的数据移除了，转移到redux公共存储的框架进行存储。Header组价就变成了一个无状态组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无状态组件的写法 <span class="keyword">const</span> Header = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="number">1.</span>render以下的内容（不包括render）</span><br><span class="line">    <span class="number">2.</span>所有的<span class="keyword">this</span>去掉</span><br><span class="line">&#125;</span><br><span class="line">到这形成第<span class="number">2</span>版</span><br></pre></td></tr></table></figure>
<h2 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h2><blockquote>
<p>安装redux-devtools-extension工具使得网页可以显示redux组件操作状态的变化</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,composeEnhancers())</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222124933.png" alt="image-20211122212415727"></p>
<blockquote>
<p>由于reducers存放数据和数据的处理，随着功能的强大，数据量会越来越大，因此不能都放在reducers里存储。</p>
<p>于是在head文件夹下创建一个store的文件夹，创建一个header下的reducer，将store里的reuders移至header的reducers</p>
<p>全局的reducer作为一个仓库，专门来放置各个组件部分的reducers。 此时功能尚未实现，因为header下的index.js文件mapState…方法用的是全局的reducer，因此得修改如下</p>
</blockquote>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        focused: state.header.focused</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">仓库reducers</span><br><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> headreducer&#125; <span class="keyword">from</span> <span class="string">'../common/header/store'</span>  <span class="comment">//间接引入reducers 目录结构会少两层 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line"></span><br><span class="line">    header:headreducer</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br><span class="line">间接引入reducers 目录结构会少两层 因为header下的reduces间接由header下的index.js文件管理了 。引入的时候就方便了</span><br></pre></td></tr></table></figure>
<h2 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h2><blockquote>
<p>由于现在在header组件下创建了一个头部的reducers，由于在头部组件里改变数据的时候派发action，然后reducer接收action然后去修改数据，之前课程说过action不要写成对象，类型也不要写成字符串。用actionCreate去创建action，同时类型定义成常量。</p>
<p>按这个做下去逻辑太绕了，不易理解。大改文件夹存放的位置 </p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111231119404.png" alt="image-20211123111850307"></p>
<blockquote>
<p>在reducer.js文件里,不能对原始的state做修改，为了防止这一点得引入facebook团队研发出来的一个库：immutable.js</p>
<p>它会帮助我们生成一个immutable对象 （不可改变的）如果state是immutable对象就是不可以被改变，就不会出问题。</p>
<p>immutable这个库提供了一个fromJS方法，可以帮助我们把一个js对象转化为immutable对象，用这个方法把数据对象（js对象）</p>
<p>转化为immutable对象。此时header下的index文件的mapState方法里的数据已经转化为immutable类型的数据（state.header）</p>
<p>如果是immutable类型的数据，再进行state.header.focused这种语法是不合理的了。immutable.js里面调用state.header里的属性不能通过点focused的方式来调用，得通过点get的方法传入focused的属性来获取对应的属性。此时不会报错，但是点击的时候就会报错报错的原因在与当你派发一个action的时候，传入reducers返回的是一个普通对象，普通对象时没有get方法的 为了防止这种情况应该这样写（没修改前与修改前的代码）</p>
<p>总结：借助immutable这个库避免编写改变数据里state的情况</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">未修改前的reducers:</span><br><span class="line"><span class="keyword">import</span> &#123;SEARCH_FOCUS,SEARCH_BLUR&#125; <span class="keyword">from</span> <span class="string">'../constant'</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">     focused:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_FOCUS)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_BLUR)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">false</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br><span class="line"></span><br><span class="line">修改前的header下的index.js</span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        focused:state.header.focused</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修改后的reducers:</span><br><span class="line"><span class="keyword">import</span> &#123;SEARCH_FOCUS,SEARCH_BLUR&#125; <span class="keyword">from</span> <span class="string">'../constant'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">'immuatble'</span></span><br><span class="line"><span class="keyword">const</span> defaultState = fromJS(&#123;</span><br><span class="line">     focused:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_FOCUS)&#123;</span><br><span class="line">       <span class="comment">// immutable对象的set方法，会结合之前immutable对象的值和设置的值,返回一个全新的对象，并没有改变原始的state</span></span><br><span class="line">        <span class="keyword">return</span> state.set(<span class="string">'focused'</span>,<span class="literal">true</span>) <span class="comment">//这里的变更不是直接变更</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_BLUR)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.set(<span class="string">'focused'</span>,<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br><span class="line"></span><br><span class="line">修改后的header下的index.js</span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        focused:state.header.get(<span class="string">'focused'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 即便是修改后的index.js 由于state是js对象，state.header是immutable对象 所以去调用focused属性的时候，数据获取的行为是不统一的。（不太靠谱）因此我们想让state也成为immutable对象，而不是js对象</p>
<p>state对应的数据是在redux下reducers里的index.js里创建的，因此我们要依赖第三方的模块 redu-immutable</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux-immutable'</span><span class="comment">//只要combineReducers是由这个库引入的reducer就是immuable对象了  </span></span><br><span class="line">之后回到header下改如下代码即可</span><br><span class="line">focused:state.get(<span class="string">'header'</span>).get(<span class="string">'focused'</span>)</span><br><span class="line">可以简写为 focused:state.getIn([<span class="string">'header'</span>,<span class="string">'focused'</span>])</span><br></pre></td></tr></table></figure>
<p><strong>下一阶段（搜索区域的布局） F11退出全屏</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  &lt;SearchList&gt;</span><br><span class="line">    &lt;SearchInfoItem&gt;教育&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">    &lt;SearchInfoItem&gt;简书&lt;/</span>SearchInfoItem&gt;</span><br><span class="line">    &lt;SearchInfoItem&gt;生活&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">    &lt;SearchInfoItem&gt;投稿&lt;/</span>SearchInfoItem&gt;</span><br><span class="line">    &lt;SearchInfoItem&gt;历史&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>SearchList&gt;</span><br><span class="line">由于子元素设置浮动了 父元素的高度无法被撑起所以给父元素设置一个BFC</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SearchList = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">    overflow:hidden;//此时只是开启BFC使其高度和宽度不丢失</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">之后就是该列表聚焦的时候显示，不聚焦的时候不显示，设置一个函数，给函数接收一个变量show。</span><br><span class="line">如果show为真就返回整个列表，假就返回<span class="literal">null</span></span><br><span class="line">最后再调用一下这个方法   &#123;getListArea(props.focused)&#125; 传入focused的值即可</span><br></pre></td></tr></table></figure>
<p><strong>换一批的功能</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">此时的header是一个无状态组件，之后还要添加很多功能，就会出现函数嵌套函数，就会使Header变得越来越庞大，不好维护</span><br><span class="line">因此还是使用Component组件 将原来props前加一个<span class="keyword">this</span> 且将显示列表的方法定义在组件里接口</span><br><span class="line"></span><br><span class="line">由于列表里的内容实际上是通过ajax数据获取的，因此header里不进要有focused的数据还得有列表的内容</span><br><span class="line">因此在header的reducer里加一个list:[]; </span><br><span class="line">当导航的input框做了聚焦之后，就要获取ajax数据，也就是onFocus的时候，onFocus执行的是handleInputFocus这个方法</span><br><span class="line">找到这个方法在方法里获取ajax数据，之前的课程有说过，获取ajax数据一般来说不会直接写在组件里，会把异步的操作放到action，或者放到redux-saga里面进行处理，这里统一使用redux-thunk，把异步操作都放至action里处理</span><br><span class="line">redux-thunk其实就是action和store之间的中间件 其实就是对dispatch方法的升级</span><br><span class="line">因此得写在创建store之前被使用</span><br><span class="line"><span class="keyword">import</span> &#123;createStore,compose,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,composeEnhancers(</span><br><span class="line">    applyMiddleware(thunk)</span><br><span class="line">))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line">有了redux-thunk之后，就可以去action里面做异步操作了</span><br><span class="line">dispatch(getList());去派发这样一个action</span><br><span class="line">以前的action返回的是一个对象，现在可以返回函数</span><br><span class="line">函数里写个输出<span class="number">123</span> 只要聚焦控制台就会显示<span class="number">123</span></span><br><span class="line">发请求前要先安装包axios  </span><br><span class="line">axios.get(<span class="string">'/api/headerList.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ERROR'</span>);         </span><br><span class="line">        &#125;)       </span><br><span class="line">&#125;</span><br><span class="line">在public文件夹下创建一个api文件夹之后在创建headerList.json的文件输入一下数据 之后在网页访问这个链接页面就可以显示数据</span><br><span class="line">原理:首先先到功能目录下看看有没有对应的路由，找不到就会去public目录下找api的headerList.json，找到后就会把文件的内容输出出来</span><br><span class="line">通过这个特性，我们可以创建一些假数据，保存。</span><br><span class="line">模拟的数据要和后端对的数据要保持一直，就是定一下格式</span><br><span class="line">public下的api下的header.json添加模拟的数据 此时:</span><br><span class="line">axios.get(<span class="string">'/api/headerList.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res <span class="comment">// 当你点击搜索的时候，控制台已经有输出了 见下图</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ERROR'</span>);         </span><br><span class="line">        &#125;)       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111231623925.png" alt="image-20211123162311226"></p>
<blockquote>
<p>之前header下的reducer里定义了一个list：[]，现在发送了一个ajax请求，获取到了结果，现在就是希望能用获取的结果替换那个空数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">action.js文件里</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getList = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;  <span class="comment">//返回函数，就要就是去派发一个异步的请求</span></span><br><span class="line">        axios.get(<span class="string">'/api/headerList.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> data = res.data;</span><br><span class="line">            <span class="keyword">const</span> action = changeList(data.data);</span><br><span class="line">            dispatch(action)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ERROR'</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">reducer.js文件里</span><br><span class="line"><span class="keyword">if</span>(action.type===CHANGELIST)&#123;</span><br><span class="line">    <span class="keyword">return</span> state.set(<span class="string">'list'</span>,action.data) </span><br><span class="line">    <span class="comment">//console.log(action);//返回的是&#123;type: "change_list", data: Array(50)&#125;</span></span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">这样写实际上还是有问题的：创建store，默认list是一个空数组，fromJS方法会将js对象转换为immuable对象，list是个数组，也会变成immuable的数组，但是调用<span class="keyword">set</span>去改变list的时候，action.data实际上是一个普通的数组， list数组会由immuable数组变成一个普通的数组，这样的话数据类型就会变了，解决这个问题</span><br><span class="line">export const changeList = (data) =&gt;(&#123;</span><br><span class="line">    type:CHANGELIST,</span><br><span class="line">    data:fromJS(data)</span><br><span class="line">&#125;)</span><br><span class="line">这样转换一下 <span class="keyword">const</span> action = changeList(data.data);<span class="comment">//输出data后的结果</span></span><br><span class="line">这里派发的时候数据就会转换成immuable的数据类型。这样reducer里接收到action的数据类型也就是immuable类型了。</span><br><span class="line">做到这里就可以使用redux的插件去查看显示header里面就list的数组了</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111231710590.png" alt="image-20211123170830305"></p>
<blockquote>
<p>之后就是将list里的数组逐一放至getListArea的方法里展示</p>
</blockquote>
<p><strong>总结</strong></p>
<blockquote>
<p>实际上讲的就是项目中用react-thunk发送ajax数据。获取到数据之后，存到store里面，然后在页面上进行显示，有几个关键点</p>
<p>第一个我们把异步获取的逻辑都拆分到actions文件夹下，如果你想拆分到这里来，就要求action返回的对象不能是一个js对象，而是一个函数，如果要返回的是一个函数就必要要用redux-thunk这个中间件，这是第一个重点</p>
<p>第二个当我们获取到数据，想要改变store里的数据的时候，我们要注意redux里的list因为外层包裹了一个fromJS，它会在创建的时候，会把内部的list定义的数组由一个普通的数组转换为immuable类型的数组，但是想直接改变这个状态的数组，就会把之前immuable类型变成普通数组的类型，因为我们就要再action之前传递action之前就要把数据转换为immuable类型的数据，这样数据统一就不会有问题。</p>
<p>页面循环展示数据，就要调用map方法通过对每一项进行循环展示，对对应的内容都展示在页面上  —功能实现</p>
</blockquote>
<p><strong>避免无意义的ajax请求发送（上方衔接最后补充的内容）</strong></p>
<blockquote>
<p>每点击一次焦点的时候就会发送一次ajax请求。实际上列表中的数据获取一次就可以了</p>
<p>解决问题：给<code>handleInputFocus(list)</code>传入list 然后输出list可以看出第一次请求的时候list.size是0，之后就是50，</p>
<p>所以控制当size为0的时候才发送请求，之后不等于0的时候就不发生了，这样就避免了每次获取焦点的时候都发一个ajax请求，从而做到性能上的调优。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> handleInputFocus(list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.size===<span class="number">0</span>)&#123;</span><br><span class="line">                  dispatch(getList());</span><br><span class="line">            &#125; 					 或者 (list.size&gt;<span class="number">0</span>)&amp;&amp;dispatch(getList());意思都一样</span><br><span class="line">            dispatch(searchFocus());</span><br><span class="line">        &#125;,</span><br><span class="line">            </span><br><span class="line">样式加一个cursor:pointer 可使鼠标放上去有个小手的标志。</span><br></pre></td></tr></table></figure>
<p> <strong>路由</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter,Route&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line">BrowserRouter代表路由 Route代表路由规则</span><br><span class="line">首先先引入路由组件</span><br><span class="line">下载包:npm add react-router-dom</span><br><span class="line">**注意** 前两周这个包刚更新过如果按之前的编码规则会使得路由组件无法显示(太坑了官网也不发布，害我整了半天)</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111242012568.png" alt="image-20211124201227148"></p>
<blockquote>
<p>把首页组件拆分成一个个小的组件</p>
<p>  外层元素：margin-left: -18px;</p>
<p>  内层元素：margin-left: 18px;、</p>
<p>  这样就可以充分利用左侧栏的宽度，使其保持一直</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   &lt;TopicItem&gt;</span><br><span class="line">               &lt;img</span><br><span class="line">        className=<span class="string">'topic-pic'</span></span><br><span class="line">        src=<span class="string">'//upload.jianshu.io/collections/images/261938/man-hands-reading-boy-large.jpg?							imageMogr2/auto-orient/strip'</span> alt=<span class="string">'niao'</span></span><br><span class="line">        /&gt;</span><br><span class="line">            社会热点</span><br><span class="line">&lt;<span class="regexp">/TopicItem&gt;</span></span><br><span class="line"><span class="regexp">这是一个标题数据，之后我们拿来用的时候需要从redux里取 数据都存在store里，而Topic是home的自组件 而home是APP的子组件</span></span><br><span class="line"><span class="regexp">因此Topic是APP的自组件 想使用store里的数据需要connect做连接</span></span><br><span class="line"><span class="regexp">定义一个获取状态的方法 mapState,从reducer获取到list给Topic组件遍历即可</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;TopicWrapper,TopicItem&#125; <span class="keyword">from</span> <span class="string">'../style'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topic</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;TopicWrapper&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.list.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;TopicItem key=&#123;item.get(<span class="string">'id'</span>)&#125;&gt;</span><br><span class="line">                        &lt;img</span><br><span class="line">                            className=<span class="string">'topic-pic'</span></span><br><span class="line">                            src=&#123;item.get(<span class="string">'imgUrl'</span>) &#125; <span class="comment">//reducer.js定义好的</span></span><br><span class="line">                            alt=<span class="string">"nihao"</span>/&gt;</span><br><span class="line">                        &#123;item.get(<span class="string">'title'</span>)&#125;</span><br><span class="line">                    &lt;<span class="regexp">/TopicItem&gt;</span></span><br><span class="line"><span class="regexp">                    )</span></span><br><span class="line"><span class="regexp">                &#125;)&#125;</span></span><br><span class="line"><span class="regexp">      </span></span><br><span class="line"><span class="regexp">            &lt;/</span>TopicWrapper&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapState  =<span class="function">(<span class="params">state</span>) =&gt;</span>(&#123;</span><br><span class="line">    list: state.get(<span class="string">'home'</span>).get(<span class="string">'topicList'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapState,<span class="literal">null</span>)(Topic)<span class="comment">//因为不需要修改状态 所以暂且先传入一个null</span></span><br></pre></td></tr></table></figure>
<h2 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h2><blockquote>
<p>页面的组件，首先闲在reducer的初始状态定义好相应的信息</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">articleList:[&#123;</span><br><span class="line">       id: <span class="number">1</span>,</span><br><span class="line">       title:<span class="string">'大数据分析可视化平台'</span>,</span><br><span class="line">       desc:<span class="string">'支持直连MySQL、SQL Server、PostgreSQL、Oracle、SAP HANA、Hive等数据源，也可上传本地Excel/Csv文件或通过API连接数据。可完成多源交互分析'</span>,</span><br><span class="line">       imgUrl:<span class="string">'https://lupic.cdn.bcebos.com/20200412/3048304592_14_800_600.jpg'</span></span><br><span class="line">   &#125;,&#123;</span><br><span class="line">       id: <span class="number">2</span>,</span><br><span class="line">       title:<span class="string">'大数据分析可视化平台'</span>,</span><br><span class="line">       desc:<span class="string">'支持直连MySQL、SQL Server、PostgreSQL、Oracle、SAP HANA、Hive等数据源，也可上传本地Excel/Csv文件或通过API连接数据。可完成多源交互分析'</span>,</span><br><span class="line">       imgUrl:<span class="string">'https://lupic.cdn.bcebos.com/20200412/3048304592_14_800_600.jpg'</span></span><br><span class="line">   &#125;],</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后在组件里通过调用connect 里调用因为这个状态是immuable数据类型 因此需要用get方法来引入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;RecommendWrapper,RecommendItem&#125; <span class="keyword">from</span> <span class="string">'../style'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="comment">// import imgone from '../1.jpg'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recommend</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RecommendWrapper&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">this</span>.props.list.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span>   <span class="xml"><span class="tag">&lt;<span class="name">RecommendItem</span> <span class="attr">imgUrl</span>=<span class="string">&#123;item.get(</span>'<span class="attr">imgUrl</span>')&#125; <span class="attr">key</span>=<span class="string">&#123;item.get(</span>'<span class="attr">id</span>')&#125;/&gt;</span></span></span><br><span class="line">                   &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;<span class="regexp">/RecommendWrapper&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapState=(state)=&gt;(&#123;</span></span><br><span class="line"><span class="regexp">    list: state.getIn(['home','recommendList'])</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">export default connect(mapState)(Recommend)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先所有的数据内容都存在前端的代码里，都是写死的，实际做项目的时候，通过接口来获取的，不能写死。</p>
<p>在public下的api定义一个接口home.json。之后在home组件下借助componentDidMount这个声明周期函数来发ajax请求去获取数据，获取了数据，（当组件挂载完毕）。就要将获取的数据取修改store里初试的数据</p>
<p>所以要创建一个action，派发给store，需要store和组件建立连接</p>
<p>修改store里的数据也就是状态 就得使用connect的第二个参数，通过这个函数就可以定义一个方法将action派发给store</p>
<p>因为UI组件不能和store直接通信，只能通过容器组件。派发给store之后store就会派发给reducer。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'change_home_data'</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(action);<span class="comment">//返回的就是ajax请求获取出来的内容</span></span><br><span class="line">        state.set(<span class="string">'topicList'</span>,action.topicList)</span><br><span class="line"><span class="comment">//action.topicList是JS对象而上面的topicList是immuable对象不能替换因此要在前面加一个fromJS（action.topicList）</span></span><br><span class="line">由于是多个对象可以用state的一个方法做一个合并 这样就实现了通过ajax异步的形式获取到了首页的内容</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述的操作都是不合适的因为UI组件不应该有太多的业务逻辑，发ajax请求不应该在UI组件里发，放在容器组件里</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">修改前</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="built_in">console</span>.log(res);<span class="comment">//如果成功会打印 因为这个路径下有这个文件 因此是可以成功的</span></span><br><span class="line">            <span class="keyword">const</span> action=&#123;</span><br><span class="line">                type:<span class="string">'change_home_data'</span>,</span><br><span class="line">                topicList:result.topicList,</span><br><span class="line">                articleList:result.articleList,</span><br><span class="line">                recommendList:result.recommendList</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData(action)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatch = <span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    changeHomeData(action)&#123;</span><br><span class="line">        dispatch(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="literal">null</span>,mapDispatch)(Home)  </span><br><span class="line">第一次修改后：</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">       </span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData()</span><br><span class="line">            </span><br><span class="line">     </span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatch = <span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    changeHomeData()&#123;</span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action=&#123;</span><br><span class="line">                type:<span class="string">'change_home_data'</span>,</span><br><span class="line">                topicList:result.topicList,</span><br><span class="line">                articleList:result.articleList,</span><br><span class="line">                recommendList:result.recommendList</span><br><span class="line">            &#125;</span><br><span class="line">        dispatch(action);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="literal">null</span>,mapDispatch)(Home)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次升级 ajax请求不放在容器组件里 放在action里 通过调用那个函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;      </span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData()          </span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatch = <span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    changeHomeData()&#123;</span><br><span class="line">        dispatch(getHomeInfo())<span class="comment">//因为派发的action是一个函数 且返回的是一个函数。如果这个action是个函数，就会顺序执行这个函数，执行这个函数action就会去派发 页面就重新执行了</span></span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而后action里代码可以做升级</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">action下home.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getHomeInfo = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;  <span class="comment">//返回函数，就要就是去派发一个异步的请求</span></span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action=&#123;</span><br><span class="line">                type:<span class="string">'change_home_data'</span>,</span><br><span class="line">                topicList:result.topicList,</span><br><span class="line">                articleList:result.articleList,</span><br><span class="line">                recommendList:result.recommendList</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch(action);</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">优化后</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">const</span> changeHomeData=<span class="function">(<span class="params">result</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:<span class="string">'change_home_data'</span>,</span><br><span class="line">    topicList:result.topicList,</span><br><span class="line">    articleList:result.articleList,</span><br><span class="line">    recommendList:result.recommendList</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getHomeInfo = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;  <span class="comment">//返回函数，就要就是去派发一个异步的请求</span></span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action = changeHomeData(result)</span><br><span class="line">            dispatch(action);  或者写成    dispatch(changeHomeData(result))</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">之后让type成常量 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;LoadMore onClick=&#123;<span class="keyword">this</span>.props.getMore&#125;&gt;更多文字&lt;<span class="regexp">/LoadMore&gt;*** 不用写()</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于页数的编码，首先先在reducers定义一个初始状态，定义完之后就可以回到List组件里定义mapState方法中的page：state…</p>
<p>定义完之后将UI组件里的LoadMore里的onClick的回调函数设置为箭头函数 传page进去， 下面调用方法的函数也传page</p>
<p>之后发异步action</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &lt;LoadMore onClick=&#123;()=&gt;<span class="keyword">this</span>.props.getMore(<span class="keyword">this</span>.props.page)&#125;&gt;更多文字&lt;<span class="regexp">/LoadMore&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">          </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapState =<span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;</span><br><span class="line">    list:state.get(<span class="string">'home'</span>).get(<span class="string">'articleList'</span>),</span><br><span class="line">    page:state.get(<span class="string">'home'</span>).get(<span class="string">'articlePage'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatch=<span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    getMore(page)&#123;</span><br><span class="line">        dispatch(getMoreList(page))</span><br><span class="line">    &#125;&#125;)</span><br><span class="line"></span><br><span class="line">异步action</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getMoreList=<span class="function">(<span class="params">page</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">      </span><br><span class="line">        axios.get(<span class="string">'./api/homeList.json?page='</span> + page).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action = AddHomeData(result,page+<span class="number">1</span>)   <span class="comment">//这里每次点击更多的时候页面加1</span></span><br><span class="line">            dispatch(action);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;&#125;</span><br><span class="line">每一个异步action都有一个同步action</span><br><span class="line"><span class="keyword">const</span> AddHomeData = <span class="function">(<span class="params">list,nextpage</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:ADD_HOME_LIST,</span><br><span class="line">    list:fromJS(list),   </span><br><span class="line">    nextpage</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">之后就回到reducer 去更新原始页面的状态</span><br></pre></td></tr></table></figure>
<p><strong>回到顶部</strong></p>
<blockquote>
<BackTop onClick={this.handleScrollTop}>回到顶部</BackTop>

</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleScrollTop() &#123;</span><br><span class="line">		<span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//回到顶部 </span></span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">之后实现页面再顶部的时候不显示回到顶部这个图标  在底部才实现</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后在home.js下的传入connect的第一个参数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapState =<span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;</span><br><span class="line">    showScroll:state.getIn([<span class="string">'home'</span>,<span class="string">'showScroll'</span>])  <span class="comment">//由于reducer的初始值有定义</span></span><br><span class="line">&#125;)</span><br><span class="line">控制这个值的<span class="literal">true</span>和<span class="literal">false</span> 来实现是否显示回到顶部的功能</span><br><span class="line">&#123;<span class="keyword">this</span>.props.showScroll ? <span class="xml"><span class="tag">&lt;<span class="name">BackTop</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleScrollTop&#125;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">BackTop</span>&gt;</span></span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><blockquote>
<p>在组件刚挂载的时候绑定一个监听事件来监测滚轮是是否滑动</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData()</span><br><span class="line">            <span class="keyword">this</span>.bindEvents();</span><br><span class="line">&#125;</span><br><span class="line">    bindEvents()&#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,<span class="keyword">this</span>.props.changeScrollTopShow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用的方法:</span><br><span class="line">   changeScrollTopShow(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);  <span class="comment">//打印的就是下图一个个事件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111260957851.png" alt="image-20211126095729529"></p>
<blockquote>
<p>如果不打印事件 换做</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.scrollTop(获取滚动条位置)要获取当前页面的滚动条纵坐标位置</span><br><span class="line"> changeScrollTopShow()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">    &#125;</span><br><span class="line">我也不明白为什么我打印出的是小数</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261002063.png" alt="image-20211126100207963"></p>
<blockquote>
<p>之后将这个值设置大于400的时候显示回到顶部，否则隐藏，因此我们要改reducer里的数据，通过发action进行改</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">changeScrollTopShow()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.documentElement.scrollTop&gt;<span class="number">400</span>)&#123;</span><br><span class="line">            dispatch(toggleTopShow(<span class="literal">true</span>))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dispatch(toggleTopShow(<span class="literal">false</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">action.js文件       </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTopShow=<span class="function">(<span class="params">show</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:TOGGLE_SCROLL_TOP,</span><br><span class="line">    show</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">reducer.js文件</span><br><span class="line"> <span class="keyword">case</span>  TOGGLE_SCROLL_TOP:</span><br><span class="line">       <span class="keyword">return</span> state.set(<span class="string">'showScroll'</span>,action.show)</span><br><span class="line">功能实现 但是需要注意的是创建组件组件挂载的时候，往<span class="built_in">window</span>上绑定的scroll事件的监听的时候，一定要把scroll事件监听在<span class="built_in">window</span>上移除</span><br><span class="line">这样组件的事件就不会影响其他的组件</span><br><span class="line">reducer.js代码优化:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CHANGE_HOME_DATA:</span><br><span class="line">    <span class="keyword">return</span> state.merge(&#123;</span><br><span class="line">        topicList:fromJS(action.topicList),</span><br><span class="line">        articleList:fromJS(action.articleList),</span><br><span class="line">        recommendList:fromJS(action.recommendList)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    定义一个方法</span><br><span class="line">    <span class="keyword">const</span> changeHomeData=<span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.merge(&#123;</span><br><span class="line">            topicList:fromJS(action.topicList),</span><br><span class="line">            articleList:fromJS(action.articleList),</span><br><span class="line">            recommendList:fromJS(action.recommendList)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    然后调用： </span><br><span class="line">    <span class="keyword">case</span> CHANGE_HOME_DATA:</span><br><span class="line">            <span class="keyword">return</span> changeHomeData(state,action)  ***修改部分</span><br><span class="line">        <span class="keyword">case</span> ADD_HOME_LIST:</span><br><span class="line">            <span class="keyword">return</span> addhomedata(state,action)</span><br></pre></td></tr></table></figure>
<p><strong>首页性能调优</strong></p>
<blockquote>
<p>因为首页的index.js都调用了connect的方法，和store做了连接，这就会产生一个问题，只要store发生了改变，那么每一个组件都会被重新渲染，也就是每个函数的render函数会被重新执行，可能有些数据发生改变了，但是那个数据和这个组件一点关系都没有，但是这个组件依然会被重新渲染，导致性能不好。提高组价性能 shouldComponentUpdata，可以在这里做性能优化的代码，判断只有与这个组件相关的数据发生改变才让render函数重新执行（重新渲染），否则return false不让render函数重新执行。</p>
<p>通过这种方式来避免虚拟DOM的比对，提高性能，react也考虑到了这点，如果你在每个特组件都去自己写should….太麻烦了，react内置了新的组件类型，引入PureComponent，区别就是PureComponent内在自己底层实现了should…,这样就不用我们手写收should……做性能优化。之后就是每个UI组件都替换为PureComponent</p>
<p>之所以项目用<strong>PureComponent</strong>，是因为项目的数据管理用了immuable.js的框架，它可以保证我们的数据是immuable的，这样PureComponent和immuablejs数据格式的管理相结合，使用PureComponent一点问题都没有，但是如果你在你的项目里面，没有使用immuable.js管理你的数据，那么使用PureComponen有的时候会遇到坑。（偏底层的坑）</p>
</blockquote>
<p><strong>实现点击title跳转至详情页面</strong></p>
<blockquote>
<p>当我们在react实现页面跳转的时候，我们要用到react-router-dom第三方模块，它的这种跳转是单页应用跳转，所谓单页应用跳转就是做一个单页应用的时候，单页应用指的是，不管怎么做页面的跳转，整个网站只会加载一个html文件，只会加载一次html文件，那么来看使用a标签来做页面的跳转，符不符合单页应用的定义。network里Doc可以看加载的html文件，使用a标签就是会重新加载html文件，会由原来的localhost变为detail的html，增加了一次html请求，比较耗性能，因为借助react-router-dom的时候，完全没必要重新加载页面，做页面的跳转，正确的做法是用Link代替a标签。</p>
<p>注意：link标签要在Router里面否则会报错，在做头部点击简书logo的时候，因为link在head里，而APP组件的Header是在BrowseRouter外部因此违背了这个规则 导致报错</p>
</blockquote>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261120619.png" alt="image-20211126111958584"></p>
<p>或者是报这个错</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261121636.png" alt="img"></p>
<h2 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h2><p><strong>详情页面的布局</strong></p>
<blockquote>
<p>从reducer里导入初试状态的content时候会导致标签转义，所以页面显示的内容不是该有的内容。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: <span class="keyword">this</span>.props.content&#125; 这样写不会被转义</span><br><span class="line"></span><br><span class="line">之后这些数据想在后端被获取而不是通过store里的原始数据取获取。就需要发ajax请求，步骤都是和之前一样</span><br></pre></td></tr></table></figure>
<p><strong>实现点击不同的title显示不同的详情页（匹配id）</strong></p>
<blockquote>
<p>在List.js文件夹下 <Link key={index} to={'./detail/' + item.get('id')}>路径下加上一个id  打开浏览器不显示了</p>
<p>原因是在APP.js组件里路由组件匹配的路径是/detail 而不是/detail/1 因此得在路由组件匹配的时候出换一个‘/detail/：id’</p>
<p>获取参数的第一种方法：动态获取参数</p>
<p>首先打开详情页面的代码 在render和return之间先 打印输出log（this.props）//在控制台里可以看出props里match里的params里有id 然后就是在组件挂载时传入id</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">action.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getDetail=<span class="function">(<span class="params">id</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">        axios.get(<span class="string">'/api/detail.json?id='</span>+ id).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="comment">//把id传给后端</span></span><br><span class="line">            <span class="keyword">const</span> result=res.data.data;</span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            dispatch(changeDetail(result.title,result.content))</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">detail下的index.js</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detail</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;DetailWrapper&gt;</span><br><span class="line">                &lt;Header&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Content dangerouslySetInnerHTML=&#123;&#123;__html: this.props.content&#125;&#125;/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/DetailWrapper&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    componentDidMount()&#123;</span></span><br><span class="line"><span class="regexp">        const &#123;id&#125; = this.props.param</span></span><br><span class="line"><span class="regexp">        this.props.getDetail(id);/</span><span class="regexp">/通过后端去返回</span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapState=(state)=&gt;(&#123;</span></span><br><span class="line"><span class="regexp">    title: state.get('detail').get('title'),</span></span><br><span class="line"><span class="regexp">    content: state.get('detail').get('content')</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">const mapDispatch=(dispatch)=&gt;(&#123;</span></span><br><span class="line"><span class="regexp">    getDetail(id)&#123;</span></span><br><span class="line"><span class="regexp">        dispatch(getDetail(id));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">然后传递路由参数出现了问题 是由于使用了react-router-dom v6的版本 下面有解释</span></span><br><span class="line"><span class="regexp">export default connect(mapState, mapDispatch)((props)=&gt;(</span></span><br><span class="line"><span class="regexp">    &lt;Detail</span></span><br><span class="line"><span class="regexp">    &#123;...props&#125;</span></span><br><span class="line"><span class="regexp">    param=&#123;useParams()&#125;</span></span><br><span class="line"><span class="regexp">    /</span>&gt;</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p><strong>巨坑由于使用了react-router-dom v6的版本 使得组件props参数里没有location history等属性。如果使用v5的话就完全避免了这个问题（使用v5下载包的时候附上版本号yarn add react-router-dom@5.3.0）</strong></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261925280.png" alt="image-20211126192533225"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261926068.png" alt="image-20211126192612881"></p>
<p><strong>登陆组件</strong></p>
<blockquote>
<p>创建reducers 定义初始状态，login：false 之后在去头部的map方法里那login组件里的login</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">login:state.getIn([<span class="string">'login'</span>,<span class="string">'login'</span>])</span><br><span class="line">&#123;</span><br><span class="line">login ? <span class="xml"><span class="tag">&lt;<span class="name">NavItem</span> <span class="attr">className</span>=<span class="string">'right'</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">NavItem</span>&gt;</span></span>:<span class="xml"><span class="tag">&lt;<span class="name">NavItem</span> <span class="attr">className</span>=<span class="string">'right'</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">NavItem</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">就可以在页面的头部看到是否处于登陆状态还是退出状态</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来如果用户没有登陆不是显示这个字样 而是跳转到登陆页面</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Link to=<span class="string">'/login'</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">NavItem</span> <span class="attr">className</span>=<span class="string">'right'</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">NavItem</span>&gt;</span></span>&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">回到登陆组件</span></span><br><span class="line"><span class="regexp"> &lt;Button onClick=&#123;() =&gt; this.props.login(this.account, this.password)&#125;&gt;登录&lt;/</span>Button&gt;</span><br><span class="line">因为登陆需要调用ajax接口，把账号密码传递过去的。这时候需要把它写进mapDispatch里 因为要发异步的请求，异步action</span><br><span class="line">只有它才能派发异步action</span><br><span class="line"></span><br><span class="line">&lt;Input placeholder=<span class="string">"账号"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.account = input&#125;&#125; /&gt;</span><br><span class="line">&lt;Input placeholder=<span class="string">"密码"</span> type=<span class="string">"password"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.password = input&#125;&#125; /&gt;</span><br><span class="line">这两句话的意思就是:通过ref把这两个DOM分别存在<span class="keyword">this</span>.account和<span class="keyword">this</span>.password里</span><br><span class="line">这样在登陆的时候就可以调用箭头函数把account和password传进去</span><br><span class="line">之后就是发ajax请求 action reducers 常见的套路 </span><br><span class="line">实现的结果就是输入账号密码之后头部的登陆变成了退出  现在就是要实现点击登陆跳转到首页</span><br><span class="line">重定向到首页 又是版本的问题，之前的重定向Redirect也不能用了</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;loginState&#125; = <span class="keyword">this</span>.props;<span class="comment">//false</span></span><br><span class="line">    <span class="keyword">if</span>(!loginState)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;LoginWrapper&gt;</span><br><span class="line">            &lt;LoginBox&gt;</span><br><span class="line">            &lt;Input placeholder=<span class="string">"账号"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.account = input&#125;&#125; /&gt;</span><br><span class="line">    &lt;Input placeholder=<span class="string">"密码"</span> type=<span class="string">"password"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.password = input&#125;&#125; /&gt;</span><br><span class="line">    &lt;Button onClick=&#123;() =&gt; <span class="keyword">this</span>.props.login(<span class="keyword">this</span>.account, <span class="keyword">this</span>.password)&#125;&gt;登录&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>LoginBox&gt;</span><br><span class="line">    &lt;<span class="regexp">/LoginWrapper&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    &#125;else&#123;</span></span><br><span class="line"><span class="regexp">        return &lt; Navigate  to='/</span><span class="string">' /&gt;</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">之后做退出的功能回到header组件的index.js下</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">     login ?</span><br><span class="line">         &lt;NavItem className=<span class="string">'right'</span>&gt;退出&lt;<span class="regexp">/NavItem&gt;:</span></span><br><span class="line"><span class="regexp">         &lt;Link to='/</span>login<span class="string">'&gt;&lt;NavItem className='</span>right<span class="string">'&gt;登陆&lt;/NavItem&gt;&lt;/Link&gt;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> 在这里添加一个点击事件onClick=&#123;logout&#125;通过调用该回调函数去修改login的值，所以要去派发action</span></span><br><span class="line"><span class="string"> 因为这是在header.js下的 要引用login的action</span></span><br><span class="line"><span class="string">修改数据得到的结果也就是头部的显示结果 就是点击退出的时候上面的退出会改成登陆</span></span><br></pre></td></tr></table></figure>
<p><strong>创建写文章（只有在登陆状态下才能写）</strong></p>
<blockquote>
<p>对于一个组件的实现流程：首先建立writer文件夹下的index.js 把login复制过来，沿用它的一些逻辑</p>
<p>如果登陆了就写文章，如果没有登陆就跳转到登陆见面 然后把这个组件放到APP.js里面 。</p>
<p>同时在头部组件里的一个写文章外部加一个Link 跳转到Writer组件里之后就不做了 </p>
</blockquote>
<p><strong>代码优化</strong></p>
<ol>
<li>在每个方法后面加分号；</li>
<li>在action里发异步请求的时候都默认发成功的请求，在企业级项目都有错误的情况.catch（）异常逻辑进行补充</li>
</ol>
<p><strong>异步组件</strong></p>
<blockquote>
<p>首先点开network组件 JS刷新页面， 跳转页面，登陆页面，都是加载bundle.js，存在一个问题：所有页面对应的组件代码，都是bundle.js，现在访问的是首页，实际上登陆和详情页面的代码一起都加载了，这样首页加载的速度就有点慢。解决问题：当你访问首页的时候，你只加载首页的代码，访问详情页的时候再去加载详情页的代码 使用异步组件来实现，底层比较复杂，但是使用封装起来的第三方模块会非常简单。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm add react-loadable</span><br><span class="line">异步组件的时候会有一个问题如果是v5版本的话</span><br><span class="line">detail下的index.js是有用到params参数的，以前可以直接获取是因为 </span><br><span class="line">因为APP.js里以前引入的Detail组件，路由对应的组件就是这个组件<span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'./pages/detail'</span>;</span><br><span class="line">&lt;Route path=<span class="string">'/detail/:id'</span> exact component=&#123;Detail&#125;&gt;&lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">如果是这样detail可以直接拿到路由信息</span></span><br><span class="line"><span class="regexp">但是现在不一样了引入的是import Detail from './</span>pages/detail/loadable.js<span class="string">';</span></span><br><span class="line"><span class="string">所以loadable.js可以获得所有的路由信息，但是它下面的组件获取不了路由内容，因为它不是Router直接对应的组件</span></span><br><span class="line"><span class="string">箭头所示的就是下面的组件 </span></span><br><span class="line"><span class="string">解决方法就是在index.js组件里加一个withRouter **这是v5的  v6不需要以上操作</span></span><br><span class="line"><span class="string">调用该方法让Detail组件有能力获取到Router里所以的参数和内容</span></span><br><span class="line"><span class="string">export default connect(mapState, mapDispatch)(withRouter(Detail));</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111262208581.png" alt="image-20211126220845485"></p>
<p><strong>注意</strong>：使用jsx语法要引入React</p>
<h2 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h2><p><strong>补充（之前漏看的视频）</strong></p>
<blockquote>
<p>首先在header组件的初始状态定义一个page和totalpage。page的作用是通过页码对内容进行控制，totalpage指的是整体的数据一共有多少页。 通过点击输入框就可以将获取列表，在列表里的action获取到数据后在同步action里面定义总共的页码。</p>
<p>之后在把页面传给reducers，打开reudx点击搜索就可以看到如下获取的列表和总共的页码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后在map方法里获取页码  <span class="string">``</span>  page:state.getIn([<span class="string">'header'</span>,<span class="string">'page'</span>]),<span class="string">``</span></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111271938134.png" alt="image-20211127192232109"></p>
<blockquote>
<p> 之后在map方法里获取页码  <code>page:state.getIn([&#39;header&#39;,&#39;page&#39;]),</code></p>
<p>让它一页显示10个</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;focused,list,page&#125;=<span class="keyword">this</span>.props</span><br><span class="line"><span class="keyword">const</span> pageList=[];</span><br><span class="line"><span class="keyword">const</span> Listpage = list.toJS(); <span class="comment">//因为从props里获取的list是immuable数据类型 该数据类型不能使用Listpage[i]方法，要先转换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=(page<span class="number">-1</span>)*<span class="number">10</span>;i&lt;page*<span class="number">10</span>;i++)&#123;</span><br><span class="line">            pageList.push(</span><br><span class="line">                &lt;SearchInfoItem key=&#123;Listpage[i]&#125;&gt;&#123;Listpage[i]&#125;&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后点击搜索显示的就是10个内容 但是才存在一个问题，点击换一换的时候input框会失焦，一失焦下面的区块就隐藏掉了，什么时候隐藏，其实并不是靠这个input的focus来控制的。实际点击区块的白色部分的时候，已经失焦但是区块不会隐藏，把鼠标移出去的时候才会隐藏。因此下面区块的展示和隐藏并不是完全由focus的状态来决定的还由一个mouseleft和mousemove决定的。</p>
<p>因此再加一个属性   mouseIn:false,，因为一开始鼠标就是没进入这个区块，鼠标移入进去，变成true。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;SearchInfo onMouseEnter=&#123;<span class="keyword">this</span>.props.handleMouseEnter&#125;<span class="comment">//定义一个方法 派发action</span></span><br><span class="line">改变mouseIn:<span class="literal">false</span>,这个的状态</span><br><span class="line">同理再加一个 onMouseLeave=&#123;<span class="keyword">this</span>.props.handleMouseLeave&#125;这个方法</span><br><span class="line">一直我们是通过focus来控制显示还是隐藏，其实现在focus不管用，还得借助mouseIn这个变量一起来控制，因此要从mapstate拿到mouseIn</span><br><span class="line"><span class="keyword">if</span>(focused||mouseIn)如果mouseIn为<span class="literal">true</span>也显示</span><br><span class="line">下面就是点击换一换 下面的内容也要跟着变</span><br><span class="line">定义方法onClick=&#123;<span class="keyword">this</span>.props.handleChangePage&#125;</span><br><span class="line">handleChangePage()&#123;</span><br><span class="line">            dispatch(changePage())<span class="comment">//派发action</span></span><br><span class="line">        &#125;,</span><br><span class="line">之后就是修改page的状态由于状态修改page不能直接加<span class="number">1</span></span><br><span class="line">因此还要获取totalPage的状态</span><br><span class="line"> handleChangePage(page,totalPage)&#123;</span><br><span class="line">  <span class="keyword">if</span>(page&lt;totalPage)&#123;</span><br><span class="line">      dispatch(changePage(page+<span class="number">1</span>))</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dispatch(changePage(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">把这个函数设为箭头函数之后把page和totalpage传进去之后进行判断 之后去修改状态即可</span><br><span class="line">但是还是会报错原因就是输出<span class="keyword">for</span>循环的时候输出的是<span class="literal">undefined</span>。原因是因为当你刚进入页面的时候，header就会被渲染，初始顺序就是list是个空，page是个<span class="number">1</span>， 然后<span class="keyword">for</span>循环一定会执行，所以会循环<span class="number">1</span>到<span class="number">9</span> 但是list是一个空数组，那么空数组list[<span class="number">0</span>]都是<span class="literal">undefined</span></span><br><span class="line">那么key就是<span class="literal">undefined</span>。 因此外层要包裹一个<span class="keyword">if</span>判断</span><br><span class="line"> <span class="keyword">if</span>(pageList.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=(page<span class="number">-1</span>)*<span class="number">10</span>;i&lt;page*<span class="number">10</span>;i++)&#123;</span><br><span class="line">                pageList.push(</span><br><span class="line">                    &lt;SearchInfoItem key=&#123;Listpage[i]&#125;&gt;&#123;Listpage[i]&#125;&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">                )</span></span><br><span class="line"><span class="regexp">            &#125; </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后点换一换的时候让i标签的动画动一下</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;SearchInfoSwitch</span><br><span class="line">    onClick=&#123;()=&gt;handleChangePage(page,totalPage,<span class="keyword">this</span>.spinIcon)&#125;</span><br><span class="line">  &gt;</span><br><span class="line">				<span class="comment">//将this.spinIcon传进onClick方法</span></span><br><span class="line">    &lt;i ref=&#123;(icon)=&gt;&#123;this.spinIcon = icon&#125;&#125; className="iconfont spin"&gt;&amp;#xe675;&lt;/i&gt;</span><br><span class="line">            换一批</span><br><span class="line"> &lt;<span class="regexp">/SearchInfoSwitch&gt;</span></span><br></pre></td></tr></table></figure>
<p>之前换一批图标功能未实现，且iconfont图标在下侧，原因是因为之前设置的iconfont样式覆盖了它</p>
<p>只要把之前的iconfont样式改成zoom即可</p>
<p>当你点击换一批的时候，我们希望i标签的值发生变化， 有一个ref的内容可以回去i标签真实的DOM节点</p>
<p> 之后把相应的值传进，之后在方法下方输出spin 控制台就会输出</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111280949745.png" alt="image-20211128094949731"></p>
<p>就获取到spin对应的DOM了</p>
<pre><code>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spin.style.transform=<span class="string">'rotate(360deg)'</span>;<span class="comment">//当你点击的时候就会旋转360 但是只会执行一次因为是转360</span></span><br><span class="line">可以获取上一次旋转的角度之后每一次加<span class="number">360</span>度 下一次就是<span class="number">720</span>度</span><br><span class="line"> 使用单纯CSS transition动画效果来实现</span><br><span class="line"> <span class="keyword">let</span> originAngle = spin.style.transform.replace(<span class="regexp">/[^0-9]/ig</span>,<span class="string">''</span>)<span class="comment">//不是0-9的数字都替换为空</span></span><br><span class="line">     <span class="keyword">if</span>(originAngle)&#123;</span><br><span class="line">         originAngle=<span class="built_in">parseInt</span>(originAngle,<span class="number">10</span>)</span><br><span class="line">     &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         originAngle=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    spin.style.transform=<span class="string">'rotate('</span>+(originAngle+ <span class="number">360</span>)+<span class="string">'deg)'</span><span class="comment">//0-360  360-720都会有过渡效果</span></span><br><span class="line">react是面向数据编程，最难的是在redux里如何对数据进设计</span><br></pre></td></tr></table></figure>
</code></pre><hr>
<p><strong>1、react是面向数据编程，最难的是在redux里的数如何的被设计</strong></p>
<hr>
<p><strong>2、改变它里面的数据，遵循redux里单向数据流的流程，首先先派发action给store，store再给reducers，reducers返回一个新的数组再给store，store去变更自己的内容，当数据发生变更，页面就自动发生变化了。</strong></p>
<h2 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h2><p><strong>简书项目上线</strong></p>
<p>首先在后端的htdocs文件夹下创建一个api文件夹，后端的人在api文件夹下的json所各种复杂的运算处理，然后前端就可以将简书项目public文件夹下的api文件夹删除了，因为开发要做接口的模拟，然后在控制台运行npm run build，就会生成一个build文件夹，在build目录下有很多项目需要上线的文件，把build下的所有文件复制粘贴至htdocs文件夹下（和api一个同级）这样就完成了项目的上线。</p>
<p>整体的流程就是将前端的代码拷贝到后端的项目，访问的也就是后端的项目（访问路径就是之前的一个软件XAMPP）。</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111281533623.png" alt="image-20211128153306716"></p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111281530997.png" alt="image-20211128153010553"></p>
<p>点start就可以在本地启动一个服务器（启动一个Apache服务器），会启动在localhost：80端口上（可以简写localhost）</p>
<h2 id="完美撒花"><a href="#完美撒花" class="headerlink" title="完美撒花"></a>完美撒花</h2><ol>
<li>react的基础语法</li>
<li>redux数据层框架</li>
<li>react-redux如何方便我们在react之中使用redux</li>
<li>react-router（本课程用的是4.0的版本 而我采用的是6.0天呐）</li>
<li>immuable.js 相关的第三方模块</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/" class="post-title-link" itemprop="url">前端面试题总结</a>
        </h2>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-22T00:00:00+08:00">2021-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前端面试题（每日10道）"><a href="#前端面试题（每日10道）" class="headerlink" title="前端面试题（每日10道）"></a>前端面试题（每日10道）</h1><h2 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h2><h3 id="1-CSS盒模型"><a href="#1-CSS盒模型" class="headerlink" title="1.CSS盒模型"></a>1.CSS盒模型</h3><p>（1）用来装页面上的元素的矩形区域。由内容区、内边距、边框、外边距四部分组成</p>
<p>（2）CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型，盒子的宽度时存在着差异</p>
<p>​            在标准的盒子模型中，宽度指内容区部分的宽度，</p>
<p>​            在IE盒子模型中，宽度表示内容区，内边距，边框这三个部分的宽度</p>
<p>（3） 在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型</p>
<p><strong>补充</strong></p>
<ul>
<li><p>边框和内边距的设置会影响到盒子的大小，外边距的设置不会影响盒子可见框的大小，但是会影响盒子的位置，从而影响盒子实际占用空间</p>
</li>
<li><p>一个元素在其父元素中,水平布局必须要满足以下的等式：左右外边距+左右内边距+左右边框+本身宽度=父元素内容区的宽度</p>
<p>如果这七个值中没有为 auto 的情况，则浏览器会自动调整margin-right值以使等式满足 如果超过800 就margin-right=-200</p>
<p>这七个值中有三个值可以设置成auto，width、margin-left、 maring-right，调整相应的auto以使等式成立 宽度优先级最高</p>
</li>
<li><p>如果子元素的大小超过了父元素，则子元素会从父元素中溢出，使用overflow属性来设置父元素如何处理溢出的子元素 </p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可选值:（1）visible，默认值子元素会从父元素中溢出，在父元素外部的位置显示。</span><br><span class="line">   （2）hidden 溢出内容将会被裁剪不会显示        </span><br><span class="line">  	   （3）scroll生成两个滚动条,通过滚动条来查看完整的内容 </span><br><span class="line">         （4）auto根据需要生成滚动条</span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直外边距的重叠（如下图绿色方块的下外边距设置100px与橙色方块上外边距设置100px重叠了) ：相邻的垂直方向外边距会发生重叠现象</p>
<ul>
<li><p>兄弟元素外边距的重叠：兄弟元素间的相邻垂直外边距会取两者之间的较大值一正一负，则取两者的和    如果相邻的外边距都是负值，则取两者中绝对值较大的   </p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151506013.png" alt="image-20211115145746032"></p>
</li>
<li><p>父子元素外边距的重叠（如下图给子元素设置上外边距100px，结果将其属性传至父元素让父元素下移）：父子元素间相邻外边距，子元素的会传递给父元素（上外边距)</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151507725.png" alt="image-20211115150739964"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-居中垂直对齐"><a href="#2-居中垂直对齐" class="headerlink" title="2.居中垂直对齐"></a>2.居中垂直对齐</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单行文本: line-height = height</span><br><span class="line">图片: vertical-align: middle;</span><br><span class="line">absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);前半部分指的是相对于物体居中但是物体本身有尺寸</span><br><span class="line">display:flex;margin:auto</span><br></pre></td></tr></table></figure>
<h3 id="3-点击按钮使得页面上的文字颜色发生改变如何实现"><a href="#3-点击按钮使得页面上的文字颜色发生改变如何实现" class="headerlink" title="3.点击按钮使得页面上的文字颜色发生改变如何实现"></a>3.点击按钮使得页面上的文字颜色发生改变如何实现</h3><p>​        首先创建一个button按钮，绑定一个onclick点击事件，对需要显示的区域设置大小和颜色(下图代码红绿交替显示)</p>
<p>​        当点击按钮的时候调用该点击事件从而改变页面上的文字颜色（调用事件的时候要获取显示区域的id）</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151600893.png" alt="image-20211115160026280"></p>
<h3 id="4-html小知识"><a href="#4-html小知识" class="headerlink" title="4.html小知识"></a>4.html小知识</h3><p>​    （1）html 语义化让页面的内容结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并      且是容易阅读的;</p>
<p>​    （2）alt 是给搜索引擎识别，在图像无法显示时的替代文本；title 是关于元素的注释信息，主要是给用户解读。</p>
<p>​    （3） iframe标签是在当前网页插入一个指定的页面   —内联框架</p>
<p>​                优点：解决加载缓慢的第三方内容如图标或者广告等的加载问题</p>
<p>​                缺点：iframe标签会阻塞主页面的onload事件</p>
<p>​    （4）href 指向网络资源所在位置  src 会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；</p>
<p>​    （5）去除项目中符号：list-style：none 去除浏览器的默认样式使用重置样式表，专门用来对浏览器的样式进行重置</p>
<p>​    （6）开启定位的元素层级会提升且层级一样，z-index属性来指定元素的层级用整数表示，可以高于定位的层级，值越大元素的层级越              高如果元素的层级一样，则优先显示靠下的元素，祖先元素的层级再高也不会盖住后代元素（祖先z-index&gt;后代定位）。</p>
<p>​    （7）text-align文本的水平对齐 可选值:    left左侧对齐    right右对齐    center居中对齐    justify 两端对齐 </p>
<p>​    （8）vertical-align 设置元素垂直对齐的方式  用于消除图片的缝</p>
<p>​    （9）background-image设置背景图片 background-repeat用来设置背景的重复方式 background-position用来设置背景图片的位置</p>
<p>  （10）:link用来表示没访问过的链接 :visited用来表示访问过的链接</p>
<p>  （11）线性渐变，颜色沿着一条直线发生变化 linear-gradient()；</p>
<p>  （12）径向渐变，(放射性的效果) radial-gradient()</p>
<p>​     (13) 表格：table标签来创建一个表格 colspan横向的合并单元格。table虽说是块元素，但是宽度是被内容撑开的。</p>
<p>​                — 以将一个表格分成三个部分: 头部 thead 主体 tbody 底部 tfoot </p>
<p>  （14）使用form标签来创建一个表单 单选按钮   <!--单选按钮-->   <!--多选按钮--><!--重置按钮--></p>
<h3 id="5-CSS选择器的优先级"><a href="#5-CSS选择器的优先级" class="headerlink" title="5.CSS选择器的优先级"></a>5.CSS选择器的优先级</h3><p><strong>不同级别</strong></p>
<ol>
<li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p>
</li>
<li><p>作为style属性写在元素内的样式（行类样式） 权值1000</p>
</li>
<li><p>id选择器 100</p>
</li>
<li><p>类选择器 10</p>
</li>
<li><p>标签选择器 1</p>
</li>
<li><p>通配符选择器</p>
</li>
<li><p>浏览器自定义或继承</p>
</li>
<li><p>贩卖人间快乐:<br>生命周期。 </p>
<p>贩卖人间快乐:<br>双向绑定</p>
</li>
<li><p><strong>选择器的累加不会超过其最大的数量级，类选择器在再高也不会超过id选择器</strong></p>
</li>
</ol>
<h3 id="6-简明说一下-CSS-link-与-import-的区别和用法？"><a href="#6-简明说一下-CSS-link-与-import-的区别和用法？" class="headerlink" title="6.简明说一下 CSS link 与 @import 的区别和用法？"></a>6.简明说一下 CSS link 与 @import 的区别和用法？</h3><pre><code>1. link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。
2. link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。
3. link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。
</code></pre><h3 id="7-display-none和visibility-hidden的区别？"><a href="#7-display-none和visibility-hidden的区别？" class="headerlink" title="7.display:none和visibility:hidden的区别？"></a>7.display:none和visibility:hidden的区别？</h3><ul>
<li>display:none 元素不在页面中显示，不占据页面的位置。</li>
<li>visibility:hidden 元素在页面中隐藏不显示，但是依然占据页面的位置。 </li>
</ul>
<h3 id="8-rgba和opacity的透明效果有什么不同？"><a href="#8-rgba和opacity的透明效果有什么不同？" class="headerlink" title="8.rgba和opacity的透明效果有什么不同？"></a>8.rgba和opacity的透明效果有什么不同？</h3><blockquote>
<p>opacity 会继承父元素的 opacity 属性，而 RGBA 不会。</p>
</blockquote>
<h3 id="9-position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#9-position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="9.position的值， relative和absolute分别是相对于谁进行定位的？"></a>9.position的值， relative和absolute分别是相对于谁进行定位的？</h3><ul>
<li>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。</li>
<li>absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。</li>
<li>fixed: （老版本IE不支持）固定定位。</li>
<li>static:默认值，没有定位，元素出现在正常的文档流中。</li>
</ul>
<h3 id="10-BFC-是什么？"><a href="#10-BFC-是什么？" class="headerlink" title="10. BFC 是什么？"></a>10. BFC 是什么？</h3><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)根元素(<span class="tag">&lt;<span class="name">html</span>&gt;</span>)</span><br><span class="line">(2)浮动元素：float 除 none 以外的值  有局限性：高度不塌了但是脱离文档流了，宽度也就丢失了，对应特点的第三条 -不推荐</span><br><span class="line">(3)绝对定位元素：position (absolute、fixed)</span><br><span class="line">(4)display 为 inline-block、table-cells、flex -不推荐</span><br><span class="line">(5)overflow 除了 visible 以外的值 (hidden、auto、scroll) -推荐</span><br></pre></td></tr></table></figure>
<ul>
<li><p>之前不会塌是因为把高度写死了所以不会塌 现在父元素不设置高低 子元素高度为多少父元素就会被撑开多少</p>
</li>
<li><p>高度塌陷的问题: 在浮动布局中,父元素的高度默认是被子元素撑开的 当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离 将会无法撑起父元素的高度，导致父元素的高度丢失 父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱 所以高度塌陷是浮动布局中比较常见的一个问题。</p>
</li>
<li><p>开启BFC后的特点：</p>
<p>​       1.开启BFC的元素不会被浮动元素所覆盖</p>
<p>​       2.开启BFC的元素子元素和父元素外边距不会重叠 </p>
<p>​       3.开启BFC的元素可以包含浮动的子元素 </p>
<p> -常用的方式为元素设置 overflow:hidden 开启其BFC以使其可以包含浮动元素 高度不塌，宽度也不会丢失。</p>
</li>
</ul>
<h2 id="11-16"><a href="#11-16" class="headerlink" title="11.16"></a>11.16</h2><h3 id="11-doctype-的作用-声明版本"><a href="#11-doctype-的作用-声明版本" class="headerlink" title="11.doctype 的作用 声明版本"></a>11.doctype 的作用 声明版本</h3><blockquote>
<p>&lt;!DOCTYPE&gt;是一个用于声明当前HTMl版本，用来告知web浏览器该文档使用是哪种 HTML 或者 XHTML 规范来解析页面，以便浏览器更加准确的理解页面内容，更加良好地展现内容效果！</p>
</blockquote>
<h3 id="12-语义化标签的理解"><a href="#12-语义化标签的理解" class="headerlink" title="12.语义化标签的理解"></a>12.语义化标签的理解</h3><ol>
<li>即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构。</li>
<li>语义化标签会使HTML结构变的清晰，有利于维护代码和添加样式。</li>
<li>和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息</li>
<li>同时与计算机的编译也存在一定的联系</li>
</ol>
<h3 id="13-important-有什么不好"><a href="#13-important-有什么不好" class="headerlink" title="13.important 有什么不好"></a>13.important 有什么不好</h3><blockquote>
<p>css定义中的用!important样式权重是最高的，会覆盖页面内任何位置定义的元素样式，有时候程序员忘了删除，这样就会导致自己设置的样式无法显示的问题。</p>
</blockquote>
<h3 id="14-css-选择器的解析顺序，原因"><a href="#14-css-选择器的解析顺序，原因" class="headerlink" title="14. css 选择器的解析顺序，原因"></a>14. css 选择器的解析顺序，原因</h3><blockquote>
<p>解析顺序：从右往左，</p>
<p>原因：从右往左进行解析的好处那就是从右往左进行匹配的时候，匹配的全部是DOM元素的父节点，而从左往右进行匹配的时候时候，匹配的全部是DOM元素的子节点，这样就避免了HTML与CSS没有下载完需要进行等待的情形。且遍历查找的节点都会少很多</p>
</blockquote>
<h3 id="15-css-清除浮动"><a href="#15-css-清除浮动" class="headerlink" title="15.css 清除浮动"></a>15.css 清除浮动</h3><p><strong>1清除浮动的第一种方式—给父级盒子添加高度</strong></p>
<blockquote>
<p>造成高度塌陷的原因就是父元素没有高度，我们只需要给父元素添加一个高度即可，但是这种方式并不推荐使用，因为有很多局限性，况且子元素依然是脱离标准流，并没有回到父元素中，此时父元素的宽度变化了。</p>
</blockquote>
<p><strong>2添加clear属性来清除浮动元素对当前元素所产生的影响**</strong></p>
<ol>
<li><p>可选值：</p>
<p>​    left清除左侧浮动元素对当前元素的影响 原来浮动的元素依然浮动 </p>
<p>​    right清除右侧浮动元素对当前元素的影响 </p>
<p>​    both 清除两侧中最大影响的那侧（类似高度的问题）</p>
</li>
<li><p>原理: 设置清除浮动以后，浏览器会自动为元素添加一个上外边距， 以使其位置不受其他元素的影响。</p>
</li>
</ol>
<p><strong>3.清除浮动的第三种方式—给父级添加overflow属性*</strong></p>
<blockquote>
<p>原理见16题</p>
</blockquote>
<p><strong>4.清除浮动的第四种方式—给父级添加after伪元素</strong></p>
<ul>
<li><p>利用after伪元素定义一个clearfix类，浮动元素的父级元素调用此类可以实现清除浮动的效果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.clearfix: : before,		//内边距重叠</span><br><span class="line">.clearfix: : after&#123;			//高度塌陷</span><br><span class="line">		content: ''; </span><br><span class="line">		display: table;//table就相当于一个物体隔开他们俩让他们的外边距不重合</span><br><span class="line">		clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="16-overflow-hidden-是怎么清除浮动的"><a href="#16-overflow-hidden-是怎么清除浮动的" class="headerlink" title="16. overflow:hidden 是怎么清除浮动的"></a>16. overflow:hidden 是怎么清除浮动的</h3><blockquote>
<p>父块没有设置指定的高宽，当子块设置为浮动后，原本包裹子块的父块的高度塌陷消失，这时给父块设置overflow:hidden就会为父块设置一个独立的块级上下文，使这个块级元素内部的排版完全独立，从而可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，这样就达到了清除浮动的效果，，使父块重新包裹子块。</p>
</blockquote>
<h3 id="17-HTML5、CSS3-里面都新增了那些新特性？"><a href="#17-HTML5、CSS3-里面都新增了那些新特性？" class="headerlink" title="17.HTML5、CSS3 里面都新增了那些新特性？"></a>17.HTML5、CSS3 里面都新增了那些新特性？</h3><p><strong>HTML5</strong> </p>
<ul>
<li>新的语义标签<ul>
<li>article 独立的内容。</li>
<li>aside 侧边栏。</li>
<li>header 头部。</li>
<li>nav 导航。</li>
<li>section 文档中的节。</li>
<li>footer 页脚。</li>
</ul>
</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>拖拽释放(Drag and drop) API</li>
<li>音频、视频API(audio,video)</li>
<li>表单控件，calendar、date、time、email、url、searc</li>
</ul>
<p><strong>CSS3</strong></p>
<ul>
<li>2d，3d变换</li>
<li>Transition, animation</li>
<li>媒体查询</li>
<li>新的单位（rem, vw，vh 等）</li>
<li>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</li>
<li>rgba</li>
</ul>
<h3 id="18-常见兼容性问题？"><a href="#18-常见兼容性问题？" class="headerlink" title="18. 常见兼容性问题？"></a>18. 常见兼容性问题？</h3><blockquote>
<p> 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
</blockquote>
<h3 id="19-固定定位和绝对定位的区别"><a href="#19-固定定位和绝对定位的区别" class="headerlink" title="19.固定定位和绝对定位的区别"></a>19.固定定位和绝对定位的区别</h3><p>fixed :固定 定位 absolute :绝对 定位 区别 ： 1、<strong>没有滚动条的情况下没有差异</strong> 2、在有滚动条的情况下， fixed定位 不会随滚动条移动而移动，而 absolute 则会随滚动条移动 </p>
<h3 id="20-实现一个两列固定，中间自适应有哪些方法"><a href="#20-实现一个两列固定，中间自适应有哪些方法" class="headerlink" title="20.实现一个两列固定，中间自适应有哪些方法"></a>20.实现一个两列固定，中间自适应有哪些方法</h3><ol>
<li><p>使用flex通过改变 <code>flex-grow</code>和 <code>flex-shrink</code>实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        height: 100vh;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: row;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: lightskyblue;</span><br><span class="line">        word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 左右固定长度 */</span></span></span><br><span class="line">        flex-basis: 100px;</span><br><span class="line"><span class="css">        <span class="comment">/* 将增长比和缩小比都设置为 0 ,避免宽度变化 */</span></span></span><br><span class="line">        flex-grow: 0;</span><br><span class="line">        flex-shrink: 0;</span><br><span class="line">        background-color: lightslategray;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 中间自动适应 */</span></span></span><br><span class="line">        flex-grow: 1;</span><br><span class="line">        flex-shrink: 1;</span><br><span class="line">        background-color: lightpink;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对定位+CSS3新盒子 (利用新盒子 width = content + padding + border 特性 🎈)</p>
   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">     body&#123;</span><br><span class="line">         height: 100vh;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">         position: relative;</span><br><span class="line">         height: 200px;</span><br><span class="line">         background-color: lightskyblue;</span><br><span class="line">         word-break: break-all;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="comment">/* 使用绝对定位来控制元素 */</span></span></span><br><span class="line">         position: absolute;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">         height: 200px;</span><br><span class="line">         width: 100px;</span><br><span class="line">         background-color: lightslategray;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">         right: 0;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="comment">/* 控制padding来放置两侧元素, content宽度会自动计算 */</span></span></span><br><span class="line">         box-sizing: border-box;</span><br><span class="line">         height: 100%;</span><br><span class="line">         width: 100%;</span><br><span class="line"><span class="css">         <span class="comment">/* 两端填充100px, 用来放两侧固定元素 */</span></span></span><br><span class="line">         padding: 0 100px;</span><br><span class="line">         background-color: lightpink;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h2><h3 id="21-伪类选择器和伪元素理解以及区别-可以使用伪类选择器实现隔行变色效果"><a href="#21-伪类选择器和伪元素理解以及区别-可以使用伪类选择器实现隔行变色效果" class="headerlink" title="21.伪类选择器和伪元素理解以及区别(可以使用伪类选择器实现隔行变色效果)"></a>21.伪类选择器和伪元素理解以及区别(可以使用伪类选择器实现隔行变色效果)</h3><p>   <strong>伪类（不存在的类，特殊的类),伪类用来描述一个元素的特殊状态 比如:第一个子元素、被点击的元素、鼠标移入的元素…</strong></p>
<ul>
<li><p>: nth-child()选中第n个子元素</p>
</li>
<li><p>: nth-of-type() 同类型元素中进行排序</p>
<p><strong>伪元素，表示页面中一些特殊的并不真实存在的元素（特殊的位置)</strong>     </p>
<blockquote>
<p>::before元素的最开头 ::after元素的最后    - before和 after必须结合content属性来使用</p>
</blockquote>
<h3 id="22-em和rem"><a href="#22-em和rem" class="headerlink" title="22.em和rem"></a>22.em和rem</h3><p><strong>em是相对于元素的字体大小来计算的</strong></p>
<p><strong>rem是相对于根元素的字体大小来计算 —类似于全局变量</strong></p>
<h3 id="23-我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现"><a href="#23-我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现" class="headerlink" title="23.我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现"></a>23.我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现</h3></li>
</ul>
</li>
</ol>
<p><strong>使用Promise.all</strong></p>
<ol>
<li><p>当有一个ajax请求时，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</p>
</li>
<li><p>Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。</p>
</li>
</ol>
<p><strong>promise补充</strong></p>
<ol>
<li>现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。</li>
<li>Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。</li>
<li>then方法的执行结果也会返回一个Promise对象。因此我们可以进行then的链式执行，这也是解决回调地狱的主要方式。</li>
</ol>
<h3 id="24-setTimeout-和-Promise-哪一个先执行"><a href="#24-setTimeout-和-Promise-哪一个先执行" class="headerlink" title="24.setTimeout 和 Promise 哪一个先执行"></a>24.setTimeout 和 Promise 哪一个先执行</h3><blockquote>
<p> Promise比setTimeout()先执行。因为Promise定义之后便会立即执行，其后的.then()是异步里面的微任务。而setTimeout()是异步的宏任务。</p>
</blockquote>
<h3 id="25-canvas-的一些方法"><a href="#25-canvas-的一些方法" class="headerlink" title="25.canvas 的一些方法"></a>25.canvas 的一些方法</h3><ol>
<li>第一是以drawXXX为主的绘制方法； 例如drawColor：填充颜色</li>
<li>第二是以clipXXX为主的裁剪方法；    例如clipRect：当前画布裁剪为一个矩形</li>
<li>第三是以scale、translate和rotate组成的Canvas变换方法；</li>
<li>最后一类save：将当前的状态推送至栈中保存   restore：将上次保存的状态从栈中弹出；</li>
</ol>
<h3 id="26-font-face"><a href="#26-font-face" class="headerlink" title="26.@font-face"></a>26.@font-face</h3><p><strong>font-face是css3中允许使用自定义字体的一个模块。<em>@ font-face</em>的是一个CSS规则，允许你输入自己的字体出现在网站上**</strong></p>
<h3 id="27-transform-有哪些属性"><a href="#27-transform-有哪些属性" class="headerlink" title="27.transform 有哪些属性"></a>27.transform 有哪些属性</h3><p><strong>transform属性值：</strong></p>
<ul>
<li><p>transform: translate():  translate()的括号内包含两个值，分别为相对于元素原有位置在水平方向和垂直方向的偏移值</p>
</li>
<li><p>transform:rolate():  正值为顺时针，负值为逆时针，单位为deg。</p>
</li>
<li><p>transform:transform-origin:任何一个元素都有一个中心点，默认情况之下，其中心点是居于元素X轴和Y轴的50%处。</p>
</li>
<li><p>transform:scale():   scale(x,y):x,y 值分别为原有元素宽高的倍数。 1为不缩放，大于1放大，小于1缩小。</p>
</li>
</ul>
<h3 id="28-轮播图的原理"><a href="#28-轮播图的原理" class="headerlink" title="28.轮播图的原理"></a>28.轮播图的原理</h3><p><strong>图片移动实现原理：</strong></p>
<p>利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制left属性，实现照片的移动。</p>
<h3 id="29-雪碧图的使用步骤"><a href="#29-雪碧图的使用步骤" class="headerlink" title="29.雪碧图的使用步骤"></a>29.雪碧图的使用步骤</h3><ol>
<li>先确定要使用的图标 </li>
<li>测量图标的大小 </li>
<li>根据测量结果创建一个元素 </li>
<li>将雪碧图设置为元素的背景图片 </li>
<li>设置一个偏移量以显示正确的图片 </li>
</ol>
<h3 id="30-js基本数据类型"><a href="#30-js基本数据类型" class="headerlink" title="30.js基本数据类型"></a>30.js基本数据类型</h3><p>数据类型主要包括两部分：</p>
<ul>
<li>基本数据类型： Undefined、Null、Boolean、Number 和 String</li>
<li>引用数据类型： Object (包括 Object 、Array 、Function)</li>
</ul>
<h2 id="11-18"><a href="#11-18" class="headerlink" title="11.18"></a>11.18</h2><h3 id="31-判断一个值是什么类型有哪些方法？"><a href="#31-判断一个值是什么类型有哪些方法？" class="headerlink" title="31.判断一个值是什么类型有哪些方法？"></a>31.判断一个值是什么类型有哪些方法？</h3><ul>
<li>typeof 运算符</li>
<li>instanceof 运算符</li>
<li>Object.prototype.toString 方法</li>
</ul>
<h3 id="32-null-和-undefined-的区别？"><a href="#32-null-和-undefined-的区别？" class="headerlink" title="32. null 和 undefined 的区别？"></a>32. null 和 undefined 的区别？</h3><p>null 表示一个对象被定义了，值为“空值”；<br>undefined 表示不存在这个值：<br>    （1）变量被声明了，但没有赋值时，就等于undefined。 </p>
<p>​    （2)  调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>​    （3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>​    （4）函数没有返回值时，默认返回undefined。</p>
<h3 id="33-js小知识"><a href="#33-js小知识" class="headerlink" title="33.js小知识"></a>33.js小知识</h3><ol>
<li><p>==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型；</p>
<p>===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p>
</li>
<li><p>eval是把对应的字符串解析成 JS 代码并运行；</p>
</li>
<li><p>var 存在变量提升; let 只能在块级作用域内访问; const 用来定义常量，必须初始化，不能修改（对象特殊）</p>
</li>
<li><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</p>
</li>
</ol>
<h3 id="34-箭头函数有哪些特点？"><a href="#34-箭头函数有哪些特点？" class="headerlink" title="34. 箭头函数有哪些特点？"></a>34. 箭头函数有哪些特点？</h3><blockquote>
<p>不需要function关键字来创建函数<br>省略return关键字<br>改变this指向</p>
</blockquote>
<h3 id="35-new操作符具体干了什么呢？"><a href="#35-new操作符具体干了什么呢？" class="headerlink" title="35.new操作符具体干了什么呢？"></a>35.new操作符具体干了什么呢？</h3><p>1、创建一个空对象，新创建的对象由 this 所引用，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。</p>
<h3 id="36-documen-write-和-innerHTML-的区别？"><a href="#36-documen-write-和-innerHTML-的区别？" class="headerlink" title="36.documen.write 和 innerHTML 的区别？"></a>36.documen.write 和 innerHTML 的区别？</h3><ul>
<li>document.write 只能重绘整个页面</li>
<li>innerHTML 可以重绘页面的一部分</li>
</ul>
<h3 id="37-ajax过程"><a href="#37-ajax过程" class="headerlink" title="37.ajax过程"></a>37.ajax过程</h3><ol>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应HTTP请求状态变化的函数.</li>
<li>发送HTTP请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用JavaScript和DOM实现局部刷新</li>
</ol>
<h3 id="38-请解释一下-JavaScript-的同源策略？"><a href="#38-请解释一下-JavaScript-的同源策略？" class="headerlink" title="38.请解释一下 JavaScript 的同源策略？"></a>38.请解释一下 JavaScript 的同源策略？</h3><p>同源策略指的是：协议，域名，端口相同。</p>
<p>同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h3 id="39-介绍一下闭包和闭包常用场景？"><a href="#39-介绍一下闭包和闭包常用场景？" class="headerlink" title="39.介绍一下闭包和闭包常用场景？"></a>39.介绍一下闭包和闭包常用场景？</h3><ul>
<li>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数</li>
<li>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。</li>
<li>闭包有三个特性：<ul>
<li>函数嵌套函数</li>
<li>函数内部可以引用外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
<li>应用场景，设置私有变量的方法</li>
<li>不适用场景：返回闭包的函数是个非常大的函数</li>
<li>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</li>
</ul>
<h3 id="40-JavaScript原型，原型链-有什么特点？"><a href="#40-JavaScript原型，原型链-有什么特点？" class="headerlink" title="40,JavaScript原型，原型链 ? 有什么特点？"></a>40,JavaScript原型，原型链 ? 有什么特点？</h3><ul>
<li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br>于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li>
<li>关系：instance.constructor.prototype = instance.<strong>proto</strong></li>
<li>特点：<br>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li>
</ul>
<h2 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h2><h3 id="41-javascript的内存-垃圾-回收机制？"><a href="#41-javascript的内存-垃圾-回收机制？" class="headerlink" title="41.javascript的内存(垃圾)回收机制？"></a>41.javascript的内存(垃圾)回收机制？</h3><ul>
<li><p>垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存</p>
</li>
<li><p>一般使用<strong>标记清除方法(mark and sweep)</strong>, 当变量进入环境标记为进入环境，离开环境标记为离开环境<br>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p>
</li>
<li>还有<strong>引用计数方法(reference counting)</strong>, 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</li>
<li>在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。</li>
</ul>
<h3 id="42-如何解决-ES6-的语法兼容"><a href="#42-如何解决-ES6-的语法兼容" class="headerlink" title="42. 如何解决 ES6 的语法兼容"></a>42. 如何解决 ES6 的语法兼容</h3><blockquote>
<ol>
<li><p>对于浏览器解析不了es6的语法，需要我们使用babel工具链</p>
</li>
<li><p>对于不支持let等语法的情况下可以采用</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="comment">//严格模式</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="43-ES6的一些东西"><a href="#43-ES6的一些东西" class="headerlink" title="43.ES6的一些东西"></a>43.ES6的一些东西</h3><ol>
<li>新增了<code>let</code>、<code>const</code> <code>let</code>和<code>const</code>具有块级作用域，不存在变量提升的问题，<code>var</code> 声明的变量作用域为包围它的函数。</li>
<li>新增了箭头函数，简化了定义函数的写法，同时可以巧用箭头函数的this、（注意箭头函数本身没有this,它的this取决于外部的环境）</li>
<li>新增了promise解决了回调地域的问题</li>
<li>新增了模块化、利用import 、export来实现导入、导出</li>
<li>let的用法：定义变量 </li>
<li>箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定</li>
</ol>
<h3 id="44-如何解决js浮点数运算精度问题"><a href="#44-如何解决js浮点数运算精度问题" class="headerlink" title="44.如何解决js浮点数运算精度问题"></a>44.如何解决js浮点数运算精度问题</h3><p>问题:整数和浮点数都属于 <code>Number</code> 数据类型，所有数字都是以 64 位浮点数形式储存，即便整数也是如此。 所以我们在打印 <code>1.00</code> 这样的浮点数的结果是 <code>1</code> 而非 <code>1.00</code> 。</p>
<p>解决方法:</p>
<ol>
<li><p>利用toFixed() 方法用定点表示法来格式化一个数，会对结果进行四舍五入，对计算结果进行精度缩小。(不过还是存在精度问题)</p>
</li>
<li><p>或者直接用第三方帮你封装好处理浮点数的库，直接可以用。 如：number-precision</p>
</li>
</ol>
<h3 id="45-requestanimationframe-有用过吗？知道是干嘛的吗"><a href="#45-requestanimationframe-有用过吗？知道是干嘛的吗" class="headerlink" title="45.requestanimationframe 有用过吗？知道是干嘛的吗"></a>45.requestanimationframe 有用过吗？知道是干嘛的吗</h3><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
<h3 id="46-new操作符的过程"><a href="#46-new操作符的过程" class="headerlink" title="46.new操作符的过程"></a>46.new操作符的过程</h3><p> <strong>具体主要有4个部分</strong></p>
<p> 1.创建了一个新对象</p>
<p> 2.把这个新对象的原型属性（proto）绑定到原函数的prototype属性（就是继承原函数原型）</p>
<p> 3.把原函数的this指向转移到这个新对象上</p>
<p> 4.返回新对象，如果这个函数没有返回其他对象的话</p>
<h3 id="47-数组的一些方法"><a href="#47-数组的一些方法" class="headerlink" title="47.数组的一些方法"></a>47.数组的一些方法</h3><p>具体详解可以看<a href="https://blog.csdn.net/jjw_zyfx/article/details/95970780" target="_blank" rel="noopener">数组方法</a>）</p>
<ol>
<li><p>map方法的使用 相当于循环遍历每一项然后可以对每一项进行修改</p>
</li>
<li><p>filter的用法 过滤掉不符合条件的,剩下符合条件的</p>
</li>
<li>join方法的使用 数组变字符串</li>
<li>split方法的使用 字符串变数组</li>
<li>splice(1,1)删除的用法 删除下标为1的1个元素</li>
</ol>
<h3 id="48-call-apply-的区别"><a href="#48-call-apply-的区别" class="headerlink" title="48.call apply 的区别"></a>48.call apply 的区别</h3><p>相同点：</p>
<p>都是在特定的作用域中调用函数，使用call()和apply()方法时，就会改变this的指向，</p>
<p>不同点：</p>
<p>apply()方法接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</p>
<p>call()方法不一定接受两个参数，第一个参数也是函数运行的作用域（this），但是传递给函数的参数必须列举出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(obj , <span class="number">100</span> , <span class="number">200</span>);</span><br><span class="line">fn.apply(obj , [<span class="number">100</span>, <span class="number">200</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="49-箭头函数与普通函数的区别"><a href="#49-箭头函数与普通函数的区别" class="headerlink" title="49.箭头函数与普通函数的区别"></a>49.箭头函数与普通函数的区别</h3><ul>
<li><p>语法更加简洁、清晰</p>
</li>
<li><p>箭头函数没有 prototype (原型)，所以箭头函数本身没有this</p>
</li>
<li><p>箭头函数不会创建自己的this</p>
</li>
<li><p>call | apply | bind 无法改变箭头函数中this的指向</p>
</li>
<li><p>箭头函数不能作为构造函数使用</p>
</li>
<li><p>如果箭头函数没有参数，</p>
<ul>
<li>直接写一个空括号即可。</li>
<li>如果箭头函数的参数只有一个，也可以省去包裹参数的括号。</li>
<li>如果箭头函数有多个参数，将参数依次用逗号(，)分隔，包裹在括号中即可。</li>
<li>箭头函数的函数体只有一句的话可以省略花括号和return</li>
</ul>
</li>
</ul>
<h3 id="50-手写一个函数去重"><a href="#50-手写一个函数去重" class="headerlink" title="50.手写一个函数去重"></a>50.手写一个函数去重</h3><h4 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes()"></a>1.Array.prototype.includes()</h4><p>基本思路：如果布尔值为假，则说明新数组不含有该元素。</p>
<ul>
<li><p>创建一个新数组</p>
</li>
<li><p>遍历原数组</p>
</li>
<li><p>新数组利用<code>Array.prototype.includes()</code>，返回<code>false</code>则将元素存储</p>
</li>
<li><p>不满足条件的元素不存储</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = [];</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArray.includes(item)) &#123;</span><br><span class="line">      newArray.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Array-prototype-reduce"><a href="#2-Array-prototype-reduce" class="headerlink" title="2.Array.prototype.reduce()"></a>2.Array.prototype.reduce()</h4><p>基本思路：先对原数组进行排序，然后利用<code>reduce</code>方法将不重复元素放进新数组。</p>
<ul>
<li><p>对原数组进行排序</p>
</li>
<li><p>利用<code>Array.prototype.reduce()</code>叠加功能</p>
</li>
<li><p>比较原数组和新数组元素，将不重复元素放进<code>init</code>新数组中。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(init.length === <span class="number">0</span> || init[init.length - <span class="number">1</span>] !== current)&#123;</span><br><span class="line">      init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">current就是原数组的遍历的每一个元素</span><br></pre></td></tr></table></figure>
<h2 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h2><h3 id="51-事件冒泡，如何阻止事件冒泡"><a href="#51-事件冒泡，如何阻止事件冒泡" class="headerlink" title="51.  事件冒泡，如何阻止事件冒泡"></a>51.  事件冒泡，如何阻止事件冒泡</h3><blockquote>
<p>事件冒泡指的是当前的目标元素触发事件的发生,事件再一次向祖先元素传播,在祖先元素上触发相同类型的事件。</p>
<p>js冒泡和捕获是事件的两种行为，使用event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用event.preventDefault()可以取消默认事件。</p>
</blockquote>
<h3 id="52-事件循环"><a href="#52-事件循环" class="headerlink" title="52.事件循环"></a>52.事件循环</h3><ol>
<li><p>所有同步任务都是在主线程上执行，形成一个很执行栈</p>
</li>
<li><p>主线程之外，还存在一个任务队列（task queue）只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</p>
</li>
<li><p>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，就结束等待状态，进入执行栈开始被执行。</p>
</li>
<li><p>主线程不断重复以上三步。</p>
</li>
</ol>
<blockquote>
<p>对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）。</p>
</blockquote>
<h3 id="53-什么是浏览器的同源政策"><a href="#53-什么是浏览器的同源政策" class="headerlink" title="53.什么是浏览器的同源政策"></a>53.什么是浏览器的同源政策</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个<br>域的协议、域名、端口号必须相同，否则则不属于同一个域。</p>
<p>同源政策主要限制了三个方面</p>
<p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p>
<p>第二个是当前域下的 js 脚本不能够操作访问其他域下的 DOM。</p>
<p>第三个是当前域下 ajax 无法发送跨域请求。</p>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者<br>script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="54-浏览器如何通过jsonp跨域"><a href="#54-浏览器如何通过jsonp跨域" class="headerlink" title="54.浏览器如何通过jsonp跨域"></a>54.浏览器如何通过jsonp跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过动态创建 script 标签，通过 script 标签的 src 请求来通过jsonp跨域</span><br><span class="line">JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。<span class="built_in">document</span>.domain + iframe跨域：两个页面都通过js强制设置<span class="built_in">document</span>.domain为基础主域，就实现了同域。</span><br><span class="line">location.hash + iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name + iframe跨域：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的<span class="built_in">window</span>.name从外域传递到本地域。</span><br><span class="line"></span><br><span class="line">postMessage跨域：可以跨域操作的<span class="built_in">window</span>属性之一。</span><br><span class="line"></span><br><span class="line">CORS：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。</span><br><span class="line"></span><br><span class="line">代理跨域：启一个代理服务器，实现数据的转发</span><br></pre></td></tr></table></figure>
<h3 id="55-GET和-POST-的区别"><a href="#55-GET和-POST-的区别" class="headerlink" title="55.GET和 POST 的区别"></a>55.GET和 POST 的区别</h3><ol>
<li>GET参数通过 url 传递，POST 放在请求体 (request body) 中。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
</ol>
<h3 id="56-说说你知道的HTTP-状态码"><a href="#56-说说你知道的HTTP-状态码" class="headerlink" title="56.说说你知道的HTTP 状态码"></a>56.说说你知道的HTTP 状态码</h3><ol>
<li>1XX 信息性状态码<ul>
<li>100 继续</li>
<li>101 切换协议</li>
</ul>
</li>
<li>2XX 成功状态码<ul>
<li>200 OK 成功处理了请求</li>
<li>204 No Content 请求处理成功，但没有资源可返回</li>
<li>206 Partial Content 请求资源的某一部分</li>
</ul>
</li>
<li>3XX 重定向状态码<ul>
<li>301 永久性重定向，表示请求的资源已被分配了新的 URI</li>
<li>302 临时性重定向，资源的 URL 已临时定位到其他位置</li>
<li>303 告诉客户端应该用另一个 URL 获取资源</li>
<li>304 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况</li>
</ul>
</li>
<li>4XX 客户端错误状态码<ul>
<li>400 表示请求报文中存在语法错误</li>
<li>401 未授权</li>
<li>403 服务器拒绝了请求</li>
<li>404 服务器无法找到所请求的 URL</li>
</ul>
</li>
<li>5XX 服务器错误状态码<ul>
<li>500 内部服务器错误</li>
<li>502 错误网关</li>
<li>503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
<li>504 响应超时</li>
</ul>
</li>
</ol>
<h3 id="57-js-脚本-defer-和-async-的区别"><a href="#57-js-脚本-defer-和-async-的区别" class="headerlink" title="57.js 脚本 defer 和 async 的区别"></a>57.js 脚本 defer 和 async 的区别</h3><blockquote>
<p> async 是异步下载并立即执行，然后文档继续解析，defer 是异步加载后解析文档，然后再执行脚本</p>
</blockquote>
<h3 id="58-js-如何设置异步"><a href="#58-js-如何设置异步" class="headerlink" title="58.js 如何设置异步"></a>58.js 如何设置异步</h3><ol>
<li><p>通过回调函数</p>
</li>
<li><p>事件监听：对这个事件进行监听，利用定时器的原理去把该事件放入事件队列里，等全部执行完毕之后，才会执行事件队列里的方法</p>
</li>
<li><p>发布/订阅：存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做发布/订阅模式。</p>
<p>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
</li>
<li><p>Promises对象：每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：f1().then(f2);</p>
</li>
</ol>
<h3 id="59-关于js暂停执行的方法"><a href="#59-关于js暂停执行的方法" class="headerlink" title="59.关于js暂停执行的方法"></a>59.关于js暂停执行的方法</h3><ol>
<li>利用alert,comfirm弹窗暂停</li>
<li><p>二:while();方法暂停 <code>while（i&lt;50000000）</code></p>
<h3 id="60-异步-js-脚本在执行的时候主线程会停止吗"><a href="#60-异步-js-脚本在执行的时候主线程会停止吗" class="headerlink" title="60. 异步 js 脚本在执行的时候主线程会停止吗"></a>60. 异步 js 脚本在执行的时候主线程会停止吗</h3></li>
</ol>
<blockquote>
<p>不会，因为是异步的，例如：刷微博，当你刷的比较快的时候，有些图片没有加载出来图片资源的加载就是一个分线程。整个页面的刷新是主线程 又或者博客的加载，有些页面的文字显示了，而图片设置了懒加载之后显示（减轻服务器的负担，增加用户体验）</p>
</blockquote>
<h2 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h2><h3 id="61-async-await-是一个语法糖，你知道-await-后面如何用吗"><a href="#61-async-await-是一个语法糖，你知道-await-后面如何用吗" class="headerlink" title="61. async/await 是一个语法糖，你知道 await 后面如何用吗"></a>61. async/await 是一个语法糖，你知道 await 后面如何用吗</h3><p><strong>await</strong> 右侧的表达式一般为 <strong>promise</strong> 对象, 但也可以是其它的值</p>
<ol>
<li>如果表达式是 promise 对象, await 返回的是 promise 成功的值</li>
<li>如果表达式是其它值, 直接将此值作为 await 的返回值</li>
</ol>
<p><strong>async </strong> 使用在<strong>定义方法</strong>时修饰, 方法内部就可以使用await</p>
<h3 id="62-this-在-node-里全局的指向是什么"><a href="#62-this-在-node-里全局的指向是什么" class="headerlink" title="62.this 在 node 里全局的指向是什么"></a>62.this 在 node 里全局的指向是什么</h3><blockquote>
<p>global</p>
</blockquote>
<h3 id="63-对象的深拷贝和浅拷贝"><a href="#63-对象的深拷贝和浅拷贝" class="headerlink" title="63.对象的深拷贝和浅拷贝"></a>63.对象的深拷贝和浅拷贝</h3><p><strong>浅拷贝</strong></p>
<blockquote>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<p>浅拷贝只在根属性上在堆内存中创建了一个新的的对象，复制了基本类型的值,但是复杂数据类型也就是对象则是拷贝相同的地址，而深拷贝则是对于复杂数据类型在堆内存中开辟了一块内存地址用于存放复制的对象并且把原有的对象复制过来，这2个对象是相互独立的,也就是2个不同的地址</p>
<blockquote>
<p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p>
</blockquote>
<h3 id="64-git-rebase-和-git-merge-的区别"><a href="#64-git-rebase-和-git-merge-的区别" class="headerlink" title="64.git rebase 和 git merge 的区别"></a>64.git rebase 和 git merge 的区别</h3><p>假设有3次提交A,B,C。</p>
<p>在远程分支origin的基础上创建一个名为”mywork”的分支并提交了，同时有其他人在”origin”上做了一些修改并提交了。</p>
<p>其实这个时候E不应该提交，因为提交后会发生冲突。如何解决这些冲突呢？有以下两种方法：</p>
<p>1、git merge<br>用git pull命令把”origin”分支上的修改pull下来与本地提交合并（merge）成版本M，但这样会形成图中的菱形，让人很困惑。</p>
<p>2、git rebase<br>创建一个新的提交R，R的文件内容和上面M的一样，但我们将E提交废除，当它不存在（图中用虚线表示）。由于这种删除，小李不应该push其他的repository.rebase的好处是避免了菱形的产生，保持提交曲线为直线，让大家易于理解。</p>
<p>在rebase的过程中，有时也会有conflict，这时Git会停止rebase并让用户去解决冲突，解决完冲突后，用git add命令去更新这些内容，然后不用执行git-commit,直接执行git rebase —continue,这样git会继续apply余下的补丁。<br>在任何时候，都可以用git rebase —abort参数来终止rebase的行动，并且mywork分支会回到rebase开始前的状态。</p>
<h3 id="65-DOM事件流包括哪些阶段"><a href="#65-DOM事件流包括哪些阶段" class="headerlink" title="65.DOM事件流包括哪些阶段"></a>65.DOM事件流包括哪些阶段</h3><ul>
<li>事件捕获阶段： 事件对象从Window对象开始沿传播路径向下，依次经过各元素传播至目标元素的父元素；</li>
<li>处于目标阶段 ：事件对象到达目标元素；</li>
<li>事件冒泡阶段： 事件对象从目标元素的父元素开始沿传播路径向上，依次经过各元素传播至Window对象。</li>
</ul>
<p>先捕获再冒泡</p>
<h3 id="66-什么是监听事件，监视事件的方式"><a href="#66-什么是监听事件，监视事件的方式" class="headerlink" title="66.什么是监听事件，监视事件的方式"></a>66.什么是监听事件，监视事件的方式</h3><blockquote>
<p>监听事件就是等待某个事件的发生，当这个事件发生之后，对其做出一个响应。如：鼠标单击一个按钮，单击按钮时打开一个新的页面，或者双击桌面的应用图标，运行一个程序，这都是监听事件的应用。</p>
</blockquote>
<p><strong>监听三要素</strong></p>
<ol>
<li>Event Source(事件源)：监听的目标，假如我们给Button设置一个点击事件，那么Button就为事件源</li>
<li>Event(事件)：发生的事件，不同的事件需要相应的事件监听器进行处理，点击、触摸、按下等都是事件</li>
<li>Event Listener(事件监听器)：不同的事件监听器处理不同的监听事件</li>
</ol>
<p><strong>实现方式</strong></p>
<ol>
<li><p>常用的五种监听方式的实现方式 ：内部类、匿名内部类、外部类、事件源所在类、onClick属性</p>
</li>
<li><p>通过onClick属性实现：在Button控件中有一个”onClick”属性，用于给Button控件设置监听事件，创建一个监听事件作为属性值传入</p>
</li>
</ol>
<h3 id="67-addEventListener-的参数有哪些"><a href="#67-addEventListener-的参数有哪些" class="headerlink" title="67. addEventListener 的参数有哪些"></a>67. addEventListener 的参数有哪些</h3><blockquote>
<p> addEventListener 有三个参数：第一个参数表示事件名称（不含 on，如 “click”）；第二个参数表示要接收事件处理的函数；第三个参数为 useCapture</p>
<p>简明说：事件名称；事件处理函数；捕获还是冒泡。</p>
</blockquote>
<h3 id="68-浏览器输入-URL-之后发生了什么"><a href="#68-浏览器输入-URL-之后发生了什么" class="headerlink" title="68. 浏览器输入 URL 之后发生了什么"></a>68. 浏览器输入 URL 之后发生了什么</h3><p>参考链接：<a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="69-flex-有哪些属性，flex-basis-属性是干嘛的"><a href="#69-flex-有哪些属性，flex-basis-属性是干嘛的" class="headerlink" title="69.flex 有哪些属性，flex-basis 属性是干嘛的"></a>69.flex 有哪些属性，flex-basis 属性是干嘛的</h3><ol>
<li><p>flex-direction属性：flex-direction属性决定主轴的方向（即项目的排列方向）。</p>
</li>
<li><p>flex-wrap属性：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，应该如何换行。</p>
</li>
<li><p>flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
</li>
<li><p>.justify-content属性：justify-content属性定义了项目在主轴上(即横向)的对齐方式。</p>
</li>
<li><p>align-items属性：align-items属性定义项目在交叉轴上(即纵向,垂直)如何对齐。</p>
</li>
</ol>
<p>flex-basis属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</span><br><span class="line">浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line">.item &#123;</span><br><span class="line">    flex-basis: <span class="xml"><span class="tag">&lt;<span class="name">length</span>&gt;</span> | auto; /* default auto */</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</span></span><br></pre></td></tr></table></figure>
<h3 id="70-线程与进程的区别"><a href="#70-线程与进程的区别" class="headerlink" title="70.线程与进程的区别"></a>70.线程与进程的区别</h3><p>官网定义：<br>进程是系统进行资源分配和调度的基本单位</p>
<p>线程是操作系统能够进行运算调度的最小单位</p>
<p>简单理解：<br>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p>
<p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p>
<p>借助阮一峰老师的解释<br>1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>4.一个车间里，可以有很多工人。他们协同完成一个任务。<br>5.线程就好比车间里的工人。一个进程可以包括多个线程。<br>6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。<br>  这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。<br>  这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。<br>10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。<br>  这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</p>
<p>操作系统的设计，因此可以归结为三点：</p>
<p>（1）以多进程形式，允许多个任务同时运行；</p>
<p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p>
<p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>
<h2 id="11-22"><a href="#11-22" class="headerlink" title="11.22"></a>11.22</h2><h3 id="71-区分-‘123’-和-123-的方法"><a href="#71-区分-‘123’-和-123-的方法" class="headerlink" title="71. 区分 ‘123’ 和 123 的方法"></a>71. 区分 ‘123’ 和 123 的方法</h3><ol>
<li><p><strong>typeof</strong></p>
</li>
<li><p><strong>instanceof</strong></p>
</li>
<li><p><strong>toString.call() 最靠谱</strong>  </p>
<ul>
<li><p>toString.call(‘aaa’) <em>// “[object String]”</em></p>
</li>
<li><p>toString.call(123) <em>// “[object Number]”</em></p>
</li>
</ul>
</li>
</ol>
<h3 id="72-Object-defineProperty-是干嘛的，参数有哪些"><a href="#72-Object-defineProperty-是干嘛的，参数有哪些" class="headerlink" title="72.Object.defineProperty 是干嘛的，参数有哪些"></a>72.Object.defineProperty 是干嘛的，参数有哪些</h3><blockquote>
<p>Object.defineProperty 需要三个参数（object , prop, descriptor）</p>
</blockquote>
<p>　    1 object 对象 =&gt;要定义属性的对象。 给谁加<br>　　2 propName 属性名 =&gt; 要定义或修改的属性的名称或 Symbol，要加的属性的名字 【类型：String】<br>　　3 descriptor 属性描述 =&gt; 要定义或修改的属性描述符，加的这个属性有什么样的特性【类型：Object】</p>
<h3 id="73-TCP-IP五层模型-OSI七层模型"><a href="#73-TCP-IP五层模型-OSI七层模型" class="headerlink" title="73. TCP/IP五层模型  OSI七层模型"></a>73. TCP/IP五层模型  OSI七层模型</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*<span class="strong">*五层模型*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">应用层</span></span><br><span class="line"><span class="strong">传输层</span></span><br><span class="line"><span class="strong">网络层</span></span><br><span class="line"><span class="strong">数据链路层</span></span><br><span class="line"><span class="strong">物理层</span></span><br><span class="line"><span class="strong">*</span><span class="strong">*七层模型*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">应用层</span></span><br><span class="line"><span class="strong">表示层</span></span><br><span class="line"><span class="strong">会话层</span></span><br><span class="line"><span class="strong">传输层</span></span><br><span class="line"><span class="strong">网络层</span></span><br><span class="line"><span class="strong">数据链路层</span></span><br><span class="line"><span class="strong">物理层</span></span><br></pre></td></tr></table></figure>
<h3 id="74-应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的"><a href="#74-应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的" class="headerlink" title="74.应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的"></a>74.应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的</h3><p><strong>基于TCP协议的</strong></p>
<ul>
<li>FTP（文件传输协议）：定义了文件传输协议，使用21端口。</li>
<li>TELNET（远程登陆协议）：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</li>
<li>SMTP（简单邮件传输协议）：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</li>
<li>POP3（邮件读取协议）：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</li>
<li>HTTP（超文本传输协议）：是从Web服务器传输超文本到本地浏览器的传送协议。</li>
<li>HTTPS（超文本传输安全协议）</li>
</ul>
<p><strong>基于UDP协议的</strong></p>
<ul>
<li>TFTP（简单文件传输协议）：该协议在熟知端口69上使用UDP服务。</li>
<li>SNMP（简单网络管理协议）：使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>BOOTP（引导程序协议，DHCP的前身）：应用于无盘设备</li>
<li>DHCP（动态主机配置协议）：是一个局域网的网络协议</li>
<li>RIP（路由信息协议）：基于距离矢量算法的路由协议，利用跳数来作为计量标准。</li>
<li>IGMP（Internet组管理协议）</li>
</ul>
<p><strong>基于TCP和UDP协议的</strong></p>
<ul>
<li>DNS（域名系统）：DNS区域传输的时候使用TCP协议。域名解析时使用UDP协议。DNS用的是53号端口。</li>
<li>ECHO（回绕协议）</li>
</ul>
<h3 id="75-HTTP-与-HTTPS-的区别"><a href="#75-HTTP-与-HTTPS-的区别" class="headerlink" title="75.HTTP 与 HTTPS 的区别"></a>75.HTTP 与 HTTPS 的区别</h3><ol>
<li>HTTP 传输的数据都是未加密的，也就是明文的，HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</li>
<li>HTTPS 协议需要 CA 证书，费用较高；</li>
<li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443；</li>
</ol>
<h3 id="76-HTTPS-协议的工作原理"><a href="#76-HTTPS-协议的工作原理" class="headerlink" title="76.HTTPS 协议的工作原理"></a>76.HTTPS 协议的工作原理</h3><ol>
<li>客户使用 HTTPS URL 访问服务器，则要求 web 服务器建立 SSL 链接。</li>
<li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回给客户端。</li>
<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器通过自己的私钥解密出会话密钥。</li>
<li>web 服务器通过会话密钥加密与客户端之间进行通信。</li>
</ol>
<h3 id="77-HTTP-2-0-特性（相比于1-0）"><a href="#77-HTTP-2-0-特性（相比于1-0）" class="headerlink" title="77.HTTP/2.0 特性（相比于1.0）"></a>77.HTTP/2.0 特性（相比于1.0）</h3><ol>
<li>首部压缩</li>
<li>多路复用</li>
<li>二进制分帧</li>
<li>服务端推送</li>
</ol>
<h3 id="78-TCP-和-UDP-之间的区别"><a href="#78-TCP-和-UDP-之间的区别" class="headerlink" title="78.TCP 和 UDP 之间的区别"></a>78.TCP 和 UDP 之间的区别</h3><p><strong>TCP：传输控制协议 UDP：用户数据报协议</strong></p>
<ol>
<li>TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接；</li>
<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。</li>
<li>TCP 是面向字节流，UDP 面向报文；</li>
<li>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多；</li>
<li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节；</li>
</ol>
<h3 id="79-三次握手相关内容"><a href="#79-三次握手相关内容" class="headerlink" title="79.三次握手相关内容"></a>79.三次握手相关内容</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222040742.png" alt="image-20211122204020581"></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</p>
<h5 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第一种回答-2" target="_blank" rel="noopener">第一种回答</a></h5><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li>
</ul>
<h5 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第二种回答-2" target="_blank" rel="noopener">第二种回答</a></h5><ul>
<li><strong>初始状态</strong>：客户端处于 <code>closed(关闭)</code>状态，服务器处于 <code>listen(监听)</code> 状态。</li>
<li><strong>第一次握手</strong>：客户端发送请求报文将 <code>SYN = 1</code>同步序列号和初始化序列号<code>seq = x</code>发送给服务端，发送完之后客户端处于发送等待状态<code>SYN_Send</code>状态。（验证了客户端的发送能力和服务端的接收能力)</li>
<li><strong>第二次握手</strong>：服务端受到 <code>SYN</code> 请求报文之后，如果同意连接，会以自己的同步序列号<code>SYN(服务端) = 1</code>、初始化序列号 <code>seq = y</code>和确认序列号（期望下次收到的数据包）<code>ack = x+ 1</code> 以及确认号<code>ACK = 1</code>报文作为应答，服务器为<code>SYN_Receive</code>状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li>
<li><strong>第三次握手</strong>： 客户端接收到服务端的 <code>SYN + ACK</code>之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 <code>ack = y + 1</code>和数据包的序列号 <code>seq = x + 1</code>以及确认号<code>ACK = 1</code>确认包作为应答，客户端转为确认连接<code>established</code>状态。（分别站在双方的角度上思考，各自ok）</li>
</ul>
<h3 id="79-为什么需要三次握手，两次不行吗？"><a href="#79-为什么需要三次握手，两次不行吗？" class="headerlink" title="79.为什么需要三次握手，两次不行吗？"></a>79.为什么需要三次握手，两次不行吗？</h3><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>为什么要进行三次握手的情况：</p>
<blockquote>
<p>当进行第一次握手，网络不好可能会堵塞，所以连接的请求并没有到达服务器端;但是tcp连接有超时重传的机制，所以再一次发送请求，这时候服务器端接收到了你的请求，他也会返回一个请求给你，这是第二次握手;<br>但是这时候网络环境突然又好了起来，那个堵塞的请求到达了服务器端，服务器端又给你回了一个请求，但是你又不想给服务器发送请求，这时候服务器的资源会进行占用等待你的请求，为了不使服务器的资源继续占用，你又必须发送一个请求给服务器;<br>所以要进行3次握手</p>
</blockquote>
<h3 id="80-四次挥手相关内容"><a href="#80-四次挥手相关内容" class="headerlink" title="80.四次挥手相关内容"></a>80.四次挥手相关内容</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222044207.png" alt="image-20211122204409801"></p>
<p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<strong>半关闭</strong>（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<h5 id="第一种回答-1"><a href="#第一种回答-1" class="headerlink" title="第一种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第一种回答-3" target="_blank" rel="noopener">第一种回答</a></h5><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
<p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<h5 id="第二种回答-1"><a href="#第二种回答-1" class="headerlink" title="第二种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第二种回答-3" target="_blank" rel="noopener">第二种回答</a></h5><ul>
<li><strong>初始化状态</strong>：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。</li>
<li><strong>第一次分手</strong>：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。</li>
</ul>
<blockquote>
<p>假如客户端发送的数据已经发送完毕，发送FIN = 1 <strong>告诉服务端，客户端所有数据已经全发完了</strong>，<strong>服务端你可以关闭接收了</strong>，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN = 1等待服务端确认释放连接状态。</p>
</blockquote>
<ul>
<li><strong>第二次分手</strong>：服务端接收到客户端的释放请求连接之后，<strong>知道客户端没有数据要发给自己了</strong>，<strong>然后服务端发送ACK = 1告诉客户端收到你发给我的信息</strong>，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）</li>
<li><strong>第三次分手</strong>：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，<strong>用于告诉客户端，服务端的所有数据发送完毕</strong>，<strong>客户端你也可以关闭接收数据连接了</strong>。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）</li>
<li><strong>第四次分手</strong>：此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息。<strong>有一个 2 MSL 的延迟等待</strong>。</li>
</ul>
<h3 id="81-React-页面路由参数传递的两种方法-对应实战第11天的一个大坑"><a href="#81-React-页面路由参数传递的两种方法-对应实战第11天的一个大坑" class="headerlink" title="81. React-页面路由参数传递的两种方法(对应实战第11天的一个大坑)"></a>81. React-页面路由参数传递的两种方法(对应实战第11天的一个大坑)</h3><p>list页-&gt;detail页</p>
<p><strong>方法一：路由参数</strong></p>
<p><strong>路由导航：</strong></p>
<p>用“/”</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link <span class="keyword">to</span>=&#123;<span class="string">'/detail/'</span>+item.<span class="keyword">get</span>(<span class="string">'id'</span>)&#125; key=&#123;<span class="keyword">index</span>&#125;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>路由map：</strong></p>
<p>加”/：id”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/detail/:id"</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>detail页获取参数：</strong></p>
<p>准确的获取到id，不需要做处理</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.props</span><span class="selector-class">.match</span><span class="selector-class">.params</span><span class="selector-class">.id</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：查询参数</strong></p>
<p><strong>路由导航：</strong></p>
<p>用“？”</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link <span class="keyword">to</span>=&#123;<span class="string">'/detail?'</span>+item.<span class="keyword">get</span>(<span class="string">'id'</span>)&#125; key=&#123;<span class="keyword">index</span>&#125;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>路由map：</strong></p>
<p>不加”/：id”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/detail"</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>detail页获取参数：</strong></p>
<p>不能准确的获取到id，需要做处理</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.props</span><span class="selector-class">.location</span><span class="selector-class">.search</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <br/>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jony J"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jony J</p>
  <div class="site-description" itemprop="description">stay hungry stay foolish！</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wzt2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wzt2023" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → &#x2F;images&#x2F;wechat.jpg"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.png" title="QQ → &#x2F;images&#x2F;qq.png"><i class="fab fa-qq fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:710471807@qq.com" title="E-Mail → mailto:710471807@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/problemset/all/" title="https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problemset&#x2F;all&#x2F;" rel="noopener" target="_blank">leetcode</a>
        </li>
    </ul>
  </div>

      </div>
      <div id="music163player">
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=441491828&auto=0&height=66"></iframe>
     
      </div>
    </div> 
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TT 版权所有</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">200k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:02</span>
</div>


 <div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
  </span>
  <span id="busuanzi_container_site_pv">
      &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8YHV7splQK9asMA21ILvvuFe-gzGzoHsz',
      appKey     : 'DwFfLh2EMujmRQp3tkcWjOJI',
      placeholder: "分享你的想法",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <script async src="/js/cursor/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

  
<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>

<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32X32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16X16.png">
  <link rel="mask-icon" href="/images/mylogo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Hack:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wzt2022.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":18,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideLeftBigIn","post_body":"slideRightBigIn","coll_header":"slideLeftIn","sidebar":"slideLeftBigIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前端面试题（每日10道）11.151.CSS盒模型（1）用来装页面上的元素的矩形区域。由内容区、内边距、边框、外边距四部分组成 （2）CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型，盒子的宽度时存在着差异 ​            在标准的盒子模型中，宽度指内容区部分的宽度， ​            在IE盒子模型中，宽度表示内容区，内边距，边框这三个部分的宽度 （3） 在CSS3中引">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题总结">
<meta property="og:url" content="https://wzt2022.github.io/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/index.html">
<meta property="og:site_name" content="TT の 博客">
<meta property="og:description" content="前端面试题（每日10道）11.151.CSS盒模型（1）用来装页面上的元素的矩形区域。由内容区、内边距、边框、外边距四部分组成 （2）CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型，盒子的宽度时存在着差异 ​            在标准的盒子模型中，宽度指内容区部分的宽度， ​            在IE盒子模型中，宽度表示内容区，内边距，边框这三个部分的宽度 （3） 在CSS3中引">
<meta property="og:image" content="https://wzt2022.github.io/images/loading.gif">
<meta property="og:image" content="https://wzt2022.github.io/images/loading.gif">
<meta property="og:image" content="https://wzt2022.github.io/images/loading.gif">
<meta property="og:image" content="https://wzt2022.github.io/images/loading.gif">
<meta property="og:image" content="https://wzt2022.github.io/images/loading.gif">
<meta property="article:published_time" content="2021-11-21T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-21T16:00:00.000Z">
<meta property="article:author" content="Jony J">
<meta property="article:tag" content="前端面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wzt2022.github.io/images/loading.gif">

<link rel="canonical" href="https://wzt2022.github.io/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>前端面试题总结 | TT の 博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6f41e725d94bfbcea62c56e046b8a37a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="TT の 博客" type="application/atom+xml">
</head>
<!-- 页面点击小红心 -->
 <script async src="/js/fireworks.js"></script>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TT の 博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">远方除了遥远，一无所有。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-heart fa-fw"></i>生活中的美好</a>

  </li>
        <li class="menu-item menu-item-photo">

    <a href="/photo/" rel="section"><i class="fa fa-image fa-fw"></i>照片</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/lf2021" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://wzt2022.github.io/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jony J">
      <meta itemprop="description" content="stay hungry stay foolish！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TT の 博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端面试题总结
        </h1>

        <div class="post-meta">
          
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-22T00:00:00+08:00">2021-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前端面试题（每日10道）"><a href="#前端面试题（每日10道）" class="headerlink" title="前端面试题（每日10道）"></a>前端面试题（每日10道）</h1><h2 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h2><h3 id="1-CSS盒模型"><a href="#1-CSS盒模型" class="headerlink" title="1.CSS盒模型"></a>1.CSS盒模型</h3><p>（1）用来装页面上的元素的矩形区域。由内容区、内边距、边框、外边距四部分组成</p>
<p>（2）CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型，盒子的宽度时存在着差异</p>
<p>​            在标准的盒子模型中，宽度指内容区部分的宽度，</p>
<p>​            在IE盒子模型中，宽度表示内容区，内边距，边框这三个部分的宽度</p>
<p>（3） 在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型</p>
<p><strong>补充</strong></p>
<ul>
<li><p>边框和内边距的设置会影响到盒子的大小，外边距的设置不会影响盒子可见框的大小，但是会影响盒子的位置，从而影响盒子实际占用空间</p>
</li>
<li><p>一个元素在其父元素中,水平布局必须要满足以下的等式：左右外边距+左右内边距+左右边框+本身宽度=父元素内容区的宽度</p>
<p>如果这七个值中没有为 auto 的情况，则浏览器会自动调整margin-right值以使等式满足 如果超过800 就margin-right=-200</p>
<p>这七个值中有三个值可以设置成auto，width、margin-left、 maring-right，调整相应的auto以使等式成立 宽度优先级最高</p>
</li>
<li><p>如果子元素的大小超过了父元素，则子元素会从父元素中溢出，使用overflow属性来设置父元素如何处理溢出的子元素 </p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可选值:（1）visible，默认值子元素会从父元素中溢出，在父元素外部的位置显示。</span><br><span class="line">   （2）hidden 溢出内容将会被裁剪不会显示        </span><br><span class="line">  	   （3）scroll生成两个滚动条,通过滚动条来查看完整的内容 </span><br><span class="line">         （4）auto根据需要生成滚动条</span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直外边距的重叠（如下图绿色方块的下外边距设置100px与橙色方块上外边距设置100px重叠了) ：相邻的垂直方向外边距会发生重叠现象</p>
<ul>
<li><p>兄弟元素外边距的重叠：兄弟元素间的相邻垂直外边距会取两者之间的较大值一正一负，则取两者的和    如果相邻的外边距都是负值，则取两者中绝对值较大的   </p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151506013.png" alt="image-20211115145746032"></p>
</li>
<li><p>父子元素外边距的重叠（如下图给子元素设置上外边距100px，结果将其属性传至父元素让父元素下移）：父子元素间相邻外边距，子元素的会传递给父元素（上外边距)</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151507725.png" alt="image-20211115150739964"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-居中垂直对齐"><a href="#2-居中垂直对齐" class="headerlink" title="2.居中垂直对齐"></a>2.居中垂直对齐</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单行文本: line-height = height</span><br><span class="line">图片: vertical-align: middle;</span><br><span class="line">absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);前半部分指的是相对于物体居中但是物体本身有尺寸</span><br><span class="line">display:flex;margin:auto</span><br></pre></td></tr></table></figure>
<h3 id="3-点击按钮使得页面上的文字颜色发生改变如何实现"><a href="#3-点击按钮使得页面上的文字颜色发生改变如何实现" class="headerlink" title="3.点击按钮使得页面上的文字颜色发生改变如何实现"></a>3.点击按钮使得页面上的文字颜色发生改变如何实现</h3><p>​        首先创建一个button按钮，绑定一个onclick点击事件，对需要显示的区域设置大小和颜色(下图代码红绿交替显示)</p>
<p>​        当点击按钮的时候调用该点击事件从而改变页面上的文字颜色（调用事件的时候要获取显示区域的id）</p>
<p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151600893.png" alt="image-20211115160026280"></p>
<h3 id="4-html小知识"><a href="#4-html小知识" class="headerlink" title="4.html小知识"></a>4.html小知识</h3><p>​    （1）html 语义化让页面的内容结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并      且是容易阅读的;</p>
<p>​    （2）alt 是给搜索引擎识别，在图像无法显示时的替代文本；title 是关于元素的注释信息，主要是给用户解读。</p>
<p>​    （3） iframe标签是在当前网页插入一个指定的页面   —内联框架</p>
<p>​                优点：解决加载缓慢的第三方内容如图标或者广告等的加载问题</p>
<p>​                缺点：iframe标签会阻塞主页面的onload事件</p>
<p>​    （4）href 指向网络资源所在位置  src 会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；</p>
<p>​    （5）去除项目中符号：list-style：none 去除浏览器的默认样式使用重置样式表，专门用来对浏览器的样式进行重置</p>
<p>​    （6）开启定位的元素层级会提升且层级一样，z-index属性来指定元素的层级用整数表示，可以高于定位的层级，值越大元素的层级越              高如果元素的层级一样，则优先显示靠下的元素，祖先元素的层级再高也不会盖住后代元素（祖先z-index&gt;后代定位）。</p>
<p>​    （7）text-align文本的水平对齐 可选值:    left左侧对齐    right右对齐    center居中对齐    justify 两端对齐 </p>
<p>​    （8）vertical-align 设置元素垂直对齐的方式  用于消除图片的缝</p>
<p>​    （9）background-image设置背景图片 background-repeat用来设置背景的重复方式 background-position用来设置背景图片的位置</p>
<p>  （10）:link用来表示没访问过的链接 :visited用来表示访问过的链接</p>
<p>  （11）线性渐变，颜色沿着一条直线发生变化 linear-gradient()；</p>
<p>  （12）径向渐变，(放射性的效果) radial-gradient()</p>
<p>​     (13) 表格：table标签来创建一个表格 colspan横向的合并单元格。table虽说是块元素，但是宽度是被内容撑开的。</p>
<p>​                — 以将一个表格分成三个部分: 头部 thead 主体 tbody 底部 tfoot </p>
<p>  （14）使用form标签来创建一个表单 单选按钮   <!--单选按钮-->   <!--多选按钮--><!--重置按钮--></p>
<h3 id="5-CSS选择器的优先级"><a href="#5-CSS选择器的优先级" class="headerlink" title="5.CSS选择器的优先级"></a>5.CSS选择器的优先级</h3><p><strong>不同级别</strong></p>
<ol>
<li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p>
</li>
<li><p>作为style属性写在元素内的样式（行类样式） 权值1000</p>
</li>
<li><p>id选择器 100</p>
</li>
<li><p>类选择器 10</p>
</li>
<li><p>标签选择器 1</p>
</li>
<li><p>通配符选择器</p>
</li>
<li><p>浏览器自定义或继承</p>
</li>
<li><p>贩卖人间快乐:<br>生命周期。 </p>
<p>贩卖人间快乐:<br>双向绑定</p>
</li>
<li><p><strong>选择器的累加不会超过其最大的数量级，类选择器在再高也不会超过id选择器</strong></p>
</li>
</ol>
<h3 id="6-简明说一下-CSS-link-与-import-的区别和用法？"><a href="#6-简明说一下-CSS-link-与-import-的区别和用法？" class="headerlink" title="6.简明说一下 CSS link 与 @import 的区别和用法？"></a>6.简明说一下 CSS link 与 @import 的区别和用法？</h3><pre><code>1. link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。
2. link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。
3. link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。
</code></pre><h3 id="7-display-none和visibility-hidden的区别？"><a href="#7-display-none和visibility-hidden的区别？" class="headerlink" title="7.display:none和visibility:hidden的区别？"></a>7.display:none和visibility:hidden的区别？</h3><ul>
<li>display:none 元素不在页面中显示，不占据页面的位置。</li>
<li>visibility:hidden 元素在页面中隐藏不显示，但是依然占据页面的位置。 </li>
</ul>
<h3 id="8-rgba和opacity的透明效果有什么不同？"><a href="#8-rgba和opacity的透明效果有什么不同？" class="headerlink" title="8.rgba和opacity的透明效果有什么不同？"></a>8.rgba和opacity的透明效果有什么不同？</h3><blockquote>
<p>opacity 会继承父元素的 opacity 属性，而 RGBA 不会。</p>
</blockquote>
<h3 id="9-position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#9-position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="9.position的值， relative和absolute分别是相对于谁进行定位的？"></a>9.position的值， relative和absolute分别是相对于谁进行定位的？</h3><ul>
<li>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。</li>
<li>absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。</li>
<li>fixed: （老版本IE不支持）固定定位。</li>
<li>static:默认值，没有定位，元素出现在正常的文档流中。</li>
</ul>
<h3 id="10-BFC-是什么？"><a href="#10-BFC-是什么？" class="headerlink" title="10. BFC 是什么？"></a>10. BFC 是什么？</h3><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)根元素(<span class="tag">&lt;<span class="name">html</span>&gt;</span>)</span><br><span class="line">(2)浮动元素：float 除 none 以外的值  有局限性：高度不塌了但是脱离文档流了，宽度也就丢失了，对应特点的第三条 -不推荐</span><br><span class="line">(3)绝对定位元素：position (absolute、fixed)</span><br><span class="line">(4)display 为 inline-block、table-cells、flex -不推荐</span><br><span class="line">(5)overflow 除了 visible 以外的值 (hidden、auto、scroll) -推荐</span><br></pre></td></tr></table></figure>
<ul>
<li><p>之前不会塌是因为把高度写死了所以不会塌 现在父元素不设置高低 子元素高度为多少父元素就会被撑开多少</p>
</li>
<li><p>高度塌陷的问题: 在浮动布局中,父元素的高度默认是被子元素撑开的 当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离 将会无法撑起父元素的高度，导致父元素的高度丢失 父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱 所以高度塌陷是浮动布局中比较常见的一个问题。</p>
</li>
<li><p>开启BFC后的特点：</p>
<p>​       1.开启BFC的元素不会被浮动元素所覆盖</p>
<p>​       2.开启BFC的元素子元素和父元素外边距不会重叠 </p>
<p>​       3.开启BFC的元素可以包含浮动的子元素 </p>
<p> -常用的方式为元素设置 overflow:hidden 开启其BFC以使其可以包含浮动元素 高度不塌，宽度也不会丢失。</p>
</li>
</ul>
<h2 id="11-16"><a href="#11-16" class="headerlink" title="11.16"></a>11.16</h2><h3 id="11-doctype-的作用-声明版本"><a href="#11-doctype-的作用-声明版本" class="headerlink" title="11.doctype 的作用 声明版本"></a>11.doctype 的作用 声明版本</h3><blockquote>
<p>&lt;!DOCTYPE&gt;是一个用于声明当前HTMl版本，用来告知web浏览器该文档使用是哪种 HTML 或者 XHTML 规范来解析页面，以便浏览器更加准确的理解页面内容，更加良好地展现内容效果！</p>
</blockquote>
<h3 id="12-语义化标签的理解"><a href="#12-语义化标签的理解" class="headerlink" title="12.语义化标签的理解"></a>12.语义化标签的理解</h3><ol>
<li>即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构。</li>
<li>语义化标签会使HTML结构变的清晰，有利于维护代码和添加样式。</li>
<li>和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息</li>
<li>同时与计算机的编译也存在一定的联系</li>
</ol>
<h3 id="13-important-有什么不好"><a href="#13-important-有什么不好" class="headerlink" title="13.important 有什么不好"></a>13.important 有什么不好</h3><blockquote>
<p>css定义中的用!important样式权重是最高的，会覆盖页面内任何位置定义的元素样式，有时候程序员忘了删除，这样就会导致自己设置的样式无法显示的问题。</p>
</blockquote>
<h3 id="14-css-选择器的解析顺序，原因"><a href="#14-css-选择器的解析顺序，原因" class="headerlink" title="14. css 选择器的解析顺序，原因"></a>14. css 选择器的解析顺序，原因</h3><blockquote>
<p>解析顺序：从右往左，</p>
<p>原因：从右往左进行解析的好处那就是从右往左进行匹配的时候，匹配的全部是DOM元素的父节点，而从左往右进行匹配的时候时候，匹配的全部是DOM元素的子节点，这样就避免了HTML与CSS没有下载完需要进行等待的情形。且遍历查找的节点都会少很多</p>
</blockquote>
<h3 id="15-css-清除浮动"><a href="#15-css-清除浮动" class="headerlink" title="15.css 清除浮动"></a>15.css 清除浮动</h3><p><strong>1清除浮动的第一种方式—给父级盒子添加高度</strong></p>
<blockquote>
<p>造成高度塌陷的原因就是父元素没有高度，我们只需要给父元素添加一个高度即可，但是这种方式并不推荐使用，因为有很多局限性，况且子元素依然是脱离标准流，并没有回到父元素中，此时父元素的宽度变化了。</p>
</blockquote>
<p><strong>2添加clear属性来清除浮动元素对当前元素所产生的影响**</strong></p>
<ol>
<li><p>可选值：</p>
<p>​    left清除左侧浮动元素对当前元素的影响 原来浮动的元素依然浮动 </p>
<p>​    right清除右侧浮动元素对当前元素的影响 </p>
<p>​    both 清除两侧中最大影响的那侧（类似高度的问题）</p>
</li>
<li><p>原理: 设置清除浮动以后，浏览器会自动为元素添加一个上外边距， 以使其位置不受其他元素的影响。</p>
</li>
</ol>
<p><strong>3.清除浮动的第三种方式—给父级添加overflow属性*</strong></p>
<blockquote>
<p>原理见16题</p>
</blockquote>
<p><strong>4.清除浮动的第四种方式—给父级添加after伪元素</strong></p>
<ul>
<li><p>利用after伪元素定义一个clearfix类，浮动元素的父级元素调用此类可以实现清除浮动的效果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.clearfix: : before,		//内边距重叠</span><br><span class="line">.clearfix: : after&#123;			//高度塌陷</span><br><span class="line">		content: ''; </span><br><span class="line">		display: table;//table就相当于一个物体隔开他们俩让他们的外边距不重合</span><br><span class="line">		clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="16-overflow-hidden-是怎么清除浮动的"><a href="#16-overflow-hidden-是怎么清除浮动的" class="headerlink" title="16. overflow:hidden 是怎么清除浮动的"></a>16. overflow:hidden 是怎么清除浮动的</h3><blockquote>
<p>父块没有设置指定的高宽，当子块设置为浮动后，原本包裹子块的父块的高度塌陷消失，这时给父块设置overflow:hidden就会为父块设置一个独立的块级上下文，使这个块级元素内部的排版完全独立，从而可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，这样就达到了清除浮动的效果，，使父块重新包裹子块。</p>
</blockquote>
<h3 id="17-HTML5、CSS3-里面都新增了那些新特性？"><a href="#17-HTML5、CSS3-里面都新增了那些新特性？" class="headerlink" title="17.HTML5、CSS3 里面都新增了那些新特性？"></a>17.HTML5、CSS3 里面都新增了那些新特性？</h3><p><strong>HTML5</strong> </p>
<ul>
<li>新的语义标签<ul>
<li>article 独立的内容。</li>
<li>aside 侧边栏。</li>
<li>header 头部。</li>
<li>nav 导航。</li>
<li>section 文档中的节。</li>
<li>footer 页脚。</li>
</ul>
</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>拖拽释放(Drag and drop) API</li>
<li>音频、视频API(audio,video)</li>
<li>表单控件，calendar、date、time、email、url、searc</li>
</ul>
<p><strong>CSS3</strong></p>
<ul>
<li>2d，3d变换</li>
<li>Transition, animation</li>
<li>媒体查询</li>
<li>新的单位（rem, vw，vh 等）</li>
<li>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</li>
<li>rgba</li>
</ul>
<h3 id="18-常见兼容性问题？"><a href="#18-常见兼容性问题？" class="headerlink" title="18. 常见兼容性问题？"></a>18. 常见兼容性问题？</h3><blockquote>
<p> 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
</blockquote>
<h3 id="19-固定定位和绝对定位的区别"><a href="#19-固定定位和绝对定位的区别" class="headerlink" title="19.固定定位和绝对定位的区别"></a>19.固定定位和绝对定位的区别</h3><p>fixed :固定 定位 absolute :绝对 定位 区别 ： 1、<strong>没有滚动条的情况下没有差异</strong> 2、在有滚动条的情况下， fixed定位 不会随滚动条移动而移动，而 absolute 则会随滚动条移动 </p>
<h3 id="20-实现一个两列固定，中间自适应有哪些方法"><a href="#20-实现一个两列固定，中间自适应有哪些方法" class="headerlink" title="20.实现一个两列固定，中间自适应有哪些方法"></a>20.实现一个两列固定，中间自适应有哪些方法</h3><ol>
<li><p>使用flex通过改变 <code>flex-grow</code>和 <code>flex-shrink</code>实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        height: 100vh;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: row;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: lightskyblue;</span><br><span class="line">        word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 左右固定长度 */</span></span></span><br><span class="line">        flex-basis: 100px;</span><br><span class="line"><span class="css">        <span class="comment">/* 将增长比和缩小比都设置为 0 ,避免宽度变化 */</span></span></span><br><span class="line">        flex-grow: 0;</span><br><span class="line">        flex-shrink: 0;</span><br><span class="line">        background-color: lightslategray;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 中间自动适应 */</span></span></span><br><span class="line">        flex-grow: 1;</span><br><span class="line">        flex-shrink: 1;</span><br><span class="line">        background-color: lightpink;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对定位+CSS3新盒子 (利用新盒子 width = content + padding + border 特性 🎈)</p>
   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">     body&#123;</span><br><span class="line">         height: 100vh;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">         position: relative;</span><br><span class="line">         height: 200px;</span><br><span class="line">         background-color: lightskyblue;</span><br><span class="line">         word-break: break-all;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="comment">/* 使用绝对定位来控制元素 */</span></span></span><br><span class="line">         position: absolute;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">         height: 200px;</span><br><span class="line">         width: 100px;</span><br><span class="line">         background-color: lightslategray;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">         right: 0;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="comment">/* 控制padding来放置两侧元素, content宽度会自动计算 */</span></span></span><br><span class="line">         box-sizing: border-box;</span><br><span class="line">         height: 100%;</span><br><span class="line">         width: 100%;</span><br><span class="line"><span class="css">         <span class="comment">/* 两端填充100px, 用来放两侧固定元素 */</span></span></span><br><span class="line">         padding: 0 100px;</span><br><span class="line">         background-color: lightpink;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h2><h3 id="21-伪类选择器和伪元素理解以及区别-可以使用伪类选择器实现隔行变色效果"><a href="#21-伪类选择器和伪元素理解以及区别-可以使用伪类选择器实现隔行变色效果" class="headerlink" title="21.伪类选择器和伪元素理解以及区别(可以使用伪类选择器实现隔行变色效果)"></a>21.伪类选择器和伪元素理解以及区别(可以使用伪类选择器实现隔行变色效果)</h3><p>   <strong>伪类（不存在的类，特殊的类),伪类用来描述一个元素的特殊状态 比如:第一个子元素、被点击的元素、鼠标移入的元素…</strong></p>
<ul>
<li><p>: nth-child()选中第n个子元素</p>
</li>
<li><p>: nth-of-type() 同类型元素中进行排序</p>
<p><strong>伪元素，表示页面中一些特殊的并不真实存在的元素（特殊的位置)</strong>     </p>
<blockquote>
<p>::before元素的最开头 ::after元素的最后    - before和 after必须结合content属性来使用</p>
</blockquote>
<h3 id="22-em和rem"><a href="#22-em和rem" class="headerlink" title="22.em和rem"></a>22.em和rem</h3><p><strong>em是相对于元素的字体大小来计算的</strong></p>
<p><strong>rem是相对于根元素的字体大小来计算 —类似于全局变量</strong></p>
<h3 id="23-我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现"><a href="#23-我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现" class="headerlink" title="23.我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现"></a>23.我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现</h3></li>
</ul>
</li>
</ol>
<p><strong>使用Promise.all</strong></p>
<ol>
<li><p>当有一个ajax请求时，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</p>
</li>
<li><p>Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。</p>
</li>
</ol>
<p><strong>promise补充</strong></p>
<ol>
<li>现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。</li>
<li>Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。</li>
<li>then方法的执行结果也会返回一个Promise对象。因此我们可以进行then的链式执行，这也是解决回调地狱的主要方式。</li>
</ol>
<h3 id="24-setTimeout-和-Promise-哪一个先执行"><a href="#24-setTimeout-和-Promise-哪一个先执行" class="headerlink" title="24.setTimeout 和 Promise 哪一个先执行"></a>24.setTimeout 和 Promise 哪一个先执行</h3><blockquote>
<p> Promise比setTimeout()先执行。因为Promise定义之后便会立即执行，其后的.then()是异步里面的微任务。而setTimeout()是异步的宏任务。</p>
</blockquote>
<h3 id="25-canvas-的一些方法"><a href="#25-canvas-的一些方法" class="headerlink" title="25.canvas 的一些方法"></a>25.canvas 的一些方法</h3><ol>
<li>第一是以drawXXX为主的绘制方法； 例如drawColor：填充颜色</li>
<li>第二是以clipXXX为主的裁剪方法；    例如clipRect：当前画布裁剪为一个矩形</li>
<li>第三是以scale、translate和rotate组成的Canvas变换方法；</li>
<li>最后一类save：将当前的状态推送至栈中保存   restore：将上次保存的状态从栈中弹出；</li>
</ol>
<h3 id="26-font-face"><a href="#26-font-face" class="headerlink" title="26.@font-face"></a>26.@font-face</h3><p><strong>font-face是css3中允许使用自定义字体的一个模块。<em>@ font-face</em>的是一个CSS规则，允许你输入自己的字体出现在网站上**</strong></p>
<h3 id="27-transform-有哪些属性"><a href="#27-transform-有哪些属性" class="headerlink" title="27.transform 有哪些属性"></a>27.transform 有哪些属性</h3><p><strong>transform属性值：</strong></p>
<ul>
<li><p>transform: translate():  translate()的括号内包含两个值，分别为相对于元素原有位置在水平方向和垂直方向的偏移值</p>
</li>
<li><p>transform:rolate():  正值为顺时针，负值为逆时针，单位为deg。</p>
</li>
<li><p>transform:transform-origin:任何一个元素都有一个中心点，默认情况之下，其中心点是居于元素X轴和Y轴的50%处。</p>
</li>
<li><p>transform:scale():   scale(x,y):x,y 值分别为原有元素宽高的倍数。 1为不缩放，大于1放大，小于1缩小。</p>
</li>
</ul>
<h3 id="28-轮播图的原理"><a href="#28-轮播图的原理" class="headerlink" title="28.轮播图的原理"></a>28.轮播图的原理</h3><p><strong>图片移动实现原理：</strong></p>
<p>利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制left属性，实现照片的移动。</p>
<h3 id="29-雪碧图的使用步骤"><a href="#29-雪碧图的使用步骤" class="headerlink" title="29.雪碧图的使用步骤"></a>29.雪碧图的使用步骤</h3><ol>
<li>先确定要使用的图标 </li>
<li>测量图标的大小 </li>
<li>根据测量结果创建一个元素 </li>
<li>将雪碧图设置为元素的背景图片 </li>
<li>设置一个偏移量以显示正确的图片 </li>
</ol>
<h3 id="30-js基本数据类型"><a href="#30-js基本数据类型" class="headerlink" title="30.js基本数据类型"></a>30.js基本数据类型</h3><p>数据类型主要包括两部分：</p>
<ul>
<li>基本数据类型： Undefined、Null、Boolean、Number 和 String</li>
<li>引用数据类型： Object (包括 Object 、Array 、Function)</li>
</ul>
<h2 id="11-18"><a href="#11-18" class="headerlink" title="11.18"></a>11.18</h2><h3 id="31-判断一个值是什么类型有哪些方法？"><a href="#31-判断一个值是什么类型有哪些方法？" class="headerlink" title="31.判断一个值是什么类型有哪些方法？"></a>31.判断一个值是什么类型有哪些方法？</h3><ul>
<li>typeof 运算符</li>
<li>instanceof 运算符</li>
<li>Object.prototype.toString 方法</li>
</ul>
<h3 id="32-null-和-undefined-的区别？"><a href="#32-null-和-undefined-的区别？" class="headerlink" title="32. null 和 undefined 的区别？"></a>32. null 和 undefined 的区别？</h3><p>null 表示一个对象被定义了，值为“空值”；<br>undefined 表示不存在这个值：<br>    （1）变量被声明了，但没有赋值时，就等于undefined。 </p>
<p>​    （2)  调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>​    （3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>​    （4）函数没有返回值时，默认返回undefined。</p>
<h3 id="33-js小知识"><a href="#33-js小知识" class="headerlink" title="33.js小知识"></a>33.js小知识</h3><ol>
<li><p>==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型；</p>
<p>===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p>
</li>
<li><p>eval是把对应的字符串解析成 JS 代码并运行；</p>
</li>
<li><p>var 存在变量提升; let 只能在块级作用域内访问; const 用来定义常量，必须初始化，不能修改（对象特殊）</p>
</li>
<li><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</p>
</li>
</ol>
<h3 id="34-箭头函数有哪些特点？"><a href="#34-箭头函数有哪些特点？" class="headerlink" title="34. 箭头函数有哪些特点？"></a>34. 箭头函数有哪些特点？</h3><blockquote>
<p>不需要function关键字来创建函数<br>省略return关键字<br>改变this指向</p>
</blockquote>
<h3 id="35-new操作符具体干了什么呢？"><a href="#35-new操作符具体干了什么呢？" class="headerlink" title="35.new操作符具体干了什么呢？"></a>35.new操作符具体干了什么呢？</h3><p>1、创建一个空对象，新创建的对象由 this 所引用，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。</p>
<h3 id="36-documen-write-和-innerHTML-的区别？"><a href="#36-documen-write-和-innerHTML-的区别？" class="headerlink" title="36.documen.write 和 innerHTML 的区别？"></a>36.documen.write 和 innerHTML 的区别？</h3><ul>
<li>document.write 只能重绘整个页面</li>
<li>innerHTML 可以重绘页面的一部分</li>
</ul>
<h3 id="37-ajax过程"><a href="#37-ajax过程" class="headerlink" title="37.ajax过程"></a>37.ajax过程</h3><ol>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应HTTP请求状态变化的函数.</li>
<li>发送HTTP请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用JavaScript和DOM实现局部刷新</li>
</ol>
<h3 id="38-请解释一下-JavaScript-的同源策略？"><a href="#38-请解释一下-JavaScript-的同源策略？" class="headerlink" title="38.请解释一下 JavaScript 的同源策略？"></a>38.请解释一下 JavaScript 的同源策略？</h3><p>同源策略指的是：协议，域名，端口相同。</p>
<p>同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h3 id="39-介绍一下闭包和闭包常用场景？"><a href="#39-介绍一下闭包和闭包常用场景？" class="headerlink" title="39.介绍一下闭包和闭包常用场景？"></a>39.介绍一下闭包和闭包常用场景？</h3><ul>
<li>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数</li>
<li>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。</li>
<li>闭包有三个特性：<ul>
<li>函数嵌套函数</li>
<li>函数内部可以引用外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
<li>应用场景，设置私有变量的方法</li>
<li>不适用场景：返回闭包的函数是个非常大的函数</li>
<li>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</li>
</ul>
<h3 id="40-JavaScript原型，原型链-有什么特点？"><a href="#40-JavaScript原型，原型链-有什么特点？" class="headerlink" title="40,JavaScript原型，原型链 ? 有什么特点？"></a>40,JavaScript原型，原型链 ? 有什么特点？</h3><ul>
<li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br>于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li>
<li>关系：instance.constructor.prototype = instance.<strong>proto</strong></li>
<li>特点：<br>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li>
</ul>
<h2 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h2><h3 id="41-javascript的内存-垃圾-回收机制？"><a href="#41-javascript的内存-垃圾-回收机制？" class="headerlink" title="41.javascript的内存(垃圾)回收机制？"></a>41.javascript的内存(垃圾)回收机制？</h3><ul>
<li><p>垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存</p>
</li>
<li><p>一般使用<strong>标记清除方法(mark and sweep)</strong>, 当变量进入环境标记为进入环境，离开环境标记为离开环境<br>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p>
</li>
<li>还有<strong>引用计数方法(reference counting)</strong>, 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</li>
<li>在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。</li>
</ul>
<h3 id="42-如何解决-ES6-的语法兼容"><a href="#42-如何解决-ES6-的语法兼容" class="headerlink" title="42. 如何解决 ES6 的语法兼容"></a>42. 如何解决 ES6 的语法兼容</h3><blockquote>
<ol>
<li><p>对于浏览器解析不了es6的语法，需要我们使用babel工具链</p>
</li>
<li><p>对于不支持let等语法的情况下可以采用</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="comment">//严格模式</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="43-ES6的一些东西"><a href="#43-ES6的一些东西" class="headerlink" title="43.ES6的一些东西"></a>43.ES6的一些东西</h3><ol>
<li>新增了<code>let</code>、<code>const</code> <code>let</code>和<code>const</code>具有块级作用域，不存在变量提升的问题，<code>var</code> 声明的变量作用域为包围它的函数。</li>
<li>新增了箭头函数，简化了定义函数的写法，同时可以巧用箭头函数的this、（注意箭头函数本身没有this,它的this取决于外部的环境）</li>
<li>新增了promise解决了回调地域的问题</li>
<li>新增了模块化、利用import 、export来实现导入、导出</li>
<li>let的用法：定义变量 </li>
<li>箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定</li>
</ol>
<h3 id="44-如何解决js浮点数运算精度问题"><a href="#44-如何解决js浮点数运算精度问题" class="headerlink" title="44.如何解决js浮点数运算精度问题"></a>44.如何解决js浮点数运算精度问题</h3><p>问题:整数和浮点数都属于 <code>Number</code> 数据类型，所有数字都是以 64 位浮点数形式储存，即便整数也是如此。 所以我们在打印 <code>1.00</code> 这样的浮点数的结果是 <code>1</code> 而非 <code>1.00</code> 。</p>
<p>解决方法:</p>
<ol>
<li><p>利用toFixed() 方法用定点表示法来格式化一个数，会对结果进行四舍五入，对计算结果进行精度缩小。(不过还是存在精度问题)</p>
</li>
<li><p>或者直接用第三方帮你封装好处理浮点数的库，直接可以用。 如：number-precision</p>
</li>
</ol>
<h3 id="45-requestanimationframe-有用过吗？知道是干嘛的吗"><a href="#45-requestanimationframe-有用过吗？知道是干嘛的吗" class="headerlink" title="45.requestanimationframe 有用过吗？知道是干嘛的吗"></a>45.requestanimationframe 有用过吗？知道是干嘛的吗</h3><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
<h3 id="46-new操作符的过程"><a href="#46-new操作符的过程" class="headerlink" title="46.new操作符的过程"></a>46.new操作符的过程</h3><p> <strong>具体主要有4个部分</strong></p>
<p> 1.创建了一个新对象</p>
<p> 2.把这个新对象的原型属性（proto）绑定到原函数的prototype属性（就是继承原函数原型）</p>
<p> 3.把原函数的this指向转移到这个新对象上</p>
<p> 4.返回新对象，如果这个函数没有返回其他对象的话</p>
<h3 id="47-数组的一些方法"><a href="#47-数组的一些方法" class="headerlink" title="47.数组的一些方法"></a>47.数组的一些方法</h3><p>具体详解可以看<a href="https://blog.csdn.net/jjw_zyfx/article/details/95970780" target="_blank" rel="noopener">数组方法</a>）</p>
<ol>
<li><p>map方法的使用 相当于循环遍历每一项然后可以对每一项进行修改</p>
</li>
<li><p>filter的用法 过滤掉不符合条件的,剩下符合条件的</p>
</li>
<li>join方法的使用 数组变字符串</li>
<li>split方法的使用 字符串变数组</li>
<li>splice(1,1)删除的用法 删除下标为1的1个元素</li>
</ol>
<h3 id="48-call-apply-的区别"><a href="#48-call-apply-的区别" class="headerlink" title="48.call apply 的区别"></a>48.call apply 的区别</h3><p>相同点：</p>
<p>都是在特定的作用域中调用函数，使用call()和apply()方法时，就会改变this的指向，</p>
<p>不同点：</p>
<p>apply()方法接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</p>
<p>call()方法不一定接受两个参数，第一个参数也是函数运行的作用域（this），但是传递给函数的参数必须列举出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(obj , <span class="number">100</span> , <span class="number">200</span>);</span><br><span class="line">fn.apply(obj , [<span class="number">100</span>, <span class="number">200</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="49-箭头函数与普通函数的区别"><a href="#49-箭头函数与普通函数的区别" class="headerlink" title="49.箭头函数与普通函数的区别"></a>49.箭头函数与普通函数的区别</h3><ul>
<li><p>语法更加简洁、清晰</p>
</li>
<li><p>箭头函数没有 prototype (原型)，所以箭头函数本身没有this</p>
</li>
<li><p>箭头函数不会创建自己的this</p>
</li>
<li><p>call | apply | bind 无法改变箭头函数中this的指向</p>
</li>
<li><p>箭头函数不能作为构造函数使用</p>
</li>
<li><p>如果箭头函数没有参数，</p>
<ul>
<li>直接写一个空括号即可。</li>
<li>如果箭头函数的参数只有一个，也可以省去包裹参数的括号。</li>
<li>如果箭头函数有多个参数，将参数依次用逗号(，)分隔，包裹在括号中即可。</li>
<li>箭头函数的函数体只有一句的话可以省略花括号和return</li>
</ul>
</li>
</ul>
<h3 id="50-手写一个函数去重"><a href="#50-手写一个函数去重" class="headerlink" title="50.手写一个函数去重"></a>50.手写一个函数去重</h3><h4 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes()"></a>1.Array.prototype.includes()</h4><p>基本思路：如果布尔值为假，则说明新数组不含有该元素。</p>
<ul>
<li><p>创建一个新数组</p>
</li>
<li><p>遍历原数组</p>
</li>
<li><p>新数组利用<code>Array.prototype.includes()</code>，返回<code>false</code>则将元素存储</p>
</li>
<li><p>不满足条件的元素不存储</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = [];</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArray.includes(item)) &#123;</span><br><span class="line">      newArray.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Array-prototype-reduce"><a href="#2-Array-prototype-reduce" class="headerlink" title="2.Array.prototype.reduce()"></a>2.Array.prototype.reduce()</h4><p>基本思路：先对原数组进行排序，然后利用<code>reduce</code>方法将不重复元素放进新数组。</p>
<ul>
<li><p>对原数组进行排序</p>
</li>
<li><p>利用<code>Array.prototype.reduce()</code>叠加功能</p>
</li>
<li><p>比较原数组和新数组元素，将不重复元素放进<code>init</code>新数组中。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(init.length === <span class="number">0</span> || init[init.length - <span class="number">1</span>] !== current)&#123;</span><br><span class="line">      init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">current就是原数组的遍历的每一个元素</span><br></pre></td></tr></table></figure>
<h2 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h2><h3 id="51-事件冒泡，如何阻止事件冒泡"><a href="#51-事件冒泡，如何阻止事件冒泡" class="headerlink" title="51.  事件冒泡，如何阻止事件冒泡"></a>51.  事件冒泡，如何阻止事件冒泡</h3><blockquote>
<p>事件冒泡指的是当前的目标元素触发事件的发生,事件再一次向祖先元素传播,在祖先元素上触发相同类型的事件。</p>
<p>js冒泡和捕获是事件的两种行为，使用event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用event.preventDefault()可以取消默认事件。</p>
</blockquote>
<h3 id="52-事件循环"><a href="#52-事件循环" class="headerlink" title="52.事件循环"></a>52.事件循环</h3><ol>
<li><p>所有同步任务都是在主线程上执行，形成一个很执行栈</p>
</li>
<li><p>主线程之外，还存在一个任务队列（task queue）只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</p>
</li>
<li><p>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，就结束等待状态，进入执行栈开始被执行。</p>
</li>
<li><p>主线程不断重复以上三步。</p>
</li>
</ol>
<blockquote>
<p>对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）。</p>
</blockquote>
<h3 id="53-什么是浏览器的同源政策"><a href="#53-什么是浏览器的同源政策" class="headerlink" title="53.什么是浏览器的同源政策"></a>53.什么是浏览器的同源政策</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个<br>域的协议、域名、端口号必须相同，否则则不属于同一个域。</p>
<p>同源政策主要限制了三个方面</p>
<p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p>
<p>第二个是当前域下的 js 脚本不能够操作访问其他域下的 DOM。</p>
<p>第三个是当前域下 ajax 无法发送跨域请求。</p>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者<br>script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="54-浏览器如何通过jsonp跨域"><a href="#54-浏览器如何通过jsonp跨域" class="headerlink" title="54.浏览器如何通过jsonp跨域"></a>54.浏览器如何通过jsonp跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过动态创建 script 标签，通过 script 标签的 src 请求来通过jsonp跨域</span><br><span class="line">JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。<span class="built_in">document</span>.domain + iframe跨域：两个页面都通过js强制设置<span class="built_in">document</span>.domain为基础主域，就实现了同域。</span><br><span class="line">location.hash + iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name + iframe跨域：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的<span class="built_in">window</span>.name从外域传递到本地域。</span><br><span class="line"></span><br><span class="line">postMessage跨域：可以跨域操作的<span class="built_in">window</span>属性之一。</span><br><span class="line"></span><br><span class="line">CORS：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。</span><br><span class="line"></span><br><span class="line">代理跨域：启一个代理服务器，实现数据的转发</span><br></pre></td></tr></table></figure>
<h3 id="55-GET和-POST-的区别"><a href="#55-GET和-POST-的区别" class="headerlink" title="55.GET和 POST 的区别"></a>55.GET和 POST 的区别</h3><ol>
<li>GET参数通过 url 传递，POST 放在请求体 (request body) 中。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
</ol>
<h3 id="56-说说你知道的HTTP-状态码"><a href="#56-说说你知道的HTTP-状态码" class="headerlink" title="56.说说你知道的HTTP 状态码"></a>56.说说你知道的HTTP 状态码</h3><ol>
<li>1XX 信息性状态码<ul>
<li>100 继续</li>
<li>101 切换协议</li>
</ul>
</li>
<li>2XX 成功状态码<ul>
<li>200 OK 成功处理了请求</li>
<li>204 No Content 请求处理成功，但没有资源可返回</li>
<li>206 Partial Content 请求资源的某一部分</li>
</ul>
</li>
<li>3XX 重定向状态码<ul>
<li>301 永久性重定向，表示请求的资源已被分配了新的 URI</li>
<li>302 临时性重定向，资源的 URL 已临时定位到其他位置</li>
<li>303 告诉客户端应该用另一个 URL 获取资源</li>
<li>304 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况</li>
</ul>
</li>
<li>4XX 客户端错误状态码<ul>
<li>400 表示请求报文中存在语法错误</li>
<li>401 未授权</li>
<li>403 服务器拒绝了请求</li>
<li>404 服务器无法找到所请求的 URL</li>
</ul>
</li>
<li>5XX 服务器错误状态码<ul>
<li>500 内部服务器错误</li>
<li>502 错误网关</li>
<li>503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
<li>504 响应超时</li>
</ul>
</li>
</ol>
<h3 id="57-js-脚本-defer-和-async-的区别"><a href="#57-js-脚本-defer-和-async-的区别" class="headerlink" title="57.js 脚本 defer 和 async 的区别"></a>57.js 脚本 defer 和 async 的区别</h3><blockquote>
<p> async 是异步下载并立即执行，然后文档继续解析，defer 是异步加载后解析文档，然后再执行脚本</p>
</blockquote>
<h3 id="58-js-如何设置异步"><a href="#58-js-如何设置异步" class="headerlink" title="58.js 如何设置异步"></a>58.js 如何设置异步</h3><ol>
<li><p>通过回调函数</p>
</li>
<li><p>事件监听：对这个事件进行监听，利用定时器的原理去把该事件放入事件队列里，等全部执行完毕之后，才会执行事件队列里的方法</p>
</li>
<li><p>发布/订阅：存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做发布/订阅模式。</p>
<p>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
</li>
<li><p>Promises对象：每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：f1().then(f2);</p>
</li>
</ol>
<h3 id="59-关于js暂停执行的方法"><a href="#59-关于js暂停执行的方法" class="headerlink" title="59.关于js暂停执行的方法"></a>59.关于js暂停执行的方法</h3><ol>
<li>利用alert,comfirm弹窗暂停</li>
<li><p>二:while();方法暂停 <code>while（i&lt;50000000）</code></p>
<h3 id="60-异步-js-脚本在执行的时候主线程会停止吗"><a href="#60-异步-js-脚本在执行的时候主线程会停止吗" class="headerlink" title="60. 异步 js 脚本在执行的时候主线程会停止吗"></a>60. 异步 js 脚本在执行的时候主线程会停止吗</h3></li>
</ol>
<blockquote>
<p>不会，因为是异步的，例如：刷微博，当你刷的比较快的时候，有些图片没有加载出来图片资源的加载就是一个分线程。整个页面的刷新是主线程 又或者博客的加载，有些页面的文字显示了，而图片设置了懒加载之后显示（减轻服务器的负担，增加用户体验）</p>
</blockquote>
<h2 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h2><h3 id="61-async-await-是一个语法糖，你知道-await-后面如何用吗"><a href="#61-async-await-是一个语法糖，你知道-await-后面如何用吗" class="headerlink" title="61. async/await 是一个语法糖，你知道 await 后面如何用吗"></a>61. async/await 是一个语法糖，你知道 await 后面如何用吗</h3><p><strong>await</strong> 右侧的表达式一般为 <strong>promise</strong> 对象, 但也可以是其它的值</p>
<ol>
<li>如果表达式是 promise 对象, await 返回的是 promise 成功的值</li>
<li>如果表达式是其它值, 直接将此值作为 await 的返回值</li>
</ol>
<p><strong>async </strong> 使用在<strong>定义方法</strong>时修饰, 方法内部就可以使用await</p>
<h3 id="62-this-在-node-里全局的指向是什么"><a href="#62-this-在-node-里全局的指向是什么" class="headerlink" title="62.this 在 node 里全局的指向是什么"></a>62.this 在 node 里全局的指向是什么</h3><blockquote>
<p>global</p>
</blockquote>
<h3 id="63-对象的深拷贝和浅拷贝"><a href="#63-对象的深拷贝和浅拷贝" class="headerlink" title="63.对象的深拷贝和浅拷贝"></a>63.对象的深拷贝和浅拷贝</h3><p><strong>浅拷贝</strong></p>
<blockquote>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<p>浅拷贝只在根属性上在堆内存中创建了一个新的的对象，复制了基本类型的值,但是复杂数据类型也就是对象则是拷贝相同的地址，而深拷贝则是对于复杂数据类型在堆内存中开辟了一块内存地址用于存放复制的对象并且把原有的对象复制过来，这2个对象是相互独立的,也就是2个不同的地址</p>
<blockquote>
<p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p>
</blockquote>
<h3 id="64-git-rebase-和-git-merge-的区别"><a href="#64-git-rebase-和-git-merge-的区别" class="headerlink" title="64.git rebase 和 git merge 的区别"></a>64.git rebase 和 git merge 的区别</h3><p>假设有3次提交A,B,C。</p>
<p>在远程分支origin的基础上创建一个名为”mywork”的分支并提交了，同时有其他人在”origin”上做了一些修改并提交了。</p>
<p>其实这个时候E不应该提交，因为提交后会发生冲突。如何解决这些冲突呢？有以下两种方法：</p>
<p>1、git merge<br>用git pull命令把”origin”分支上的修改pull下来与本地提交合并（merge）成版本M，但这样会形成图中的菱形，让人很困惑。</p>
<p>2、git rebase<br>创建一个新的提交R，R的文件内容和上面M的一样，但我们将E提交废除，当它不存在（图中用虚线表示）。由于这种删除，小李不应该push其他的repository.rebase的好处是避免了菱形的产生，保持提交曲线为直线，让大家易于理解。</p>
<p>在rebase的过程中，有时也会有conflict，这时Git会停止rebase并让用户去解决冲突，解决完冲突后，用git add命令去更新这些内容，然后不用执行git-commit,直接执行git rebase —continue,这样git会继续apply余下的补丁。<br>在任何时候，都可以用git rebase —abort参数来终止rebase的行动，并且mywork分支会回到rebase开始前的状态。</p>
<h3 id="65-DOM事件流包括哪些阶段"><a href="#65-DOM事件流包括哪些阶段" class="headerlink" title="65.DOM事件流包括哪些阶段"></a>65.DOM事件流包括哪些阶段</h3><ul>
<li>事件捕获阶段： 事件对象从Window对象开始沿传播路径向下，依次经过各元素传播至目标元素的父元素；</li>
<li>处于目标阶段 ：事件对象到达目标元素；</li>
<li>事件冒泡阶段： 事件对象从目标元素的父元素开始沿传播路径向上，依次经过各元素传播至Window对象。</li>
</ul>
<p>先捕获再冒泡</p>
<h3 id="66-什么是监听事件，监视事件的方式"><a href="#66-什么是监听事件，监视事件的方式" class="headerlink" title="66.什么是监听事件，监视事件的方式"></a>66.什么是监听事件，监视事件的方式</h3><blockquote>
<p>监听事件就是等待某个事件的发生，当这个事件发生之后，对其做出一个响应。如：鼠标单击一个按钮，单击按钮时打开一个新的页面，或者双击桌面的应用图标，运行一个程序，这都是监听事件的应用。</p>
</blockquote>
<p><strong>监听三要素</strong></p>
<ol>
<li>Event Source(事件源)：监听的目标，假如我们给Button设置一个点击事件，那么Button就为事件源</li>
<li>Event(事件)：发生的事件，不同的事件需要相应的事件监听器进行处理，点击、触摸、按下等都是事件</li>
<li>Event Listener(事件监听器)：不同的事件监听器处理不同的监听事件</li>
</ol>
<p><strong>实现方式</strong></p>
<ol>
<li><p>常用的五种监听方式的实现方式 ：内部类、匿名内部类、外部类、事件源所在类、onClick属性</p>
</li>
<li><p>通过onClick属性实现：在Button控件中有一个”onClick”属性，用于给Button控件设置监听事件，创建一个监听事件作为属性值传入</p>
</li>
</ol>
<h3 id="67-addEventListener-的参数有哪些"><a href="#67-addEventListener-的参数有哪些" class="headerlink" title="67. addEventListener 的参数有哪些"></a>67. addEventListener 的参数有哪些</h3><blockquote>
<p> addEventListener 有三个参数：第一个参数表示事件名称（不含 on，如 “click”）；第二个参数表示要接收事件处理的函数；第三个参数为 useCapture</p>
<p>简明说：事件名称；事件处理函数；捕获还是冒泡。</p>
</blockquote>
<h3 id="68-浏览器输入-URL-之后发生了什么"><a href="#68-浏览器输入-URL-之后发生了什么" class="headerlink" title="68. 浏览器输入 URL 之后发生了什么"></a>68. 浏览器输入 URL 之后发生了什么</h3><p>参考链接：<a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="69-flex-有哪些属性，flex-basis-属性是干嘛的"><a href="#69-flex-有哪些属性，flex-basis-属性是干嘛的" class="headerlink" title="69.flex 有哪些属性，flex-basis 属性是干嘛的"></a>69.flex 有哪些属性，flex-basis 属性是干嘛的</h3><ol>
<li><p>flex-direction属性：flex-direction属性决定主轴的方向（即项目的排列方向）。</p>
</li>
<li><p>flex-wrap属性：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，应该如何换行。</p>
</li>
<li><p>flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
</li>
<li><p>.justify-content属性：justify-content属性定义了项目在主轴上(即横向)的对齐方式。</p>
</li>
<li><p>align-items属性：align-items属性定义项目在交叉轴上(即纵向,垂直)如何对齐。</p>
</li>
</ol>
<p>flex-basis属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</span><br><span class="line">浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line">.item &#123;</span><br><span class="line">    flex-basis: <span class="xml"><span class="tag">&lt;<span class="name">length</span>&gt;</span> | auto; /* default auto */</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</span></span><br></pre></td></tr></table></figure>
<h3 id="70-线程与进程的区别"><a href="#70-线程与进程的区别" class="headerlink" title="70.线程与进程的区别"></a>70.线程与进程的区别</h3><p>官网定义：<br>进程是系统进行资源分配和调度的基本单位</p>
<p>线程是操作系统能够进行运算调度的最小单位</p>
<p>简单理解：<br>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p>
<p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p>
<p>借助阮一峰老师的解释<br>1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>4.一个车间里，可以有很多工人。他们协同完成一个任务。<br>5.线程就好比车间里的工人。一个进程可以包括多个线程。<br>6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。<br>  这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。<br>  这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。<br>10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。<br>  这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</p>
<p>操作系统的设计，因此可以归结为三点：</p>
<p>（1）以多进程形式，允许多个任务同时运行；</p>
<p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p>
<p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>
<h2 id="11-22"><a href="#11-22" class="headerlink" title="11.22"></a>11.22</h2><h3 id="71-区分-‘123’-和-123-的方法"><a href="#71-区分-‘123’-和-123-的方法" class="headerlink" title="71. 区分 ‘123’ 和 123 的方法"></a>71. 区分 ‘123’ 和 123 的方法</h3><ol>
<li><p><strong>typeof</strong></p>
</li>
<li><p><strong>instanceof</strong></p>
</li>
<li><p><strong>toString.call() 最靠谱</strong>  </p>
<ul>
<li><p>toString.call(‘aaa’) <em>// “[object String]”</em></p>
</li>
<li><p>toString.call(123) <em>// “[object Number]”</em></p>
</li>
</ul>
</li>
</ol>
<h3 id="72-Object-defineProperty-是干嘛的，参数有哪些"><a href="#72-Object-defineProperty-是干嘛的，参数有哪些" class="headerlink" title="72.Object.defineProperty 是干嘛的，参数有哪些"></a>72.Object.defineProperty 是干嘛的，参数有哪些</h3><blockquote>
<p>Object.defineProperty 需要三个参数（object , prop, descriptor）</p>
</blockquote>
<p>　    1 object 对象 =&gt;要定义属性的对象。 给谁加<br>　　2 propName 属性名 =&gt; 要定义或修改的属性的名称或 Symbol，要加的属性的名字 【类型：String】<br>　　3 descriptor 属性描述 =&gt; 要定义或修改的属性描述符，加的这个属性有什么样的特性【类型：Object】</p>
<h3 id="73-TCP-IP五层模型-OSI七层模型"><a href="#73-TCP-IP五层模型-OSI七层模型" class="headerlink" title="73. TCP/IP五层模型  OSI七层模型"></a>73. TCP/IP五层模型  OSI七层模型</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*<span class="strong">*五层模型*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">应用层</span></span><br><span class="line"><span class="strong">传输层</span></span><br><span class="line"><span class="strong">网络层</span></span><br><span class="line"><span class="strong">数据链路层</span></span><br><span class="line"><span class="strong">物理层</span></span><br><span class="line"><span class="strong">*</span><span class="strong">*七层模型*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">应用层</span></span><br><span class="line"><span class="strong">表示层</span></span><br><span class="line"><span class="strong">会话层</span></span><br><span class="line"><span class="strong">传输层</span></span><br><span class="line"><span class="strong">网络层</span></span><br><span class="line"><span class="strong">数据链路层</span></span><br><span class="line"><span class="strong">物理层</span></span><br></pre></td></tr></table></figure>
<h3 id="74-应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的"><a href="#74-应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的" class="headerlink" title="74.应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的"></a>74.应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的</h3><p><strong>基于TCP协议的</strong></p>
<ul>
<li>FTP（文件传输协议）：定义了文件传输协议，使用21端口。</li>
<li>TELNET（远程登陆协议）：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</li>
<li>SMTP（简单邮件传输协议）：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</li>
<li>POP3（邮件读取协议）：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</li>
<li>HTTP（超文本传输协议）：是从Web服务器传输超文本到本地浏览器的传送协议。</li>
<li>HTTPS（超文本传输安全协议）</li>
</ul>
<p><strong>基于UDP协议的</strong></p>
<ul>
<li>TFTP（简单文件传输协议）：该协议在熟知端口69上使用UDP服务。</li>
<li>SNMP（简单网络管理协议）：使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>BOOTP（引导程序协议，DHCP的前身）：应用于无盘设备</li>
<li>DHCP（动态主机配置协议）：是一个局域网的网络协议</li>
<li>RIP（路由信息协议）：基于距离矢量算法的路由协议，利用跳数来作为计量标准。</li>
<li>IGMP（Internet组管理协议）</li>
</ul>
<p><strong>基于TCP和UDP协议的</strong></p>
<ul>
<li>DNS（域名系统）：DNS区域传输的时候使用TCP协议。域名解析时使用UDP协议。DNS用的是53号端口。</li>
<li>ECHO（回绕协议）</li>
</ul>
<h3 id="75-HTTP-与-HTTPS-的区别"><a href="#75-HTTP-与-HTTPS-的区别" class="headerlink" title="75.HTTP 与 HTTPS 的区别"></a>75.HTTP 与 HTTPS 的区别</h3><ol>
<li>HTTP 传输的数据都是未加密的，也就是明文的，HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</li>
<li>HTTPS 协议需要 CA 证书，费用较高；</li>
<li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443；</li>
</ol>
<h3 id="76-HTTPS-协议的工作原理"><a href="#76-HTTPS-协议的工作原理" class="headerlink" title="76.HTTPS 协议的工作原理"></a>76.HTTPS 协议的工作原理</h3><ol>
<li>客户使用 HTTPS URL 访问服务器，则要求 web 服务器建立 SSL 链接。</li>
<li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回给客户端。</li>
<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器通过自己的私钥解密出会话密钥。</li>
<li>web 服务器通过会话密钥加密与客户端之间进行通信。</li>
</ol>
<h3 id="77-HTTP-2-0-特性（相比于1-0）"><a href="#77-HTTP-2-0-特性（相比于1-0）" class="headerlink" title="77.HTTP/2.0 特性（相比于1.0）"></a>77.HTTP/2.0 特性（相比于1.0）</h3><ol>
<li>首部压缩</li>
<li>多路复用</li>
<li>二进制分帧</li>
<li>服务端推送</li>
</ol>
<h3 id="78-TCP-和-UDP-之间的区别"><a href="#78-TCP-和-UDP-之间的区别" class="headerlink" title="78.TCP 和 UDP 之间的区别"></a>78.TCP 和 UDP 之间的区别</h3><p><strong>TCP：传输控制协议 UDP：用户数据报协议</strong></p>
<ol>
<li>TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接；</li>
<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。</li>
<li>TCP 是面向字节流，UDP 面向报文；</li>
<li>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多；</li>
<li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节；</li>
</ol>
<h3 id="79-三次握手相关内容"><a href="#79-三次握手相关内容" class="headerlink" title="79.三次握手相关内容"></a>79.三次握手相关内容</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222040742.png" alt="image-20211122204020581"></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</p>
<h5 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第一种回答-2" target="_blank" rel="noopener">第一种回答</a></h5><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li>
</ul>
<h5 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第二种回答-2" target="_blank" rel="noopener">第二种回答</a></h5><ul>
<li><strong>初始状态</strong>：客户端处于 <code>closed(关闭)</code>状态，服务器处于 <code>listen(监听)</code> 状态。</li>
<li><strong>第一次握手</strong>：客户端发送请求报文将 <code>SYN = 1</code>同步序列号和初始化序列号<code>seq = x</code>发送给服务端，发送完之后客户端处于发送等待状态<code>SYN_Send</code>状态。（验证了客户端的发送能力和服务端的接收能力)</li>
<li><strong>第二次握手</strong>：服务端受到 <code>SYN</code> 请求报文之后，如果同意连接，会以自己的同步序列号<code>SYN(服务端) = 1</code>、初始化序列号 <code>seq = y</code>和确认序列号（期望下次收到的数据包）<code>ack = x+ 1</code> 以及确认号<code>ACK = 1</code>报文作为应答，服务器为<code>SYN_Receive</code>状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li>
<li><strong>第三次握手</strong>： 客户端接收到服务端的 <code>SYN + ACK</code>之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 <code>ack = y + 1</code>和数据包的序列号 <code>seq = x + 1</code>以及确认号<code>ACK = 1</code>确认包作为应答，客户端转为确认连接<code>established</code>状态。（分别站在双方的角度上思考，各自ok）</li>
</ul>
<h3 id="79-为什么需要三次握手，两次不行吗？"><a href="#79-为什么需要三次握手，两次不行吗？" class="headerlink" title="79.为什么需要三次握手，两次不行吗？"></a>79.为什么需要三次握手，两次不行吗？</h3><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>为什么要进行三次握手的情况：</p>
<blockquote>
<p>当进行第一次握手，网络不好可能会堵塞，所以连接的请求并没有到达服务器端;但是tcp连接有超时重传的机制，所以再一次发送请求，这时候服务器端接收到了你的请求，他也会返回一个请求给你，这是第二次握手;<br>但是这时候网络环境突然又好了起来，那个堵塞的请求到达了服务器端，服务器端又给你回了一个请求，但是你又不想给服务器发送请求，这时候服务器的资源会进行占用等待你的请求，为了不使服务器的资源继续占用，你又必须发送一个请求给服务器;<br>所以要进行3次握手</p>
</blockquote>
<h3 id="80-四次挥手相关内容"><a href="#80-四次挥手相关内容" class="headerlink" title="80.四次挥手相关内容"></a>80.四次挥手相关内容</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222044207.png" alt="image-20211122204409801"></p>
<p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<strong>半关闭</strong>（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<h5 id="第一种回答-1"><a href="#第一种回答-1" class="headerlink" title="第一种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第一种回答-3" target="_blank" rel="noopener">第一种回答</a></h5><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
<p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<h5 id="第二种回答-1"><a href="#第二种回答-1" class="headerlink" title="第二种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第二种回答-3" target="_blank" rel="noopener">第二种回答</a></h5><ul>
<li><strong>初始化状态</strong>：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。</li>
<li><strong>第一次分手</strong>：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。</li>
</ul>
<blockquote>
<p>假如客户端发送的数据已经发送完毕，发送FIN = 1 <strong>告诉服务端，客户端所有数据已经全发完了</strong>，<strong>服务端你可以关闭接收了</strong>，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN = 1等待服务端确认释放连接状态。</p>
</blockquote>
<ul>
<li><strong>第二次分手</strong>：服务端接收到客户端的释放请求连接之后，<strong>知道客户端没有数据要发给自己了</strong>，<strong>然后服务端发送ACK = 1告诉客户端收到你发给我的信息</strong>，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）</li>
<li><strong>第三次分手</strong>：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，<strong>用于告诉客户端，服务端的所有数据发送完毕</strong>，<strong>客户端你也可以关闭接收数据连接了</strong>。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）</li>
<li><strong>第四次分手</strong>：此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息。<strong>有一个 2 MSL 的延迟等待</strong>。</li>
</ul>
<h3 id="81-React-页面路由参数传递的两种方法-对应实战第11天的一个大坑"><a href="#81-React-页面路由参数传递的两种方法-对应实战第11天的一个大坑" class="headerlink" title="81. React-页面路由参数传递的两种方法(对应实战第11天的一个大坑)"></a>81. React-页面路由参数传递的两种方法(对应实战第11天的一个大坑)</h3><p>list页-&gt;detail页</p>
<p><strong>方法一：路由参数</strong></p>
<p><strong>路由导航：</strong></p>
<p>用“/”</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link <span class="keyword">to</span>=&#123;<span class="string">'/detail/'</span>+item.<span class="keyword">get</span>(<span class="string">'id'</span>)&#125; key=&#123;<span class="keyword">index</span>&#125;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>路由map：</strong></p>
<p>加”/：id”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/detail/:id"</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>detail页获取参数：</strong></p>
<p>准确的获取到id，不需要做处理</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.props</span><span class="selector-class">.match</span><span class="selector-class">.params</span><span class="selector-class">.id</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：查询参数</strong></p>
<p><strong>路由导航：</strong></p>
<p>用“？”</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link <span class="keyword">to</span>=&#123;<span class="string">'/detail?'</span>+item.<span class="keyword">get</span>(<span class="string">'id'</span>)&#125; key=&#123;<span class="keyword">index</span>&#125;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>路由map：</strong></p>
<p>不加”/：id”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/detail"</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>detail页获取参数：</strong></p>
<p>不能准确的获取到id，需要做处理</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.props</span><span class="selector-class">.location</span><span class="selector-class">.search</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div>万一真有土豪呢！！！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/loading.gif" data-original="/images/wechatpay.jpg" alt="Jony J 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/loading.gif" data-original="/images/alipay.png" alt="Jony J 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 前端面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/13/React%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E4%B9%8BBOSS%E6%8B%9B%E8%81%98/" rel="prev" title="React BOSS直聘">
      <i class="fa fa-chevron-left"></i> React BOSS直聘
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/30/react%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/" rel="next" title="React 简书实战">
      React 简书实战 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前端面试题（每日10道）"><span class="nav-text">前端面试题（每日10道）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-15"><span class="nav-text">11.15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-CSS盒模型"><span class="nav-text">1.CSS盒模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-居中垂直对齐"><span class="nav-text">2.居中垂直对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-点击按钮使得页面上的文字颜色发生改变如何实现"><span class="nav-text">3.点击按钮使得页面上的文字颜色发生改变如何实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-html小知识"><span class="nav-text">4.html小知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-CSS选择器的优先级"><span class="nav-text">5.CSS选择器的优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-简明说一下-CSS-link-与-import-的区别和用法？"><span class="nav-text">6.简明说一下 CSS link 与 @import 的区别和用法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-display-none和visibility-hidden的区别？"><span class="nav-text">7.display:none和visibility:hidden的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-rgba和opacity的透明效果有什么不同？"><span class="nav-text">8.rgba和opacity的透明效果有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-position的值，-relative和absolute分别是相对于谁进行定位的？"><span class="nav-text">9.position的值， relative和absolute分别是相对于谁进行定位的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-BFC-是什么？"><span class="nav-text">10. BFC 是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-16"><span class="nav-text">11.16</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-doctype-的作用-声明版本"><span class="nav-text">11.doctype 的作用 声明版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-语义化标签的理解"><span class="nav-text">12.语义化标签的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-important-有什么不好"><span class="nav-text">13.important 有什么不好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-css-选择器的解析顺序，原因"><span class="nav-text">14. css 选择器的解析顺序，原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-css-清除浮动"><span class="nav-text">15.css 清除浮动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-overflow-hidden-是怎么清除浮动的"><span class="nav-text">16. overflow:hidden 是怎么清除浮动的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-HTML5、CSS3-里面都新增了那些新特性？"><span class="nav-text">17.HTML5、CSS3 里面都新增了那些新特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-常见兼容性问题？"><span class="nav-text">18. 常见兼容性问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-固定定位和绝对定位的区别"><span class="nav-text">19.固定定位和绝对定位的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-实现一个两列固定，中间自适应有哪些方法"><span class="nav-text">20.实现一个两列固定，中间自适应有哪些方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-17"><span class="nav-text">11.17</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-伪类选择器和伪元素理解以及区别-可以使用伪类选择器实现隔行变色效果"><span class="nav-text">21.伪类选择器和伪元素理解以及区别(可以使用伪类选择器实现隔行变色效果)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-em和rem"><span class="nav-text">22.em和rem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现"><span class="nav-text">23.我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-setTimeout-和-Promise-哪一个先执行"><span class="nav-text">24.setTimeout 和 Promise 哪一个先执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-canvas-的一些方法"><span class="nav-text">25.canvas 的一些方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-font-face"><span class="nav-text">26.@font-face</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-transform-有哪些属性"><span class="nav-text">27.transform 有哪些属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-轮播图的原理"><span class="nav-text">28.轮播图的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-雪碧图的使用步骤"><span class="nav-text">29.雪碧图的使用步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-js基本数据类型"><span class="nav-text">30.js基本数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-18"><span class="nav-text">11.18</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#31-判断一个值是什么类型有哪些方法？"><span class="nav-text">31.判断一个值是什么类型有哪些方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-null-和-undefined-的区别？"><span class="nav-text">32. null 和 undefined 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-js小知识"><span class="nav-text">33.js小知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-箭头函数有哪些特点？"><span class="nav-text">34. 箭头函数有哪些特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-new操作符具体干了什么呢？"><span class="nav-text">35.new操作符具体干了什么呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-documen-write-和-innerHTML-的区别？"><span class="nav-text">36.documen.write 和 innerHTML 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-ajax过程"><span class="nav-text">37.ajax过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-请解释一下-JavaScript-的同源策略？"><span class="nav-text">38.请解释一下 JavaScript 的同源策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-介绍一下闭包和闭包常用场景？"><span class="nav-text">39.介绍一下闭包和闭包常用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-JavaScript原型，原型链-有什么特点？"><span class="nav-text">40,JavaScript原型，原型链 ? 有什么特点？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-19"><span class="nav-text">11.19</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-javascript的内存-垃圾-回收机制？"><span class="nav-text">41.javascript的内存(垃圾)回收机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-如何解决-ES6-的语法兼容"><span class="nav-text">42. 如何解决 ES6 的语法兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-ES6的一些东西"><span class="nav-text">43.ES6的一些东西</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-如何解决js浮点数运算精度问题"><span class="nav-text">44.如何解决js浮点数运算精度问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-requestanimationframe-有用过吗？知道是干嘛的吗"><span class="nav-text">45.requestanimationframe 有用过吗？知道是干嘛的吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-new操作符的过程"><span class="nav-text">46.new操作符的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-数组的一些方法"><span class="nav-text">47.数组的一些方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-call-apply-的区别"><span class="nav-text">48.call apply 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-箭头函数与普通函数的区别"><span class="nav-text">49.箭头函数与普通函数的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-手写一个函数去重"><span class="nav-text">50.手写一个函数去重</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Array-prototype-includes"><span class="nav-text">1.Array.prototype.includes()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Array-prototype-reduce"><span class="nav-text">2.Array.prototype.reduce()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-20"><span class="nav-text">11.20</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#51-事件冒泡，如何阻止事件冒泡"><span class="nav-text">51.  事件冒泡，如何阻止事件冒泡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-事件循环"><span class="nav-text">52.事件循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-什么是浏览器的同源政策"><span class="nav-text">53.什么是浏览器的同源政策</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-浏览器如何通过jsonp跨域"><span class="nav-text">54.浏览器如何通过jsonp跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-GET和-POST-的区别"><span class="nav-text">55.GET和 POST 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-说说你知道的HTTP-状态码"><span class="nav-text">56.说说你知道的HTTP 状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-js-脚本-defer-和-async-的区别"><span class="nav-text">57.js 脚本 defer 和 async 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-js-如何设置异步"><span class="nav-text">58.js 如何设置异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-关于js暂停执行的方法"><span class="nav-text">59.关于js暂停执行的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-异步-js-脚本在执行的时候主线程会停止吗"><span class="nav-text">60. 异步 js 脚本在执行的时候主线程会停止吗</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-21"><span class="nav-text">11.21</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#61-async-await-是一个语法糖，你知道-await-后面如何用吗"><span class="nav-text">61. async&#x2F;await 是一个语法糖，你知道 await 后面如何用吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-this-在-node-里全局的指向是什么"><span class="nav-text">62.this 在 node 里全局的指向是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-对象的深拷贝和浅拷贝"><span class="nav-text">63.对象的深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-git-rebase-和-git-merge-的区别"><span class="nav-text">64.git rebase 和 git merge 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65-DOM事件流包括哪些阶段"><span class="nav-text">65.DOM事件流包括哪些阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-什么是监听事件，监视事件的方式"><span class="nav-text">66.什么是监听事件，监视事件的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-addEventListener-的参数有哪些"><span class="nav-text">67. addEventListener 的参数有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68-浏览器输入-URL-之后发生了什么"><span class="nav-text">68. 浏览器输入 URL 之后发生了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-flex-有哪些属性，flex-basis-属性是干嘛的"><span class="nav-text">69.flex 有哪些属性，flex-basis 属性是干嘛的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-线程与进程的区别"><span class="nav-text">70.线程与进程的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-22"><span class="nav-text">11.22</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#71-区分-‘123’-和-123-的方法"><span class="nav-text">71. 区分 ‘123’ 和 123 的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-Object-defineProperty-是干嘛的，参数有哪些"><span class="nav-text">72.Object.defineProperty 是干嘛的，参数有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73-TCP-IP五层模型-OSI七层模型"><span class="nav-text">73. TCP&#x2F;IP五层模型  OSI七层模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的"><span class="nav-text">74.应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-HTTP-与-HTTPS-的区别"><span class="nav-text">75.HTTP 与 HTTPS 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-HTTPS-协议的工作原理"><span class="nav-text">76.HTTPS 协议的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-HTTP-2-0-特性（相比于1-0）"><span class="nav-text">77.HTTP&#x2F;2.0 特性（相比于1.0）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78-TCP-和-UDP-之间的区别"><span class="nav-text">78.TCP 和 UDP 之间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-三次握手相关内容"><span class="nav-text">79.三次握手相关内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一种回答"><span class="nav-text">第一种回答</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二种回答"><span class="nav-text">第二种回答</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-为什么需要三次握手，两次不行吗？"><span class="nav-text">79.为什么需要三次握手，两次不行吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-四次挥手相关内容"><span class="nav-text">80.四次挥手相关内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一种回答-1"><span class="nav-text">第一种回答</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二种回答-1"><span class="nav-text">第二种回答</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81-React-页面路由参数传递的两种方法-对应实战第11天的一个大坑"><span class="nav-text">81. React-页面路由参数传递的两种方法(对应实战第11天的一个大坑)</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <br/>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jony J"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jony J</p>
  <div class="site-description" itemprop="description">stay hungry stay foolish！</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wzt2023" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wzt2023" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat.jpg" title="WeChat → &#x2F;images&#x2F;wechat.jpg"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/qq.png" title="QQ → &#x2F;images&#x2F;qq.png"><i class="fab fa-qq fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:710471807@qq.com" title="E-Mail → mailto:710471807@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/problemset/all/" title="https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problemset&#x2F;all&#x2F;" rel="noopener" target="_blank">leetcode</a>
        </li>
    </ul>
  </div>

      </div>
      <div id="music163player">
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=441491828&auto=0&height=66"></iframe>
     
      </div>
    </div> 
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TT 版权所有</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">200k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:02</span>
</div>


 <div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
  </span>
  <span id="busuanzi_container_site_pv">
      &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8YHV7splQK9asMA21ILvvuFe-gzGzoHsz',
      appKey     : 'DwFfLh2EMujmRQp3tkcWjOJI',
      placeholder: "分享你的想法",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <script async src="/js/cursor/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

  
<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>

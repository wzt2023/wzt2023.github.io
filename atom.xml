<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TT の 博客</title>
  
  <subtitle>远方除了遥远，一无所有。</subtitle>
  <link href="https://wzt2022.github.io/atom.xml" rel="self"/>
  
  <link href="https://wzt2022.github.io/"/>
  <updated>2021-11-30T16:00:00.000Z</updated>
  <id>https://wzt2022.github.io/</id>
  
  <author>
    <name>Jony J</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 简书实战</title>
    <link href="https://wzt2022.github.io/2021/12/01/react%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/"/>
    <id>https://wzt2022.github.io/2021/12/01/react%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-11-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react简书实战"><a href="#react简书实战" class="headerlink" title="react简书实战"></a>react简书实战</h1><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><p><strong>实战环节</strong></p><blockquote><p>环境的搭建-&gt;Header组件的编写-&gt;首页的编写-&gt;详情页的编写-&gt;登陆相关业务逻辑的处理-&gt;项目开发结束上线</p></blockquote><p><strong>核心技术点</strong></p><ol><li><p>creat-react-app脚手架工具进行项目的搭建</p></li><li><p>组件化思维进行项目开发</p></li><li><p>深入学习jsx模板语法</p></li><li><p>项目的开发调试</p></li><li><p>虚拟DOM和diff算法，生命周期</p></li><li><p>项目react-transition-group第三方的模块实现复杂的动画效果</p></li><li><p>Redux  Antd UI组件 容器组件 无状态组件等等内容</p></li><li><p>redux使用之中的redux中间键 比如redux-thunk、redux-saga这些新的技术</p></li><li><p>项目样式布局采用最新的Styled-components技术来实现CSS样式的编码，避免组件之间样式的互相影响</p></li><li><p>在进行redux之中数据管理的时候，使用react推出的数据框架 Immutable.js，这个库有效的避免我们对数据的误操作</p><p>如果使用这个库还会涉及redux-immutable这个redux的中间键</p></li><li><p>使用axios这个工具发送ajax请求</p></li></ol><p><strong>react基础知识的巩固</strong></p><blockquote><p>React开发环境的准备：引入.js文件来使用React-&gt;通过脚手架工具来编码-&gt;Create-react-app官网提供的脚手架</p></blockquote><ul><li>创建脚手架： （1）检查node -v的版本 和 npm -v的版本 </li></ul><p>​               （2）输入命令<code>npm install -g create-react-app</code></p><p>  ​                (3) 输入命令<code>create-react-app 文件夹名</code>   </p><p>  ​                (4) 创建之后切换到创建的文件夹 <code>cd 文件名夹</code></p><p>  ​               （5）运行yarn start即可显示 React 主界面 </p><ul><li><p>三个文件：（1）public下的index.html文件 ：页面上显示的html的内容</p><p>​            （2）src下的index.js： 整个react项目的入口文件 会引入App文件</p><p>​            （3）src下的App.js ： 负责页面上显示Hello Word的内容</p></li></ul><h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><blockquote><p>React中的组件</p></blockquote><p>​    定义组件：定义的那个类继承<code>React.Component</code></p><ul><li><p>只要是jsx语法想在react之中正常的运行，就要引入react   例如 组件<APP/>（组件标签都需要大写开头）  render()下的<div> （小写开头的就是h5标签）这些都属于jsx语法</p></li><li><p><code>index.js ``文件中通过ReactDOM将APP这个组件显示在``id=root</code>这个标签下面</p></li><li><p><code>render</code>返回的必须是在一个大的元素之中，但是有时候又不想让这个div显示就可以用<Fragmrnt></Fragmrnt>的占位符来替代最外层的div，不会渲染为任何标签</p></li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input </span><br><span class="line">value=&#123;<span class="keyword">this</span>.state.inputvalue&#125; --inputvalue就是输入框的值</span><br><span class="line">onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; --通过调用该函数来改变改值</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">handleInputChange=(e)=&gt;&#123;</span><br><span class="line">   <span class="keyword">this</span>.state.inputValue = e.<span class="keyword">target</span>.vaue</span><br><span class="line">   console.log(e.<span class="keyword">target</span>.value)  --e.<span class="keyword">target</span>是Input框返回的DOM节点，e.<span class="keyword">target</span>.value返回的就是value值</span><br><span class="line">   console.log(<span class="keyword">this</span>)</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">   inputValue:e.<span class="keyword">target</span>.value</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">/*如果需要实现改变inputvalue的值就在handleInputChange函数里写<span class="keyword">this</span>.state.inputValue = e.<span class="keyword">target</span>.vaue</span><br><span class="line">如果handleInputChange这个函数没有使用箭头函数,此时的<span class="keyword">this</span>为undefined，可以使用ES6的语法将<span class="keyword">this</span>的指向指向为Todolist组件</span><br><span class="line">onChange=&#123;<span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>)&#125;即可。</span><br></pre></td></tr></table></figure><ul><li><p>改变state里的数据不能像上述引用的方式去改变，必须调用setState的方法去改变state里的数据。</p></li><li><p>由于react中state是不允许做任何的改变的immutable的特性，因此我们在做list操作的时候需要先做一个拷贝，对拷贝的数据进行处理 如果改变之后做性能优化的时候就会出现问题。</p></li></ul><blockquote><p>JSX细节语法补充</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>两种注释方法:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注释内容 </span></span><br><span class="line">    &#125;</span><br><span class="line">    或者</span><br><span class="line">    &#123;<span class="comment">/*注释内容*/</span>&#125;</span><br><span class="line"><span class="number">2.</span>为了防止某些标签的内容不被转义  也就是在输入框输入&lt;h1&gt;啦啦啦&lt;h1/&gt;点击提交的时候是显示啦啦啦</span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handledelete&#125;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:item&#125;&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="number">3.</span>在输入框前添加label标签的时候 点击babel标签的内容光标会自动聚焦到输入框上</span><br><span class="line">    &lt;label htmlFor=<span class="string">'insertArea'</span>&gt;输入内容&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">&lt;input id='insertArea' className='input' value=&#123;inputvalue&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新版的react  setState返回的不是一个对象了 要把对象替换成函数</span><br><span class="line">之前: handlechange=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">      &#123;<span class="attr">inputvalue</span>:e.target.value&#125;</span><br><span class="line">    )&#125; </span><br><span class="line"></span><br><span class="line">现在:  <span class="keyword">const</span> value = e.target.value  <span class="comment">//对value值做保存 </span></span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span>=&gt;</span>(&#123;</span><br><span class="line">          inputvalue:value&#125;)) <span class="comment">//写成函数就会变成异步的setState 如果直接写e.target.value就会有问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>React优点</strong></p><ol><li>声明式开发：使得我们能减少大量DOM操作代码量</li><li>可以与其他框架并存</li><li>组件化</li><li>单向数据流</li><li>视图层框架</li><li>函数式编程  好处：用react写出来的项目更容易实现前端自动化测试</li></ol><p><strong>思考</strong></p><blockquote><p>单向数据流：父组件可以向子组件传值，但是子组件不能改变这个值，只能单向进行传递，不能反过来修改。这就说明为什么在修改item项目的时候，为什么不向子组件传递一个list，而要传递index与item了。</p><p>再或者说如果一个父组件有很多个子组件且子组件都共用list，如果将list传给某一个子组件且在该子组件进行修改，会导致其余四个组件中list也发生变化，这样页面出现bug的时候，就不知如何去定位这个bug，对代码的调试是很不方便的，因此要有单向数据流的概念。</p><p>如果真的想修改：首先父组件传递给子组件一个方法，在子组件去调用父组件传的这个方法，然后去做删除。</p><p>React是一个视图层的框架:react并不是什么问题都解决，只帮助你解决数据和页面渲染上的一些东西，至于组件之间怎么传值（就如1给2传递的话就不能按一层一层传了），并不负责，交给其他组件来做，做到大型项目时，react不够用，只能借助它去搭建视图，做组件传值的时候还要借助redux等的数据层的框架来做额外的支撑。</p></blockquote><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111171547264.png" alt="image-20211117154738062"></p><p><strong>巩固知识</strong></p><ul><li>父组件给子组件传值的时候，子组件要对传来的值做类型的限制。如果对传来的值做了isRequired的限制，如果不传就会报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">限制类型有两种放置方法:</span><br><span class="line">    <span class="number">1.</span>TodoItem.propTypes=&#123;</span><br><span class="line">           item:PropTypes.string,</span><br><span class="line">           dele:PropTypes.func,</span><br><span class="line">           index:PropTypes.number</span><br><span class="line">       &#125; --放置在定义完组件的下方（最下方）</span><br><span class="line">    <span class="number">2.</span>TodoItem.propTypes=&#123;</span><br><span class="line">           item:PropTypes.string,</span><br><span class="line">           dele:PropTypes.func,</span><br><span class="line">           index:PropTypes.number</span><br><span class="line">       &#125; --放置在render的上方</span><br></pre></td></tr></table></figure><ul><li><p>当组件的state和props发生改变的时候，render函数就会重新执行。</p></li><li><p>当父组件的render函数被运行时，它的子组件的render都将重新运行一次。</p></li></ul><p><strong>虚拟DOM</strong>(本质上就是一个js对象，之所以能提高性能，因为js去比较js对象不怎么耗性能，去比较真实的DOM很耗性能)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">真实DOM和虚拟DOM性能的差异:</span><br><span class="line">    使用真实DOM</span><br><span class="line">    <span class="number">1.</span> state数据 **初始数据state</span><br><span class="line">    <span class="number">2.</span> JSX 模版  **对应render里的jsx代码</span><br><span class="line">    <span class="number">3</span>．数据+模版结合，生成真实的DOM，来显示</span><br><span class="line">    <span class="number">4.</span> state 发生改变</span><br><span class="line">    <span class="number">5</span>．数据＋模版结合，生成真实的DOM，并不直接替换原始的DOM</span><br><span class="line">    <span class="number">6</span>．新的DOM 和原始的DOM做比对，找差异</span><br><span class="line">    <span class="number">7.</span>找出input框发生了变化</span><br><span class="line">    <span class="number">8.</span>只用新的DOM中的input元素，替换掉老的DOM中的input元素  </span><br><span class="line">        **相比全部替换原始DOM性能提升 </span><br><span class="line">**但是还是消耗了一部分性能:新的DOM和原始DOM做比对的性能 性能提升也不是很明显</span><br><span class="line"></span><br><span class="line">    使用虚拟DOM:</span><br><span class="line">    <span class="number">1.</span> state数据</span><br><span class="line">    <span class="number">2.</span> JSX 模版</span><br><span class="line">    <span class="number">3.</span> 数据+模版结合,生成真实的DOM，来显示</span><br><span class="line">    假设真实DOM为:<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'abc'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="number">4</span>．生成虚拟DOM(虚拟DOM就是一个JS对象，用它来描述真实DOM)(相比上面第四步没有生成虚拟DOM 实看是损耗了性能)</span><br><span class="line">    [ <span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'abc'</span>&#125;, [ <span class="string">'span'</span>,&#123;&#125;,<span class="string">'hello world '</span>]]  <span class="comment">//标签名 标签属性  标签内容  **JS对象 也就是虚拟DOM</span></span><br><span class="line">    <span class="number">5.</span> state 发生变化</span><br><span class="line">    <span class="number">6.</span> 数据+模版生成新的虚拟DOM(极大的提升了性能相比创建真实DOM，js对象创建的过程性能是极低的)</span><br><span class="line">    [ <span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'abc'</span>&#125;,[ <span class="string">'span'</span>, &#123;&#125;,<span class="string">'bye bye'</span> ]]</span><br><span class="line">    <span class="number">7</span>．比较原始虚拟DOM和新的虚拟DOM的区别,找到区别是span中内容(极大的提升性能)</span><br><span class="line">        **比对的是原始的js对象和新的js对象两个js对象的比较是极不损耗性能的。</span><br><span class="line">    <span class="number">8</span>．直接操作DOM，改变span中的内容</span><br></pre></td></tr></table></figure><p><strong>深入了解虚拟DOM</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">实际的流程是:</span><br><span class="line">    <span class="number">1.</span> state数据</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span> JSX 模版（类似于div）</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*JSX -&gt; createElement方法 -&gt; JS对象 -&gt; 真实的DOM</span></span><br><span class="line"><span class="comment">      return &lt;div&gt;item&lt;div&gt; =&gt;等价为</span></span><br><span class="line"><span class="comment">      return React.createElement('div',&#123;&#125;,'item')</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">3</span>．数据 + 模板 生成虚拟DOM(虚拟DOM就是一个JS对象，用它来描述真实DOM)(损耗了性能)</span><br><span class="line">    [ <span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'abc'</span>&#125;, [ <span class="string">'span'</span>,&#123;&#125;,<span class="string">'hello world '</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="number">4.</span> 用虚拟DOM的结构生成真实的DOM，来显示</span><br><span class="line">    &lt;div id=<span class="string">'abc'</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    5. state 发生变化</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    6. 数据+模版生成新的虚拟DOM(极大的提升了性能)</span></span><br><span class="line"><span class="regexp">    [ 'div', &#123;id: 'abc'&#125;,[ 'span', &#123;&#125;,'bye bye' ]]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    7．比较原始虚拟DOM和新的虚拟DOM的区别,找到区别是span中内容(极大的提升性能)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    8．直接操作DOM，改变span中的内容</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">虚拟DOM的好处: 1.性能提升:因为生成真实DOM要耗费很大的性能</span></span><br><span class="line"><span class="regexp"> 2.它使得跨端应用得以实现</span></span><br><span class="line"><span class="regexp">             </span></span><br><span class="line"><span class="regexp">第2点好处的底层原理:没有虚拟DOM React是无法写原生应用的，根本无法在原生（React Native）的应用里被使用。</span></span><br><span class="line"><span class="regexp">例如:没有虚拟DOM，流程就是准备好state数据和模板之后就会渲染DOM，渲染DOM在浏览器是没有问题的，可是在移动端的原生应用里，比如安卓或者ios机器上的代码是不存在DOM这个概念的，所以没有虚拟DOM，在原生的应用里根本无法被使用，所以代码只能运行在浏览器里面，但是有虚拟DOM就不一样了，代码首先会被转化为虚拟DOM（是个js对象）js对象在浏览器可以被识别，在原生的应用里也可以被识别。</span></span><br><span class="line"><span class="regexp">换句话说:虚拟DOM生成好了在浏览器下面，可以将虚拟DOM变成真实DOM，浏览器下面会显示出真实的页面。假设在原生应用里，虚拟DOM生成之后可以不生成真实DOM，而让虚拟DOM生成些原生的组件，这样的话同样的代码包括state，jsx的代码都可以被复用，原生的应用里面可以把对应的页面展示出来。因为生成的虚拟DOM，在哪里都可以运行，只需要在网页上将虚拟DOM转化为真实DOM，这样的话网页就可以跑起来。这使得React既能开发网页应用，还可以开发原生应用</span></span><br></pre></td></tr></table></figure><p><strong>虚拟DOM中的Diff算法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">比较原始虚拟DOM和新的虚拟DOM的区别,找到区别是span中内容(极大的提升性能)</span><br><span class="line">当数据发生改变的时候（state和props的改变，其实props的改变实际上也是父组件的state发生改变），虚拟DOM和真实DOM才会发生比对。</span><br><span class="line">归根到底，当你调用setState的时候，数据才发生改变，然后虚拟DOM才发生比对。（setState是异步的，实际上是为了提升react底层的性能，原因:假设连续调用三次setState，变更三组数据，React会把三次setState合并成一次，只是做了一次虚拟DOM的比对，然后去更新一次DOM，可以额外减去那两次DOM比对带来的性能上的耗费）--性能优化</span><br><span class="line">Diff算法就是两个虚拟DOM比对的算法，React采用的是同层的虚拟DOM比对的算法。左边的为虚拟DOM，当数据改变的时候会生成新的虚拟DOM。同层比对，如果一层不满足要求，之后的也不比对了，后面的就直接废弃掉，整个就替换掉，这样会提升性能。（直观上如果第一层不一样后面都一样，导致后面一样的节点没办法复用，性能很低，怎么会提升性能。实际上是因为同层比对的算法很简单，算法简单带来的是比对的速度会非常快。虽然可能会导致DOM重新渲染上的浪费，但是它大大的减少了两个虚拟DOM之间比对的算法上性能的消耗。） </span><br><span class="line">key值要保持相对稳定，在项目中能不用index做key值就不用。</span><br><span class="line">同层比对和key值比对这些比对的方式都是Diff算法的一部分。--性能优化</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111302200890.png" alt="image-20211130220031980"></p><p><strong>ref</strong></p><blockquote><p>如果ref和setState一起使用的时候，要注意setState是异步函数，不会立马执行。有时候会使得无法正确输出页面DOM的真实情况</p><p>为了避免这种情况，setState还有第二个参数，它是一个回调函数，执行的时机是在等异步的完全结束了再执行。</p></blockquote><p><strong>生命周期函数</strong></p><blockquote><p>生命周期函数指在某一个时刻组件会自动调用的函数（当state和pros变化的时候render就会被调用，render函数就是生命周期函数）  组件一创建就会被调用 constructor函数和生命周期函数</p><p>每一个组件都可以有生命周期函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps,nextState) &#123;</span><br><span class="line"><span class="keyword">if</span>(nextProps.content !==<span class="keyword">this</span>.props.content) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">设置shouldComponentUpdate这个声明周期函数提升了组件的性能，性能提升在避免组件做无谓的render操作。render重新执行就意味着react底层需要对组件重新生成一份虚拟DOM，这样就要和之前的虚拟DOM做比对，虽然虚拟DOM的比对比真实DOM的比对性能要快的多，但是能省略这个比对过程，当然可以节约更多的性能。--性能优化</span><br><span class="line"></span><br><span class="line"> 一般把ajax请求放到ComponentDidMount（）来做</span><br><span class="line"></span><br><span class="line"> 如何发送ajax请求，首先我们要借助一个库  在todolist输入命令行：yarn add axios   </span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line"> axios.get(<span class="string">'/api/todolist'</span>)</span><br><span class="line"></span><br><span class="line">    .then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;alert( <span class="string">'success'</span> )&#125;)</span><br><span class="line"></span><br><span class="line">.catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;alert( <span class="string">'error'</span> )&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><p><strong>CSS过渡动画</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">可以使用关键帧</span><br><span class="line">@keyframes identifier &#123;  </span><br><span class="line">    <span class="number">0</span>% &#123;</span><br><span class="line">        opacity: <span class="number">1</span>;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50</span>% &#123;</span><br><span class="line">        opacity: <span class="number">0.5</span>;</span><br><span class="line">        color: salmon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100</span>%&#123;</span><br><span class="line">        opacity: <span class="number">0</span>;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.hide&#123;</span><br><span class="line">   animation: identifier <span class="number">2</span>s ease-<span class="keyword">in</span> forwards; <span class="comment">//如果没有forwards 动画执行结束</span></span><br><span class="line">&#125;</span><br><span class="line">注意:关键帧当动画执行结束后，最后一帧动画的CSS效果不会被保存下来。加了forwards属性就可以保存下来了</span><br><span class="line">实际上用CSS3开发出的动画具有局限性，涉及js动画的时候就没法处理了。因此得使用下方的模块</span><br></pre></td></tr></table></figure><p><strong>使用react-transition-group实现动画</strong></p><blockquote><p>使用这个可能实现更加复杂的动画效果</p><p>[官网文档API网址]（<a href="https://reactcommunity.org/react-transition-group/" target="_blank" rel="noopener">React Transition Group (reactcommunity.org)</a>）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">App.js文件里</span><br><span class="line">对单个元素实现效果:</span><br><span class="line">&lt;CSSTransition&gt;组件 </span><br><span class="line"></span><br><span class="line">&lt;CSSTransition</span><br><span class="line">            <span class="keyword">in</span>=&#123;<span class="keyword">this</span>.state.show&#125; <span class="comment">//显示的属性</span></span><br><span class="line">            timeout=&#123;<span class="number">1000</span>&#125;       <span class="comment">//显示的时间</span></span><br><span class="line">            classNames=<span class="string">'fade'</span>    <span class="comment">//入场和出场动画属性名匹配</span></span><br><span class="line">            unmountOnExit</span><br><span class="line">            onEntered=&#123;(el)=&gt;&#123;el.style.color=<span class="string">'blue'</span>&#125;&#125;<span class="comment">//入场动画结束时显示的</span></span><br><span class="line">            appear=&#123;<span class="literal">true</span>&#125;<span class="comment">//在入场动画开始前就显示样式  同时在style.css要加上appear属性           </span></span><br><span class="line">     &gt;</span><br><span class="line">            &lt;div&gt;hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>CSSTransition&gt; </span><br><span class="line">style.css文件里</span><br><span class="line">.fade-enter, .fade-appear &#123;</span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.fade-enter-active , .fade-appear-active&#123;</span><br><span class="line">    opacity: <span class="number">1</span>;</span><br><span class="line">    transition: opaciy <span class="number">1</span>s ease-<span class="keyword">in</span> ;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.fade-enter-done &#123;</span><br><span class="line">    opacity: <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">补充:很多相关的API都可以展示效果（例如出场动画第一帧，中间帧等等）</span><br><span class="line"></span><br><span class="line">对多个元素实现效果: </span><br><span class="line">        &lt;TransitionGroup&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="keyword">return</span>( <span class="xml"><span class="tag">&lt;<span class="name">CSSTransition</span></span></span></span><br><span class="line"><span class="xml">                    timeout=&#123;1000&#125; </span></span><br><span class="line"><span class="xml">                    classNames='fade'  </span></span><br><span class="line"><span class="xml">                    unmountOnExit</span></span><br><span class="line"><span class="xml">                    onEntered=&#123;(el)=&gt;&#123;el.style.color='blue'&#125;&#125;</span></span><br><span class="line"><span class="xml">                    appear=&#123;true&#125;</span></span><br><span class="line"><span class="xml">                    key=&#123;index&#125;             </span></span><br><span class="line"><span class="xml">        &gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">CSSTransition</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">        &#125;)&#125;</span><br><span class="line">        &lt;<span class="regexp">/TransitionGroup&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果<code>CSSTransition</code>实现不了的效果就可以去浏览<code>Transition</code>API。(API位置在官网文档最下方)</p><p><strong>redux</strong>（数据层框架）</p><blockquote><p>用一张图很好的表示有无Redux之间的区别（数据的传递更加简化，便捷）</p><p>有Redux不管组件的层次结构有多深，走的流程都是一样的。组件改变-&gt;数据修改-&gt;其余组件取用</p></blockquote><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111181216252.png" alt="img"></p><blockquote><p>整体redux流程：react要去改变store里的数据，首先要一个派发action，action会通过dispatch方法传递给store，store再把之前的数据state和action转发给reducers，reducers是一个函数，当reducers接收到state和action之后，做一些处理之后，会返回一个新的state给到store，store用这个新的state替换掉之前store里的数据，store数据发生改变之后，react组件会感知到store发生改变（用的是<code>store.subcribe()</code>来监测store里状态的改变）这个时候就会从store里面重新取出数据更新组件的内容，页面就发生变化了（<code>this.setState(store.getState())</code>）。 </p></blockquote><p><strong>对于todolist的案例要使点击某项实现删除某项的功能 首先先绑定一个删除的回调函数，派发一个action（某项的索引index会传进去）之后在reducers值删除（由于reduces可以接收state，但是决不能修改state）这里就要对之前的状态做一个深拷贝</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(action.type === <span class="string">'delete_todo_item'</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newstate = <span class="built_in">JSON</span>，parse(<span class="built_in">JSON</span>.stringfy(state));</span><br><span class="line">    newState.list.splice(action.index,<span class="number">1</span>)<span class="comment">//做删除</span></span><br><span class="line">    <span class="keyword">return</span> newstate</span><br><span class="line">&#125;</span><br><span class="line">**注意** 讲解简书这个项目的老师和尚硅谷的老师（好像不需要深拷贝，用的另外一个方法）对redux基础知识的讲解有点出处。</span><br><span class="line">之后会做整合的博客</span><br></pre></td></tr></table></figure><p><strong>对ActionTypes的拆分：目的是为了拼写错误难以找出错误，有了拆分的文件就拼写错误控制台就会直接定位报错的位置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_INPUT_VALUE=<span class="string">'change_input_value'</span></span><br></pre></td></tr></table></figure><p><strong>利用actionCreators对action进行管理：目的提高代码的可维护性，加上前端有自动化测试的工具，如果你把action写在一个文 件里，自动化测试也会非常方便。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">管理前:handleInputChange(e)&#123;</span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">    type:CHANGE_INPUT_VALUE,</span><br><span class="line">    value:e.target.value</span><br><span class="line">&#125;;</span><br><span class="line">store.dispatch(action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">管理后:在actionCreators文件内:</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getInputChangeAction=<span class="function">(<span class="params">value</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:CHANGE_INPUT_VALUE,</span><br><span class="line">    valuee.target.value</span><br><span class="line">&#125;)</span><br><span class="line">handleInputChange(e)&#123;</span><br><span class="line"><span class="keyword">const</span> action = getInputChangeAction(e.target.value)</span><br><span class="line">store.dispatch(action);</span><br><span class="line">&#125;</span><br><span class="line">**高代码的可维护性</span><br><span class="line">*自动化测试也会非常方便</span><br></pre></td></tr></table></figure><p><strong>补充</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> store是唯一的。</span><br><span class="line"><span class="number">2.</span> 只有store能改变自己的内容。</span><br><span class="line"><span class="number">3.</span> Reducer必须是纯函数：给定固定的输入，就一定会有固定的输出，而且不会有副作用。</span><br><span class="line"><span class="number">4</span>。rudux核心API </span><br><span class="line">-creatStore  帮助创建一个store</span><br><span class="line">-store.dispatch 帮助派发action，action会传递给store</span><br><span class="line">-store.getState 帮助获取store里的数据内容</span><br><span class="line">-store.subscribe 帮助订阅store里的改变，只要store改变，store.subscribe接收的这个函数里的回调函数就会执行</span><br></pre></td></tr></table></figure><p><strong>UI组件和容器组件</strong></p><blockquote><p>UI组件负责页面的渲染，容器组件负责页面的逻辑</p></blockquote><p><strong>无状态组件</strong></p><blockquote><p>当一个组件只有render函数的时候，就可以使用无状态组件去替换这个普通组件</p><p>无状态组件相对于普通组件的优势在于：性能比较高，因为无状态组件仅仅是一个函数，普通组件是js的一个类，类生成的对象还有生命周期函数render，执行的东西要远比无状态组件要多得多。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">无状态组件:</span><br><span class="line"><span class="keyword">const</span> 组件名 = （props）=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">普通组件</span><br><span class="line"><span class="class"><span class="keyword">class</span> 组件名 <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">前提:一个组件只有一个render的时候就可以用无状态组件去替换普通组件</span><br></pre></td></tr></table></figure><p><strong>Redux中发送异步请求获取数据  </strong></p><blockquote><p>通过axios发送请求，将后台返回的数据传给store，但是传之前要做几个流程。首先，创建一个actionCreartors的一个函数initListAction，然后在actionTypes（防止拼写错误的文件）定义一个常量</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'./list.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = res.data;</span><br><span class="line">    <span class="keyword">const</span> action = initListAction(data)</span><br><span class="line">    store.dispatch(action)</span><br><span class="line">&#125;)</span><br><span class="line">然后在reducers文件里写</span><br><span class="line"><span class="keyword">if</span>(action.type === INIT_LIST_ACTION)&#123;</span><br><span class="line">    <span class="keyword">const</span> newstate = <span class="built_in">JSON</span>，parse(<span class="built_in">JSON</span>.stringfy(state));</span><br><span class="line">    newState.list = action.data;<span class="comment">//这里的data就是后台传过来的数据</span></span><br><span class="line">    <span class="keyword">return</span> newstate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Redux-thunk中间件进行ajax请求发送</strong></p><blockquote><p>这个中间件可以使我们把异步请求或者复杂的逻辑放到action里处理</p><p>使用redux-thunk可使得创建actionCreartors定义的函数返回的结果可以是一个函数（之前返回的是一个对象），这样就可以发异步请求。 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">const</span> action = getTodoList();</span><br><span class="line">    store.dispatch(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getTodoList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span>&#123;</span><br><span class="line">axios.get( <span class="string">'/list.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = res.data;</span><br><span class="line">  <span class="keyword">const</span> action = initListAction(data);</span><br><span class="line">      dispatch(action);  ***最终执行的</span><br><span class="line">&#125;)</span><br><span class="line">解释:componentDidMount当组件挂载时执行，store派发函数的action实则是派发给store，但是它先会默认自动执行getTodoList()这个函数，随之就会去执行那个异步action，最终派发的也就是dispatch(action)</span><br></pre></td></tr></table></figure><h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p><strong>redux的标准流程</strong></p><blockquote><p>view在redux之中会派发一个action，action通过store的dispatch方法，分发给store，store接收到action连同之前的state一起传给reducer，reducer返回一个新的数据给store，store拿到新的状态去更新旧的状态。</p></blockquote><p> <strong>redux的中间件（redux-saga中间件的使用）</strong></p><blockquote><p>中间件的概念是指action和store之间的中间，指的是redux的中间键（dispatch的升级）因为只有redux有action和store的概念。</p><p>redux-sage远比redux-thunk复杂的多，里面内置了很多API</p><p>有一点区别的是如果上方<code>store.dispatch(action)</code>store传递的action是一个函数，store接收到action之后它不仅可以派发到reducer还可以派发到一个sagas.js的文件里，可以在sagas.js文件里做一些异步逻辑的操作。 </p></blockquote><p><strong>React-Redux的使用</strong></p><ol><li><p>给组件包裹一个<Provider store={store}></Provider>即可让组件使用store里的数据，是react-redux的核心组件。</p></li><li><p>通过redux的connect方法，将组件和store做一个连接 <code>export default connect(mapStateToProps,null)(组件)</code></p></li><li><p>做连接就有一个规则，规则就在第一个参数<code>mapStateToProps</code>（翻译过来就是把store里的数据映射给组件，变成组件的props）</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123; <span class="comment">//state就是store里的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inputvalue:state.inputvalue<span class="comment">//  这一步映射到组件的props &lt;input value=&#123;this.props.inputValue&#125;/&gt;</span></span><br><span class="line">        list:state.list </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>connect的第二个参数是<code>mapDispatchToProps</code>(把store的diapatch方法挂载到props)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123; <span class="comment">//state就是store里的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        changeInputvalue(e)&#123;</span><br><span class="line">           <span class="keyword">const</span> action=&#123;</span><br><span class="line">               type:<span class="string">'change_input_value'</span>  <span class="comment">//组件里就是onclick=&#123;this.props.changeInputvalue&#125;</span></span><br><span class="line">               value:e.target.value</span><br><span class="line">           &#125;</span><br><span class="line">           dispatch(action); <span class="comment">//这一派发就要去写reducer了（匹配类型返回一个新的newState-&gt;newState有inputvalue和list）</span></span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上述的代码还需像之前一样创建actiontypes和actionCreaters文件</span><br><span class="line">connect生成返回的结果就是一个容器组件（可以理解成业务逻辑，数据，方法对UI组件进行包装）</span><br></pre></td></tr></table></figure><h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><h2 id="开始实战"><a href="#开始实战" class="headerlink" title="开始实战"></a>开始实战</h2><p><strong>1、引入reset.css文件</strong></p><blockquote><p>使用reset.css的好处：不同浏览器的内核里面对html，body这样的标签，默认样式得设置是不同的，有可能在某一个浏览器上margin间距值是10，而在另外一个浏览器上这个间距值可能就是8。为了能让我们代码在所有浏览器表现形式都是一致的，首先就得对这些浏览器默认对这些标签的实现进行统一，reset.css就是干这个活，使得这些标签在任何浏览器上的margin padding默认都是一样的。一般在开发项目的时候，首先就要先引入reset.css文件。</p></blockquote><hr><p><strong>2、简书网站头部区块的编写</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">与之前不一样的是，对样式的处理需要创建一个style.js文件（样式写在这个文件里，实际上是一个个的组件，不会影响其他页面的组件样式）</span><br><span class="line">也就是我们这个页面用这个组件时候。这些样式只作用这个组件上面，对其他任何地方都没有影响，有效避免写项目潜在的可能css样式冲突的问题</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HeaderWrapper = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">    height:56px;</span></span><br><span class="line"><span class="string">    background:red;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"> HeaderWrapper是带样式的div标签 </span><br><span class="line"> 用法在header组件里引入后使用  &lt;HeaderWrapper&gt;header&lt;<span class="regexp">/HeaderWrapper&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">注意点:</span></span><br><span class="line"><span class="regexp">1.在style.js写的样式都要加分号``;``不然样式显示不出来</span></span><br><span class="line"><span class="regexp">2.a标签不能设置宽高，必须转换为块元素</span></span><br><span class="line"><span class="regexp">    3.头部导航条设置padding 不然会导致设置的图标重合</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111201038700.png" alt="image-20211120103759703"></p><blockquote><p>就像这样 因此需要去设置头部导航条</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  width:<span class="number">960</span>px;</span><br><span class="line">  height:<span class="number">100</span>%;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line"> +padding-right:<span class="number">70</span>px;</span><br><span class="line"> +box-sizing:border-box</span><br><span class="line">+号为添加的代码，设置一个内聚变以便使其隔开，但是为了保证盒子宽度不变，还得将盒子设置成border-box</span><br><span class="line"></span><br><span class="line">由于搜索框和图标是独立的，因此需要&lt;SearchWrapper&gt;&lt;<span class="regexp">/SearchWrapper&gt;标签将其包裹</span></span><br><span class="line"><span class="regexp">由于该标签被Nav标签包裹且在Nav标签里的子标签都设置了浮动，宽度失效。如果SearchWrapper不设置浮动，宽度就会继承Nav的宽度</span></span><br><span class="line"><span class="regexp">就与搜索框的宽度不一致，因此也得将SearchWrapper设置浮动。</span></span><br></pre></td></tr></table></figure><h2 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h2><p><strong>整体交换的流程</strong></p><blockquote><p>创建store文件夹-&gt;创建index.js ,reducer.js-&gt;编写相应的内容如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">index.js:</span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line">reducer.js:</span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState,action)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之后回到App.js引入</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 回到header组件引入connect,，将组件和store做一个连接</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(Header)</span><br></pre></td></tr></table></figure><blockquote><p>由于初始化的数据需要放在reducer.js上 所以将组件里的数据进行转移      —&gt;形成版本1</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Header/index.js 将状态转移后删除</span><br><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            focused:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">reduer.js</span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    focused:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于header组件里有很多是用到state里的focused,因此得将从state拿改成从props拿， 此时就需要mapState…方法</p><p>将store里状态的focused映射到组件的Props里去,因此就可以将下方图中的state替换成props</p></blockquote><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111220951787.png" alt="image-20211122095058838"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleInputFocus=<span class="function"><span class="params">()</span>=&gt;</span>&#123;     </span><br><span class="line">     <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            focused:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">handleInputBlur=<span class="function"><span class="params">()</span>=&gt;</span>&#123;  </span><br><span class="line">     <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            focused:<span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">这两个方法之前是为了去改变state里的数据 现在数据都不在state里存放了因此就可以连同方法删掉</span><br></pre></td></tr></table></figure><blockquote><p>之后我们要实现当聚焦的时候要改变focused的值 -&gt;一整套流程</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">当你聚焦的时候，改变store里的数据，就要去调用store的dispatch方法，就要把方法定义在mapDispatch...里</span><br><span class="line">Focus=&#123;<span class="keyword">this</span>.handleInputFocus&#125;</span><br><span class="line">onBlur=&#123;<span class="keyword">this</span>.handleInputBlur&#125;</span><br><span class="line">改成</span><br><span class="line">onFocus=&#123;<span class="keyword">this</span>.props.handleInputFocus&#125;</span><br><span class="line">onBlur=&#123;<span class="keyword">this</span>.props.handleInputBlur&#125;</span><br><span class="line">有这个方法之后，首先要改变store里的数据首先要创建一个action</span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps=<span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        handleInputFocus()&#123;</span><br><span class="line">            <span class="keyword">const</span> action = &#123;</span><br><span class="line">                type:<span class="string">'search_focus'</span></span><br><span class="line">            &#125;;</span><br><span class="line">        dispatch(action)  </span><br><span class="line">        &#125;,</span><br><span class="line">        handleInputBlur()&#123;</span><br><span class="line">            <span class="keyword">const</span> action = &#123;</span><br><span class="line">                type:<span class="string">'search_blur'</span></span><br><span class="line">            &#125;;</span><br><span class="line">            dispatch(action)</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">reducers.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  (state = defaultState,action)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.type===<span class="string">'search_focus'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.type===<span class="string">'search_blur'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><blockquote><p>我们把之前组件里的数据移除了，转移到redux公共存储的框架进行存储。Header组价就变成了一个无状态组件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无状态组件的写法 <span class="keyword">const</span> Header = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="number">1.</span>render以下的内容（不包括render）</span><br><span class="line">    <span class="number">2.</span>所有的<span class="keyword">this</span>去掉</span><br><span class="line">&#125;</span><br><span class="line">到这形成第<span class="number">2</span>版</span><br></pre></td></tr></table></figure><h2 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h2><blockquote><p>安装redux-devtools-extension工具使得网页可以显示redux组件操作状态的变化</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,composeEnhancers())</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222124933.png" alt="image-20211122212415727"></p><blockquote><p>由于reducers存放数据和数据的处理，随着功能的强大，数据量会越来越大，因此不能都放在reducers里存储。</p><p>于是在head文件夹下创建一个store的文件夹，创建一个header下的reducer，将store里的reuders移至header的reducers</p><p>全局的reducer作为一个仓库，专门来放置各个组件部分的reducers。 此时功能尚未实现，因为header下的index.js文件mapState…方法用的是全局的reducer，因此得修改如下</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        focused: state.header.focused</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">仓库reducers</span><br><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> headreducer&#125; <span class="keyword">from</span> <span class="string">'../common/header/store'</span>  <span class="comment">//间接引入reducers 目录结构会少两层 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line"></span><br><span class="line">    header:headreducer</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br><span class="line">间接引入reducers 目录结构会少两层 因为header下的reduces间接由header下的index.js文件管理了 。引入的时候就方便了</span><br></pre></td></tr></table></figure><h2 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h2><blockquote><p>由于现在在header组件下创建了一个头部的reducers，由于在头部组件里改变数据的时候派发action，然后reducer接收action然后去修改数据，之前课程说过action不要写成对象，类型也不要写成字符串。用actionCreate去创建action，同时类型定义成常量。</p><p>按这个做下去逻辑太绕了，不易理解。大改文件夹存放的位置 </p></blockquote><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111231119404.png" alt="image-20211123111850307"></p><blockquote><p>在reducer.js文件里,不能对原始的state做修改，为了防止这一点得引入facebook团队研发出来的一个库：immutable.js</p><p>它会帮助我们生成一个immutable对象 （不可改变的）如果state是immutable对象就是不可以被改变，就不会出问题。</p><p>immutable这个库提供了一个fromJS方法，可以帮助我们把一个js对象转化为immutable对象，用这个方法把数据对象（js对象）</p><p>转化为immutable对象。此时header下的index文件的mapState方法里的数据已经转化为immutable类型的数据（state.header）</p><p>如果是immutable类型的数据，再进行state.header.focused这种语法是不合理的了。immutable.js里面调用state.header里的属性不能通过点focused的方式来调用，得通过点get的方法传入focused的属性来获取对应的属性。此时不会报错，但是点击的时候就会报错报错的原因在与当你派发一个action的时候，传入reducers返回的是一个普通对象，普通对象时没有get方法的 为了防止这种情况应该这样写（没修改前与修改前的代码）</p><p>总结：借助immutable这个库避免编写改变数据里state的情况</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">未修改前的reducers:</span><br><span class="line"><span class="keyword">import</span> &#123;SEARCH_FOCUS,SEARCH_BLUR&#125; <span class="keyword">from</span> <span class="string">'../constant'</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">     focused:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_FOCUS)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_BLUR)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            focused:<span class="literal">false</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br><span class="line"></span><br><span class="line">修改前的header下的index.js</span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        focused:state.header.focused</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修改后的reducers:</span><br><span class="line"><span class="keyword">import</span> &#123;SEARCH_FOCUS,SEARCH_BLUR&#125; <span class="keyword">from</span> <span class="string">'../constant'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">'immuatble'</span></span><br><span class="line"><span class="keyword">const</span> defaultState = fromJS(&#123;</span><br><span class="line">     focused:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_FOCUS)&#123;</span><br><span class="line">       <span class="comment">// immutable对象的set方法，会结合之前immutable对象的值和设置的值,返回一个全新的对象，并没有改变原始的state</span></span><br><span class="line">        <span class="keyword">return</span> state.set(<span class="string">'focused'</span>,<span class="literal">true</span>) <span class="comment">//这里的变更不是直接变更</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.type===SEARCH_BLUR)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.set(<span class="string">'focused'</span>,<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br><span class="line"></span><br><span class="line">修改后的header下的index.js</span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        focused:state.header.get(<span class="string">'focused'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 即便是修改后的index.js 由于state是js对象，state.header是immutable对象 所以去调用focused属性的时候，数据获取的行为是不统一的。（不太靠谱）因此我们想让state也成为immutable对象，而不是js对象</p><p>state对应的数据是在redux下reducers里的index.js里创建的，因此我们要依赖第三方的模块 redu-immutable</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux-immutable'</span><span class="comment">//只要combineReducers是由这个库引入的reducer就是immuable对象了  </span></span><br><span class="line">之后回到header下改如下代码即可</span><br><span class="line">focused:state.get(<span class="string">'header'</span>).get(<span class="string">'focused'</span>)</span><br><span class="line">可以简写为 focused:state.getIn([<span class="string">'header'</span>,<span class="string">'focused'</span>])</span><br></pre></td></tr></table></figure><p><strong>下一阶段（搜索区域的布局） F11退出全屏</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  &lt;SearchList&gt;</span><br><span class="line">    &lt;SearchInfoItem&gt;教育&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">    &lt;SearchInfoItem&gt;简书&lt;/</span>SearchInfoItem&gt;</span><br><span class="line">    &lt;SearchInfoItem&gt;生活&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">    &lt;SearchInfoItem&gt;投稿&lt;/</span>SearchInfoItem&gt;</span><br><span class="line">    &lt;SearchInfoItem&gt;历史&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>SearchList&gt;</span><br><span class="line">由于子元素设置浮动了 父元素的高度无法被撑起所以给父元素设置一个BFC</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SearchList = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">    overflow:hidden;//此时只是开启BFC使其高度和宽度不丢失</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">之后就是该列表聚焦的时候显示，不聚焦的时候不显示，设置一个函数，给函数接收一个变量show。</span><br><span class="line">如果show为真就返回整个列表，假就返回<span class="literal">null</span></span><br><span class="line">最后再调用一下这个方法   &#123;getListArea(props.focused)&#125; 传入focused的值即可</span><br></pre></td></tr></table></figure><p><strong>换一批的功能</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">此时的header是一个无状态组件，之后还要添加很多功能，就会出现函数嵌套函数，就会使Header变得越来越庞大，不好维护</span><br><span class="line">因此还是使用Component组件 将原来props前加一个<span class="keyword">this</span> 且将显示列表的方法定义在组件里接口</span><br><span class="line"></span><br><span class="line">由于列表里的内容实际上是通过ajax数据获取的，因此header里不进要有focused的数据还得有列表的内容</span><br><span class="line">因此在header的reducer里加一个list:[]; </span><br><span class="line">当导航的input框做了聚焦之后，就要获取ajax数据，也就是onFocus的时候，onFocus执行的是handleInputFocus这个方法</span><br><span class="line">找到这个方法在方法里获取ajax数据，之前的课程有说过，获取ajax数据一般来说不会直接写在组件里，会把异步的操作放到action，或者放到redux-saga里面进行处理，这里统一使用redux-thunk，把异步操作都放至action里处理</span><br><span class="line">redux-thunk其实就是action和store之间的中间件 其实就是对dispatch方法的升级</span><br><span class="line">因此得写在创建store之前被使用</span><br><span class="line"><span class="keyword">import</span> &#123;createStore,compose,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,composeEnhancers(</span><br><span class="line">    applyMiddleware(thunk)</span><br><span class="line">))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line">有了redux-thunk之后，就可以去action里面做异步操作了</span><br><span class="line">dispatch(getList());去派发这样一个action</span><br><span class="line">以前的action返回的是一个对象，现在可以返回函数</span><br><span class="line">函数里写个输出<span class="number">123</span> 只要聚焦控制台就会显示<span class="number">123</span></span><br><span class="line">发请求前要先安装包axios  </span><br><span class="line">axios.get(<span class="string">'/api/headerList.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ERROR'</span>);         </span><br><span class="line">        &#125;)       </span><br><span class="line">&#125;</span><br><span class="line">在public文件夹下创建一个api文件夹之后在创建headerList.json的文件输入一下数据 之后在网页访问这个链接页面就可以显示数据</span><br><span class="line">原理:首先先到功能目录下看看有没有对应的路由，找不到就会去public目录下找api的headerList.json，找到后就会把文件的内容输出出来</span><br><span class="line">通过这个特性，我们可以创建一些假数据，保存。</span><br><span class="line">模拟的数据要和后端对的数据要保持一直，就是定一下格式</span><br><span class="line">public下的api下的header.json添加模拟的数据 此时:</span><br><span class="line">axios.get(<span class="string">'/api/headerList.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res <span class="comment">// 当你点击搜索的时候，控制台已经有输出了 见下图</span></span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ERROR'</span>);         </span><br><span class="line">        &#125;)       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111231623925.png" alt="image-20211123162311226"></p><blockquote><p>之前header下的reducer里定义了一个list：[]，现在发送了一个ajax请求，获取到了结果，现在就是希望能用获取的结果替换那个空数组</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">action.js文件里</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getList = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;  <span class="comment">//返回函数，就要就是去派发一个异步的请求</span></span><br><span class="line">        axios.get(<span class="string">'/api/headerList.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> data = res.data;</span><br><span class="line">            <span class="keyword">const</span> action = changeList(data.data);</span><br><span class="line">            dispatch(action)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ERROR'</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">reducer.js文件里</span><br><span class="line"><span class="keyword">if</span>(action.type===CHANGELIST)&#123;</span><br><span class="line">    <span class="keyword">return</span> state.set(<span class="string">'list'</span>,action.data) </span><br><span class="line">    <span class="comment">//console.log(action);//返回的是&#123;type: "change_list", data: Array(50)&#125;</span></span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">这样写实际上还是有问题的：创建store，默认list是一个空数组，fromJS方法会将js对象转换为immuable对象，list是个数组，也会变成immuable的数组，但是调用<span class="keyword">set</span>去改变list的时候，action.data实际上是一个普通的数组， list数组会由immuable数组变成一个普通的数组，这样的话数据类型就会变了，解决这个问题</span><br><span class="line">export const changeList = (data) =&gt;(&#123;</span><br><span class="line">    type:CHANGELIST,</span><br><span class="line">    data:fromJS(data)</span><br><span class="line">&#125;)</span><br><span class="line">这样转换一下 <span class="keyword">const</span> action = changeList(data.data);<span class="comment">//输出data后的结果</span></span><br><span class="line">这里派发的时候数据就会转换成immuable的数据类型。这样reducer里接收到action的数据类型也就是immuable类型了。</span><br><span class="line">做到这里就可以使用redux的插件去查看显示header里面就list的数组了</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111231710590.png" alt="image-20211123170830305"></p><blockquote><p>之后就是将list里的数组逐一放至getListArea的方法里展示</p></blockquote><p><strong>总结</strong></p><blockquote><p>实际上讲的就是项目中用react-thunk发送ajax数据。获取到数据之后，存到store里面，然后在页面上进行显示，有几个关键点</p><p>第一个我们把异步获取的逻辑都拆分到actions文件夹下，如果你想拆分到这里来，就要求action返回的对象不能是一个js对象，而是一个函数，如果要返回的是一个函数就必要要用redux-thunk这个中间件，这是第一个重点</p><p>第二个当我们获取到数据，想要改变store里的数据的时候，我们要注意redux里的list因为外层包裹了一个fromJS，它会在创建的时候，会把内部的list定义的数组由一个普通的数组转换为immuable类型的数组，但是想直接改变这个状态的数组，就会把之前immuable类型变成普通数组的类型，因为我们就要再action之前传递action之前就要把数据转换为immuable类型的数据，这样数据统一就不会有问题。</p><p>页面循环展示数据，就要调用map方法通过对每一项进行循环展示，对对应的内容都展示在页面上  —功能实现</p></blockquote><p><strong>避免无意义的ajax请求发送（上方衔接最后补充的内容）</strong></p><blockquote><p>每点击一次焦点的时候就会发送一次ajax请求。实际上列表中的数据获取一次就可以了</p><p>解决问题：给<code>handleInputFocus(list)</code>传入list 然后输出list可以看出第一次请求的时候list.size是0，之后就是50，</p><p>所以控制当size为0的时候才发送请求，之后不等于0的时候就不发生了，这样就避免了每次获取焦点的时候都发一个ajax请求，从而做到性能上的调优。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> handleInputFocus(list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.size===<span class="number">0</span>)&#123;</span><br><span class="line">                  dispatch(getList());</span><br><span class="line">            &#125;  或者 (list.size&gt;<span class="number">0</span>)&amp;&amp;dispatch(getList());意思都一样</span><br><span class="line">            dispatch(searchFocus());</span><br><span class="line">        &#125;,</span><br><span class="line">            </span><br><span class="line">样式加一个cursor:pointer 可使鼠标放上去有个小手的标志。</span><br></pre></td></tr></table></figure><p> <strong>路由</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter,Route&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line">BrowserRouter代表路由 Route代表路由规则</span><br><span class="line">首先先引入路由组件</span><br><span class="line">下载包:npm add react-router-dom</span><br><span class="line">**注意** 前两周这个包刚更新过如果按之前的编码规则会使得路由组件无法显示(太坑了官网也不发布，害我整了半天)</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111242012568.png" alt="image-20211124201227148"></p><blockquote><p>把首页组件拆分成一个个小的组件</p><p>  外层元素：margin-left: -18px;</p><p>  内层元素：margin-left: 18px;、</p><p>  这样就可以充分利用左侧栏的宽度，使其保持一直</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   &lt;TopicItem&gt;</span><br><span class="line">               &lt;img</span><br><span class="line">        className=<span class="string">'topic-pic'</span></span><br><span class="line">        src=<span class="string">'//upload.jianshu.io/collections/images/261938/man-hands-reading-boy-large.jpg?imageMogr2/auto-orient/strip'</span> alt=<span class="string">'niao'</span></span><br><span class="line">        /&gt;</span><br><span class="line">            社会热点</span><br><span class="line">&lt;<span class="regexp">/TopicItem&gt;</span></span><br><span class="line"><span class="regexp">这是一个标题数据，之后我们拿来用的时候需要从redux里取 数据都存在store里，而Topic是home的自组件 而home是APP的子组件</span></span><br><span class="line"><span class="regexp">因此Topic是APP的自组件 想使用store里的数据需要connect做连接</span></span><br><span class="line"><span class="regexp">定义一个获取状态的方法 mapState,从reducer获取到list给Topic组件遍历即可</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;TopicWrapper,TopicItem&#125; <span class="keyword">from</span> <span class="string">'../style'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topic</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;TopicWrapper&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.list.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;TopicItem key=&#123;item.get(<span class="string">'id'</span>)&#125;&gt;</span><br><span class="line">                        &lt;img</span><br><span class="line">                            className=<span class="string">'topic-pic'</span></span><br><span class="line">                            src=&#123;item.get(<span class="string">'imgUrl'</span>) &#125; <span class="comment">//reducer.js定义好的</span></span><br><span class="line">                            alt=<span class="string">"nihao"</span>/&gt;</span><br><span class="line">                        &#123;item.get(<span class="string">'title'</span>)&#125;</span><br><span class="line">                    &lt;<span class="regexp">/TopicItem&gt;</span></span><br><span class="line"><span class="regexp">                    )</span></span><br><span class="line"><span class="regexp">                &#125;)&#125;</span></span><br><span class="line"><span class="regexp">      </span></span><br><span class="line"><span class="regexp">            &lt;/</span>TopicWrapper&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapState  =<span class="function">(<span class="params">state</span>) =&gt;</span>(&#123;</span><br><span class="line">    list: state.get(<span class="string">'home'</span>).get(<span class="string">'topicList'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapState,<span class="literal">null</span>)(Topic)<span class="comment">//因为不需要修改状态 所以暂且先传入一个null</span></span><br></pre></td></tr></table></figure><h2 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h2><blockquote><p>页面的组件，首先闲在reducer的初始状态定义好相应的信息</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">articleList:[&#123;</span><br><span class="line">       id: <span class="number">1</span>,</span><br><span class="line">       title:<span class="string">'大数据分析可视化平台'</span>,</span><br><span class="line">       desc:<span class="string">'支持直连MySQL、SQL Server、PostgreSQL、Oracle、SAP HANA、Hive等数据源，也可上传本地Excel/Csv文件或通过API连接数据。可完成多源交互分析'</span>,</span><br><span class="line">       imgUrl:<span class="string">'https://lupic.cdn.bcebos.com/20200412/3048304592_14_800_600.jpg'</span></span><br><span class="line">   &#125;,&#123;</span><br><span class="line">       id: <span class="number">2</span>,</span><br><span class="line">       title:<span class="string">'大数据分析可视化平台'</span>,</span><br><span class="line">       desc:<span class="string">'支持直连MySQL、SQL Server、PostgreSQL、Oracle、SAP HANA、Hive等数据源，也可上传本地Excel/Csv文件或通过API连接数据。可完成多源交互分析'</span>,</span><br><span class="line">       imgUrl:<span class="string">'https://lupic.cdn.bcebos.com/20200412/3048304592_14_800_600.jpg'</span></span><br><span class="line">   &#125;],</span><br></pre></td></tr></table></figure><blockquote><p>之后在组件里通过调用connect 里调用因为这个状态是immuable数据类型 因此需要用get方法来引入</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;RecommendWrapper,RecommendItem&#125; <span class="keyword">from</span> <span class="string">'../style'</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="comment">// import imgone from '../1.jpg'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recommend</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RecommendWrapper&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">this</span>.props.list.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span>   <span class="xml"><span class="tag">&lt;<span class="name">RecommendItem</span> <span class="attr">imgUrl</span>=<span class="string">&#123;item.get(</span>'<span class="attr">imgUrl</span>')&#125; <span class="attr">key</span>=<span class="string">&#123;item.get(</span>'<span class="attr">id</span>')&#125;/&gt;</span></span></span><br><span class="line">                   &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;<span class="regexp">/RecommendWrapper&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapState=(state)=&gt;(&#123;</span></span><br><span class="line"><span class="regexp">    list: state.getIn(['home','recommendList'])</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">export default connect(mapState)(Recommend)</span></span><br></pre></td></tr></table></figure><blockquote><p>首先所有的数据内容都存在前端的代码里，都是写死的，实际做项目的时候，通过接口来获取的，不能写死。</p><p>在public下的api定义一个接口home.json。之后在home组件下借助componentDidMount这个声明周期函数来发ajax请求去获取数据，获取了数据，（当组件挂载完毕）。就要将获取的数据取修改store里初试的数据</p><p>所以要创建一个action，派发给store，需要store和组件建立连接</p><p>修改store里的数据也就是状态 就得使用connect的第二个参数，通过这个函数就可以定义一个方法将action派发给store</p><p>因为UI组件不能和store直接通信，只能通过容器组件。派发给store之后store就会派发给reducer。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'change_home_data'</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(action);<span class="comment">//返回的就是ajax请求获取出来的内容</span></span><br><span class="line">        state.set(<span class="string">'topicList'</span>,action.topicList)</span><br><span class="line"><span class="comment">//action.topicList是JS对象而上面的topicList是immuable对象不能替换因此要在前面加一个fromJS（action.topicList）</span></span><br><span class="line">由于是多个对象可以用state的一个方法做一个合并 这样就实现了通过ajax异步的形式获取到了首页的内容</span><br></pre></td></tr></table></figure><blockquote><p>上述的操作都是不合适的因为UI组件不应该有太多的业务逻辑，发ajax请求不应该在UI组件里发，放在容器组件里</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">修改前</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="built_in">console</span>.log(res);<span class="comment">//如果成功会打印 因为这个路径下有这个文件 因此是可以成功的</span></span><br><span class="line">            <span class="keyword">const</span> action=&#123;</span><br><span class="line">                type:<span class="string">'change_home_data'</span>,</span><br><span class="line">                topicList:result.topicList,</span><br><span class="line">                articleList:result.articleList,</span><br><span class="line">                recommendList:result.recommendList</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData(action)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatch = <span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    changeHomeData(action)&#123;</span><br><span class="line">        dispatch(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="literal">null</span>,mapDispatch)(Home)  </span><br><span class="line">第一次修改后：</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">       </span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData()</span><br><span class="line">            </span><br><span class="line">     </span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatch = <span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    changeHomeData()&#123;</span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action=&#123;</span><br><span class="line">                type:<span class="string">'change_home_data'</span>,</span><br><span class="line">                topicList:result.topicList,</span><br><span class="line">                articleList:result.articleList,</span><br><span class="line">                recommendList:result.recommendList</span><br><span class="line">            &#125;</span><br><span class="line">        dispatch(action);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="literal">null</span>,mapDispatch)(Home)</span><br></pre></td></tr></table></figure><blockquote><p>再次升级 ajax请求不放在容器组件里 放在action里 通过调用那个函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;      </span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData()          </span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatch = <span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    changeHomeData()&#123;</span><br><span class="line">        dispatch(getHomeInfo())<span class="comment">//因为派发的action是一个函数 且返回的是一个函数。如果这个action是个函数，就会顺序执行这个函数，执行这个函数action就会去派发 页面就重新执行了</span></span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>而后action里代码可以做升级</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">action下home.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getHomeInfo = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;  <span class="comment">//返回函数，就要就是去派发一个异步的请求</span></span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action=&#123;</span><br><span class="line">                type:<span class="string">'change_home_data'</span>,</span><br><span class="line">                topicList:result.topicList,</span><br><span class="line">                articleList:result.articleList,</span><br><span class="line">                recommendList:result.recommendList</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch(action);</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">优化后</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">const</span> changeHomeData=<span class="function">(<span class="params">result</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:<span class="string">'change_home_data'</span>,</span><br><span class="line">    topicList:result.topicList,</span><br><span class="line">    articleList:result.articleList,</span><br><span class="line">    recommendList:result.recommendList</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getHomeInfo = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;  <span class="comment">//返回函数，就要就是去派发一个异步的请求</span></span><br><span class="line">        axios.get(<span class="string">'./api/home.json'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action = changeHomeData(result)</span><br><span class="line">            dispatch(action);  或者写成    dispatch(changeHomeData(result))</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">之后让type成常量 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;LoadMore onClick=&#123;<span class="keyword">this</span>.props.getMore&#125;&gt;更多文字&lt;<span class="regexp">/LoadMore&gt;*** 不用写()</span></span><br></pre></td></tr></table></figure><blockquote><p>对于页数的编码，首先先在reducers定义一个初始状态，定义完之后就可以回到List组件里定义mapState方法中的page：state…</p><p>定义完之后将UI组件里的LoadMore里的onClick的回调函数设置为箭头函数 传page进去， 下面调用方法的函数也传page</p><p>之后发异步action</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &lt;LoadMore onClick=&#123;()=&gt;<span class="keyword">this</span>.props.getMore(<span class="keyword">this</span>.props.page)&#125;&gt;更多文字&lt;<span class="regexp">/LoadMore&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">          </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapState =<span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;</span><br><span class="line">    list:state.get(<span class="string">'home'</span>).get(<span class="string">'articleList'</span>),</span><br><span class="line">    page:state.get(<span class="string">'home'</span>).get(<span class="string">'articlePage'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatch=<span class="function">(<span class="params">dispatch</span>)=&gt;</span>(&#123;</span><br><span class="line">    getMore(page)&#123;</span><br><span class="line">        dispatch(getMoreList(page))</span><br><span class="line">    &#125;&#125;)</span><br><span class="line"></span><br><span class="line">异步action</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getMoreList=<span class="function">(<span class="params">page</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">      </span><br><span class="line">        axios.get(<span class="string">'./api/homeList.json?page='</span> + page).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = res.data.data;</span><br><span class="line">            <span class="keyword">const</span> action = AddHomeData(result,page+<span class="number">1</span>)   <span class="comment">//这里每次点击更多的时候页面加1</span></span><br><span class="line">            dispatch(action);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;&#125;</span><br><span class="line">每一个异步action都有一个同步action</span><br><span class="line"><span class="keyword">const</span> AddHomeData = <span class="function">(<span class="params">list,nextpage</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:ADD_HOME_LIST,</span><br><span class="line">    list:fromJS(list),   </span><br><span class="line">    nextpage</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">之后就回到reducer 去更新原始页面的状态</span><br></pre></td></tr></table></figure><p><strong>回到顶部</strong></p><blockquote><BackTop onClick={this.handleScrollTop}>回到顶部</BackTop></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleScrollTop() &#123;</span><br><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//回到顶部 </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">之后实现页面再顶部的时候不显示回到顶部这个图标  在底部才实现</span><br></pre></td></tr></table></figure><blockquote><p>然后在home.js下的传入connect的第一个参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapState =<span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;</span><br><span class="line">    showScroll:state.getIn([<span class="string">'home'</span>,<span class="string">'showScroll'</span>])  <span class="comment">//由于reducer的初始值有定义</span></span><br><span class="line">&#125;)</span><br><span class="line">控制这个值的<span class="literal">true</span>和<span class="literal">false</span> 来实现是否显示回到顶部的功能</span><br><span class="line">&#123;<span class="keyword">this</span>.props.showScroll ? <span class="xml"><span class="tag">&lt;<span class="name">BackTop</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleScrollTop&#125;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">BackTop</span>&gt;</span></span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><blockquote><p>在组件刚挂载的时候绑定一个监听事件来监测滚轮是是否滑动</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">            <span class="keyword">this</span>.props.changeHomeData()</span><br><span class="line">            <span class="keyword">this</span>.bindEvents();</span><br><span class="line">&#125;</span><br><span class="line">    bindEvents()&#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,<span class="keyword">this</span>.props.changeScrollTopShow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用的方法:</span><br><span class="line">   changeScrollTopShow(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);  <span class="comment">//打印的就是下图一个个事件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111260957851.png" alt="image-20211126095729529"></p><blockquote><p>如果不打印事件 换做</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.scrollTop(获取滚动条位置)要获取当前页面的滚动条纵坐标位置</span><br><span class="line"> changeScrollTopShow()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">    &#125;</span><br><span class="line">我也不明白为什么我打印出的是小数</span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261002063.png" alt="image-20211126100207963"></p><blockquote><p>之后将这个值设置大于400的时候显示回到顶部，否则隐藏，因此我们要改reducer里的数据，通过发action进行改</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">changeScrollTopShow()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.documentElement.scrollTop&gt;<span class="number">400</span>)&#123;</span><br><span class="line">            dispatch(toggleTopShow(<span class="literal">true</span>))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dispatch(toggleTopShow(<span class="literal">false</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">action.js文件       </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTopShow=<span class="function">(<span class="params">show</span>)=&gt;</span>(&#123;</span><br><span class="line">    type:TOGGLE_SCROLL_TOP,</span><br><span class="line">    show</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">reducer.js文件</span><br><span class="line"> <span class="keyword">case</span>  TOGGLE_SCROLL_TOP:</span><br><span class="line">       <span class="keyword">return</span> state.set(<span class="string">'showScroll'</span>,action.show)</span><br><span class="line">功能实现 但是需要注意的是创建组件组件挂载的时候，往<span class="built_in">window</span>上绑定的scroll事件的监听的时候，一定要把scroll事件监听在<span class="built_in">window</span>上移除</span><br><span class="line">这样组件的事件就不会影响其他的组件</span><br><span class="line">reducer.js代码优化:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CHANGE_HOME_DATA:</span><br><span class="line">    <span class="keyword">return</span> state.merge(&#123;</span><br><span class="line">        topicList:fromJS(action.topicList),</span><br><span class="line">        articleList:fromJS(action.articleList),</span><br><span class="line">        recommendList:fromJS(action.recommendList)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    定义一个方法</span><br><span class="line">    <span class="keyword">const</span> changeHomeData=<span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.merge(&#123;</span><br><span class="line">            topicList:fromJS(action.topicList),</span><br><span class="line">            articleList:fromJS(action.articleList),</span><br><span class="line">            recommendList:fromJS(action.recommendList)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    然后调用： </span><br><span class="line">    <span class="keyword">case</span> CHANGE_HOME_DATA:</span><br><span class="line">            <span class="keyword">return</span> changeHomeData(state,action)  ***修改部分</span><br><span class="line">        <span class="keyword">case</span> ADD_HOME_LIST:</span><br><span class="line">            <span class="keyword">return</span> addhomedata(state,action)</span><br></pre></td></tr></table></figure><p><strong>首页性能调优</strong></p><blockquote><p>因为首页的index.js都调用了connect的方法，和store做了连接，这就会产生一个问题，只要store发生了改变，那么每一个组件都会被重新渲染，也就是每个函数的render函数会被重新执行，可能有些数据发生改变了，但是那个数据和这个组件一点关系都没有，但是这个组件依然会被重新渲染，导致性能不好。提高组价性能 shouldComponentUpdata，可以在这里做性能优化的代码，判断只有与这个组件相关的数据发生改变才让render函数重新执行（重新渲染），否则return false不让render函数重新执行。</p><p>通过这种方式来避免虚拟DOM的比对，提高性能，react也考虑到了这点，如果你在每个特组件都去自己写should….太麻烦了，react内置了新的组件类型，引入PureComponent，区别就是PureComponent内在自己底层实现了should…,这样就不用我们手写收should……做性能优化。之后就是每个UI组件都替换为PureComponent</p><p>之所以项目用<strong>PureComponent</strong>，是因为项目的数据管理用了immuable.js的框架，它可以保证我们的数据是immuable的，这样PureComponent和immuablejs数据格式的管理相结合，使用PureComponent一点问题都没有，但是如果你在你的项目里面，没有使用immuable.js管理你的数据，那么使用PureComponen有的时候会遇到坑。（偏底层的坑）</p></blockquote><p><strong>实现点击title跳转至详情页面</strong></p><blockquote><p>当我们在react实现页面跳转的时候，我们要用到react-router-dom第三方模块，它的这种跳转是单页应用跳转，所谓单页应用跳转就是做一个单页应用的时候，单页应用指的是，不管怎么做页面的跳转，整个网站只会加载一个html文件，只会加载一次html文件，那么来看使用a标签来做页面的跳转，符不符合单页应用的定义。network里Doc可以看加载的html文件，使用a标签就是会重新加载html文件，会由原来的localhost变为detail的html，增加了一次html请求，比较耗性能，因为借助react-router-dom的时候，完全没必要重新加载页面，做页面的跳转，正确的做法是用Link代替a标签。</p><p>注意：link标签要在Router里面否则会报错，在做头部点击简书logo的时候，因为link在head里，而APP组件的Header是在BrowseRouter外部因此违背了这个规则 导致报错</p></blockquote><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261120619.png" alt="image-20211126111958584"></p><p>或者是报这个错</p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261121636.png" alt="img"></p><h2 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h2><p><strong>详情页面的布局</strong></p><blockquote><p>从reducer里导入初试状态的content时候会导致标签转义，所以页面显示的内容不是该有的内容。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: <span class="keyword">this</span>.props.content&#125; 这样写不会被转义</span><br><span class="line"></span><br><span class="line">之后这些数据想在后端被获取而不是通过store里的原始数据取获取。就需要发ajax请求，步骤都是和之前一样</span><br></pre></td></tr></table></figure><p><strong>实现点击不同的title显示不同的详情页（匹配id）</strong></p><blockquote><p>在List.js文件夹下 <Link key={index} to={'./detail/' + item.get('id')}>路径下加上一个id  打开浏览器不显示了</p><p>原因是在APP.js组件里路由组件匹配的路径是/detail 而不是/detail/1 因此得在路由组件匹配的时候出换一个‘/detail/：id’</p><p>获取参数的第一种方法：动态获取参数</p><p>首先打开详情页面的代码 在render和return之间先 打印输出log（this.props）//在控制台里可以看出props里match里的params里有id 然后就是在组件挂载时传入id</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">action.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getDetail=<span class="function">(<span class="params">id</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">        axios.get(<span class="string">'/api/detail.json?id='</span>+ id).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="comment">//把id传给后端</span></span><br><span class="line">            <span class="keyword">const</span> result=res.data.data;</span><br><span class="line">            <span class="comment">// console.log(res.data.data);</span></span><br><span class="line">            dispatch(changeDetail(result.title,result.content))</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">detail下的index.js</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detail</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;DetailWrapper&gt;</span><br><span class="line">                &lt;Header&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Content dangerouslySetInnerHTML=&#123;&#123;__html: this.props.content&#125;&#125;/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/DetailWrapper&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    componentDidMount()&#123;</span></span><br><span class="line"><span class="regexp">        const &#123;id&#125; = this.props.param</span></span><br><span class="line"><span class="regexp">        this.props.getDetail(id);/</span><span class="regexp">/通过后端去返回</span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapState=(state)=&gt;(&#123;</span></span><br><span class="line"><span class="regexp">    title: state.get('detail').get('title'),</span></span><br><span class="line"><span class="regexp">    content: state.get('detail').get('content')</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">const mapDispatch=(dispatch)=&gt;(&#123;</span></span><br><span class="line"><span class="regexp">    getDetail(id)&#123;</span></span><br><span class="line"><span class="regexp">        dispatch(getDetail(id));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">然后传递路由参数出现了问题 是由于使用了react-router-dom v6的版本 下面有解释</span></span><br><span class="line"><span class="regexp">export default connect(mapState, mapDispatch)((props)=&gt;(</span></span><br><span class="line"><span class="regexp">    &lt;Detail</span></span><br><span class="line"><span class="regexp">    &#123;...props&#125;</span></span><br><span class="line"><span class="regexp">    param=&#123;useParams()&#125;</span></span><br><span class="line"><span class="regexp">    /</span>&gt;</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p><strong>巨坑由于使用了react-router-dom v6的版本 使得组件props参数里没有location history等属性。如果使用v5的话就完全避免了这个问题（使用v5下载包的时候附上版本号yarn add react-router-dom@5.3.0）</strong></p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261925280.png" alt="image-20211126192533225"></p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111261926068.png" alt="image-20211126192612881"></p><p><strong>登陆组件</strong></p><blockquote><p>创建reducers 定义初始状态，login：false 之后在去头部的map方法里那login组件里的login</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">login:state.getIn([<span class="string">'login'</span>,<span class="string">'login'</span>])</span><br><span class="line">&#123;</span><br><span class="line">login ? <span class="xml"><span class="tag">&lt;<span class="name">NavItem</span> <span class="attr">className</span>=<span class="string">'right'</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">NavItem</span>&gt;</span></span>:<span class="xml"><span class="tag">&lt;<span class="name">NavItem</span> <span class="attr">className</span>=<span class="string">'right'</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">NavItem</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">就可以在页面的头部看到是否处于登陆状态还是退出状态</span><br></pre></td></tr></table></figure><blockquote><p>接下来如果用户没有登陆不是显示这个字样 而是跳转到登陆页面</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Link to=<span class="string">'/login'</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">NavItem</span> <span class="attr">className</span>=<span class="string">'right'</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">NavItem</span>&gt;</span></span>&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">回到登陆组件</span></span><br><span class="line"><span class="regexp"> &lt;Button onClick=&#123;() =&gt; this.props.login(this.account, this.password)&#125;&gt;登录&lt;/</span>Button&gt;</span><br><span class="line">因为登陆需要调用ajax接口，把账号密码传递过去的。这时候需要把它写进mapDispatch里 因为要发异步的请求，异步action</span><br><span class="line">只有它才能派发异步action</span><br><span class="line"></span><br><span class="line">&lt;Input placeholder=<span class="string">"账号"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.account = input&#125;&#125; /&gt;</span><br><span class="line">&lt;Input placeholder=<span class="string">"密码"</span> type=<span class="string">"password"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.password = input&#125;&#125; /&gt;</span><br><span class="line">这两句话的意思就是:通过ref把这两个DOM分别存在<span class="keyword">this</span>.account和<span class="keyword">this</span>.password里</span><br><span class="line">这样在登陆的时候就可以调用箭头函数把account和password传进去</span><br><span class="line">之后就是发ajax请求 action reducers 常见的套路 </span><br><span class="line">实现的结果就是输入账号密码之后头部的登陆变成了退出  现在就是要实现点击登陆跳转到首页</span><br><span class="line">重定向到首页 又是版本的问题，之前的重定向Redirect也不能用了</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;loginState&#125; = <span class="keyword">this</span>.props;<span class="comment">//false</span></span><br><span class="line">    <span class="keyword">if</span>(!loginState)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;LoginWrapper&gt;</span><br><span class="line">            &lt;LoginBox&gt;</span><br><span class="line">            &lt;Input placeholder=<span class="string">"账号"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.account = input&#125;&#125; /&gt;</span><br><span class="line">    &lt;Input placeholder=<span class="string">"密码"</span> type=<span class="string">"password"</span> ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.password = input&#125;&#125; /&gt;</span><br><span class="line">    &lt;Button onClick=&#123;() =&gt; <span class="keyword">this</span>.props.login(<span class="keyword">this</span>.account, <span class="keyword">this</span>.password)&#125;&gt;登录&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>LoginBox&gt;</span><br><span class="line">    &lt;<span class="regexp">/LoginWrapper&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    &#125;else&#123;</span></span><br><span class="line"><span class="regexp">        return &lt; Navigate  to='/</span><span class="string">' /&gt;</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">之后做退出的功能回到header组件的index.js下</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">     login ?</span><br><span class="line">         &lt;NavItem className=<span class="string">'right'</span>&gt;退出&lt;<span class="regexp">/NavItem&gt;:</span></span><br><span class="line"><span class="regexp">         &lt;Link to='/</span>login<span class="string">'&gt;&lt;NavItem className='</span>right<span class="string">'&gt;登陆&lt;/NavItem&gt;&lt;/Link&gt;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> 在这里添加一个点击事件onClick=&#123;logout&#125;通过调用该回调函数去修改login的值，所以要去派发action</span></span><br><span class="line"><span class="string"> 因为这是在header.js下的 要引用login的action</span></span><br><span class="line"><span class="string">修改数据得到的结果也就是头部的显示结果 就是点击退出的时候上面的退出会改成登陆</span></span><br></pre></td></tr></table></figure><p><strong>创建写文章（只有在登陆状态下才能写）</strong></p><blockquote><p>对于一个组件的实现流程：首先建立writer文件夹下的index.js 把login复制过来，沿用它的一些逻辑</p><p>如果登陆了就写文章，如果没有登陆就跳转到登陆见面 然后把这个组件放到APP.js里面 。</p><p>同时在头部组件里的一个写文章外部加一个Link 跳转到Writer组件里之后就不做了 </p></blockquote><p><strong>代码优化</strong></p><ol><li>在每个方法后面加分号；</li><li>在action里发异步请求的时候都默认发成功的请求，在企业级项目都有错误的情况.catch（）异常逻辑进行补充</li></ol><p><strong>异步组件</strong></p><blockquote><p>首先点开network组件 JS刷新页面， 跳转页面，登陆页面，都是加载bundle.js，存在一个问题：所有页面对应的组件代码，都是bundle.js，现在访问的是首页，实际上登陆和详情页面的代码一起都加载了，这样首页加载的速度就有点慢。解决问题：当你访问首页的时候，你只加载首页的代码，访问详情页的时候再去加载详情页的代码 使用异步组件来实现，底层比较复杂，但是使用封装起来的第三方模块会非常简单。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm add react-loadable</span><br><span class="line">异步组件的时候会有一个问题如果是v5版本的话</span><br><span class="line">detail下的index.js是有用到params参数的，以前可以直接获取是因为 </span><br><span class="line">因为APP.js里以前引入的Detail组件，路由对应的组件就是这个组件<span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'./pages/detail'</span>;</span><br><span class="line">&lt;Route path=<span class="string">'/detail/:id'</span> exact component=&#123;Detail&#125;&gt;&lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">如果是这样detail可以直接拿到路由信息</span></span><br><span class="line"><span class="regexp">但是现在不一样了引入的是import Detail from './</span>pages/detail/loadable.js<span class="string">';</span></span><br><span class="line"><span class="string">所以loadable.js可以获得所有的路由信息，但是它下面的组件获取不了路由内容，因为它不是Router直接对应的组件</span></span><br><span class="line"><span class="string">箭头所示的就是下面的组件 </span></span><br><span class="line"><span class="string">解决方法就是在index.js组件里加一个withRouter **这是v5的  v6不需要以上操作</span></span><br><span class="line"><span class="string">调用该方法让Detail组件有能力获取到Router里所以的参数和内容</span></span><br><span class="line"><span class="string">export default connect(mapState, mapDispatch)(withRouter(Detail));</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111262208581.png" alt="image-20211126220845485"></p><p><strong>注意</strong>：使用jsx语法要引入React</p><h2 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h2><p><strong>补充（之前漏看的视频）</strong></p><blockquote><p>首先在header组件的初始状态定义一个page和totalpage。page的作用是通过页码对内容进行控制，totalpage指的是整体的数据一共有多少页。 通过点击输入框就可以将获取列表，在列表里的action获取到数据后在同步action里面定义总共的页码。</p><p>之后在把页面传给reducers，打开reudx点击搜索就可以看到如下获取的列表和总共的页码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后在map方法里获取页码  <span class="string">``</span>  page:state.getIn([<span class="string">'header'</span>,<span class="string">'page'</span>]),<span class="string">``</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111271938134.png" alt="image-20211127192232109"></p><blockquote><p> 之后在map方法里获取页码  <code>page:state.getIn([&#39;header&#39;,&#39;page&#39;]),</code></p><p>让它一页显示10个</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;focused,list,page&#125;=<span class="keyword">this</span>.props</span><br><span class="line"><span class="keyword">const</span> pageList=[];</span><br><span class="line"><span class="keyword">const</span> Listpage = list.toJS(); <span class="comment">//因为从props里获取的list是immuable数据类型 该数据类型不能使用Listpage[i]方法，要先转换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=(page<span class="number">-1</span>)*<span class="number">10</span>;i&lt;page*<span class="number">10</span>;i++)&#123;</span><br><span class="line">            pageList.push(</span><br><span class="line">                &lt;SearchInfoItem key=&#123;Listpage[i]&#125;&gt;&#123;Listpage[i]&#125;&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>之后点击搜索显示的就是10个内容 但是才存在一个问题，点击换一换的时候input框会失焦，一失焦下面的区块就隐藏掉了，什么时候隐藏，其实并不是靠这个input的focus来控制的。实际点击区块的白色部分的时候，已经失焦但是区块不会隐藏，把鼠标移出去的时候才会隐藏。因此下面区块的展示和隐藏并不是完全由focus的状态来决定的还由一个mouseleft和mousemove决定的。</p><p>因此再加一个属性   mouseIn:false,，因为一开始鼠标就是没进入这个区块，鼠标移入进去，变成true。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;SearchInfo onMouseEnter=&#123;<span class="keyword">this</span>.props.handleMouseEnter&#125;<span class="comment">//定义一个方法 派发action</span></span><br><span class="line">改变mouseIn:<span class="literal">false</span>,这个的状态</span><br><span class="line">同理再加一个 onMouseLeave=&#123;<span class="keyword">this</span>.props.handleMouseLeave&#125;这个方法</span><br><span class="line">一直我们是通过focus来控制显示还是隐藏，其实现在focus不管用，还得借助mouseIn这个变量一起来控制，因此要从mapstate拿到mouseIn</span><br><span class="line"><span class="keyword">if</span>(focused||mouseIn)如果mouseIn为<span class="literal">true</span>也显示</span><br><span class="line">下面就是点击换一换 下面的内容也要跟着变</span><br><span class="line">定义方法onClick=&#123;<span class="keyword">this</span>.props.handleChangePage&#125;</span><br><span class="line">handleChangePage()&#123;</span><br><span class="line">            dispatch(changePage())<span class="comment">//派发action</span></span><br><span class="line">        &#125;,</span><br><span class="line">之后就是修改page的状态由于状态修改page不能直接加<span class="number">1</span></span><br><span class="line">因此还要获取totalPage的状态</span><br><span class="line"> handleChangePage(page,totalPage)&#123;</span><br><span class="line">  <span class="keyword">if</span>(page&lt;totalPage)&#123;</span><br><span class="line">      dispatch(changePage(page+<span class="number">1</span>))</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dispatch(changePage(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">把这个函数设为箭头函数之后把page和totalpage传进去之后进行判断 之后去修改状态即可</span><br><span class="line">但是还是会报错原因就是输出<span class="keyword">for</span>循环的时候输出的是<span class="literal">undefined</span>。原因是因为当你刚进入页面的时候，header就会被渲染，初始顺序就是list是个空，page是个<span class="number">1</span>， 然后<span class="keyword">for</span>循环一定会执行，所以会循环<span class="number">1</span>到<span class="number">9</span> 但是list是一个空数组，那么空数组list[<span class="number">0</span>]都是<span class="literal">undefined</span></span><br><span class="line">那么key就是<span class="literal">undefined</span>。 因此外层要包裹一个<span class="keyword">if</span>判断</span><br><span class="line"> <span class="keyword">if</span>(pageList.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=(page<span class="number">-1</span>)*<span class="number">10</span>;i&lt;page*<span class="number">10</span>;i++)&#123;</span><br><span class="line">                pageList.push(</span><br><span class="line">                    &lt;SearchInfoItem key=&#123;Listpage[i]&#125;&gt;&#123;Listpage[i]&#125;&lt;<span class="regexp">/SearchInfoItem&gt;</span></span><br><span class="line"><span class="regexp">                )</span></span><br><span class="line"><span class="regexp">            &#125; </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>之后点换一换的时候让i标签的动画动一下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;SearchInfoSwitch</span><br><span class="line">    onClick=&#123;()=&gt;handleChangePage(page,totalPage,<span class="keyword">this</span>.spinIcon)&#125;</span><br><span class="line">  &gt;</span><br><span class="line"><span class="comment">//将this.spinIcon传进onClick方法</span></span><br><span class="line">    &lt;i ref=&#123;(icon)=&gt;&#123;this.spinIcon = icon&#125;&#125; className="iconfont spin"&gt;&amp;#xe675;&lt;/i&gt;</span><br><span class="line">            换一批</span><br><span class="line"> &lt;<span class="regexp">/SearchInfoSwitch&gt;</span></span><br></pre></td></tr></table></figure><p>之前换一批图标功能未实现，且iconfont图标在下侧，原因是因为之前设置的iconfont样式覆盖了它</p><p>只要把之前的iconfont样式改成zoom即可</p><p>当你点击换一批的时候，我们希望i标签的值发生变化， 有一个ref的内容可以回去i标签真实的DOM节点</p><p> 之后把相应的值传进，之后在方法下方输出spin 控制台就会输出</p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111280949745.png" alt="image-20211128094949731"></p><p>就获取到spin对应的DOM了</p><pre><code>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spin.style.transform=<span class="string">'rotate(360deg)'</span>;<span class="comment">//当你点击的时候就会旋转360 但是只会执行一次因为是转360</span></span><br><span class="line">可以获取上一次旋转的角度之后每一次加<span class="number">360</span>度 下一次就是<span class="number">720</span>度</span><br><span class="line"> 使用单纯CSS transition动画效果来实现</span><br><span class="line"> <span class="keyword">let</span> originAngle = spin.style.transform.replace(<span class="regexp">/[^0-9]/ig</span>,<span class="string">''</span>)<span class="comment">//不是0-9的数字都替换为空</span></span><br><span class="line">     <span class="keyword">if</span>(originAngle)&#123;</span><br><span class="line">         originAngle=<span class="built_in">parseInt</span>(originAngle,<span class="number">10</span>)</span><br><span class="line">     &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         originAngle=<span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    spin.style.transform=<span class="string">'rotate('</span>+(originAngle+ <span class="number">360</span>)+<span class="string">'deg)'</span><span class="comment">//0-360  360-720都会有过渡效果</span></span><br><span class="line">react是面向数据编程，最难的是在redux里如何对数据进设计</span><br></pre></td></tr></table></figure></code></pre><hr><p><strong>1、react是面向数据编程，最难的是在redux里的数如何的被设计</strong></p><hr><p><strong>2、改变它里面的数据，遵循redux里单向数据流的流程，首先先派发action给store，store再给reducers，reducers返回一个新的数组再给store，store去变更自己的内容，当数据发生变更，页面就自动发生变化了。</strong></p><h2 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h2><p><strong>简书项目上线</strong></p><p>首先在后端的htdocs文件夹下创建一个api文件夹，后端的人在api文件夹下的json所各种复杂的运算处理，然后前端就可以将简书项目public文件夹下的api文件夹删除了，因为开发要做接口的模拟，然后在控制台运行npm run build，就会生成一个build文件夹，在build目录下有很多项目需要上线的文件，把build下的所有文件复制粘贴至htdocs文件夹下（和api一个同级）这样就完成了项目的上线。</p><p>整体的流程就是将前端的代码拷贝到后端的项目，访问的也就是后端的项目（访问路径就是之前的一个软件XAMPP）。</p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111281533623.png" alt="image-20211128153306716"></p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111281530997.png" alt="image-20211128153010553"></p><p>点start就可以在本地启动一个服务器（启动一个Apache服务器），会启动在localhost：80端口上（可以简写localhost）</p><h2 id="完美撒花"><a href="#完美撒花" class="headerlink" title="完美撒花"></a>完美撒花</h2><ol><li>react的基础语法</li><li>redux数据层框架</li><li>react-redux如何方便我们在react之中使用redux</li><li>react-router（本课程用的是4.0的版本 而我采用的是6.0天呐）</li><li>immuable.js 相关的第三方模块</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;react简书实战&quot;&gt;&lt;a href=&quot;#react简书实战&quot; class=&quot;headerlink&quot; title=&quot;react简书实战&quot;&gt;&lt;/a&gt;react简书实战&lt;/h1&gt;&lt;h2 id=&quot;day1&quot;&gt;&lt;a href=&quot;#day1&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="React" scheme="https://wzt2022.github.io/categories/React/"/>
    
    
    <category term="简书实战" scheme="https://wzt2022.github.io/tags/%E7%AE%80%E4%B9%A6%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题总结</title>
    <link href="https://wzt2022.github.io/2021/11/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/"/>
    <id>https://wzt2022.github.io/2021/11/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%AF%8F%E6%97%A510%E9%81%93%EF%BC%89/</id>
    <published>2021-11-14T16:00:00.000Z</published>
    <updated>2021-11-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端面试题（每日10道）"><a href="#前端面试题（每日10道）" class="headerlink" title="前端面试题（每日10道）"></a>前端面试题（每日10道）</h1><h2 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h2><h3 id="1-CSS盒模型"><a href="#1-CSS盒模型" class="headerlink" title="1.CSS盒模型"></a>1.CSS盒模型</h3><p>（1）用来装页面上的元素的矩形区域。由内容区、内边距、边框、外边距四部分组成</p><p>（2）CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型，盒子的宽度时存在着差异</p><p>​            在标准的盒子模型中，宽度指内容区部分的宽度，</p><p>​            在IE盒子模型中，宽度表示内容区，内边距，边框这三个部分的宽度</p><p>（3） 在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型</p><p><strong>补充</strong></p><ul><li><p>边框和内边距的设置会影响到盒子的大小，外边距的设置不会影响盒子可见框的大小，但是会影响盒子的位置，从而影响盒子实际占用空间</p></li><li><p>一个元素在其父元素中,水平布局必须要满足以下的等式：左右外边距+左右内边距+左右边框+本身宽度=父元素内容区的宽度</p><p>如果这七个值中没有为 auto 的情况，则浏览器会自动调整margin-right值以使等式满足 如果超过800 就margin-right=-200</p><p>这七个值中有三个值可以设置成auto，width、margin-left、 maring-right，调整相应的auto以使等式成立 宽度优先级最高</p></li><li><p>如果子元素的大小超过了父元素，则子元素会从父元素中溢出，使用overflow属性来设置父元素如何处理溢出的子元素 </p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可选值:（1）visible，默认值子元素会从父元素中溢出，在父元素外部的位置显示。</span><br><span class="line">   （2）hidden 溢出内容将会被裁剪不会显示        </span><br><span class="line">     （3）scroll生成两个滚动条,通过滚动条来查看完整的内容 </span><br><span class="line">         （4）auto根据需要生成滚动条</span><br></pre></td></tr></table></figure></li><li><p>垂直外边距的重叠（如下图绿色方块的下外边距设置100px与橙色方块上外边距设置100px重叠了) ：相邻的垂直方向外边距会发生重叠现象</p><ul><li><p>兄弟元素外边距的重叠：兄弟元素间的相邻垂直外边距会取两者之间的较大值一正一负，则取两者的和    如果相邻的外边距都是负值，则取两者中绝对值较大的   </p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151506013.png" alt="image-20211115145746032"></p></li><li><p>父子元素外边距的重叠（如下图给子元素设置上外边距100px，结果将其属性传至父元素让父元素下移）：父子元素间相邻外边距，子元素的会传递给父元素（上外边距)</p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151507725.png" alt="image-20211115150739964"></p></li></ul></li></ul><h3 id="2-居中垂直对齐"><a href="#2-居中垂直对齐" class="headerlink" title="2.居中垂直对齐"></a>2.居中垂直对齐</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单行文本: line-height = height</span><br><span class="line">图片: vertical-align: middle;</span><br><span class="line">absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);前半部分指的是相对于物体居中但是物体本身有尺寸</span><br><span class="line">display:flex;margin:auto</span><br></pre></td></tr></table></figure><h3 id="3-点击按钮使得页面上的文字颜色发生改变如何实现"><a href="#3-点击按钮使得页面上的文字颜色发生改变如何实现" class="headerlink" title="3.点击按钮使得页面上的文字颜色发生改变如何实现"></a>3.点击按钮使得页面上的文字颜色发生改变如何实现</h3><p>​        首先创建一个button按钮，绑定一个onclick点击事件，对需要显示的区域设置大小和颜色(下图代码红绿交替显示)</p><p>​        当点击按钮的时候调用该点击事件从而改变页面上的文字颜色（调用事件的时候要获取显示区域的id）</p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111151600893.png" alt="image-20211115160026280"></p><h3 id="4-html小知识"><a href="#4-html小知识" class="headerlink" title="4.html小知识"></a>4.html小知识</h3><p>​    （1）html 语义化让页面的内容结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并      且是容易阅读的;</p><p>​    （2）alt 是给搜索引擎识别，在图像无法显示时的替代文本；title 是关于元素的注释信息，主要是给用户解读。</p><p>​    （3） iframe标签是在当前网页插入一个指定的页面   —内联框架</p><p>​                优点：解决加载缓慢的第三方内容如图标或者广告等的加载问题</p><p>​                缺点：iframe标签会阻塞主页面的onload事件</p><p>​    （4）href 指向网络资源所在位置  src 会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；</p><p>​    （5）去除项目中符号：list-style：none 去除浏览器的默认样式使用重置样式表，专门用来对浏览器的样式进行重置</p><p>​    （6）开启定位的元素层级会提升且层级一样，z-index属性来指定元素的层级用整数表示，可以高于定位的层级，值越大元素的层级越              高如果元素的层级一样，则优先显示靠下的元素，祖先元素的层级再高也不会盖住后代元素（祖先z-index&gt;后代定位）。</p><p>​    （7）text-align文本的水平对齐 可选值:    left左侧对齐    right右对齐    center居中对齐    justify 两端对齐 </p><p>​    （8）vertical-align 设置元素垂直对齐的方式  用于消除图片的缝</p><p>​    （9）background-image设置背景图片 background-repeat用来设置背景的重复方式 background-position用来设置背景图片的位置</p><p>  （10）:link用来表示没访问过的链接 :visited用来表示访问过的链接</p><p>  （11）线性渐变，颜色沿着一条直线发生变化 linear-gradient()；</p><p>  （12）径向渐变，(放射性的效果) radial-gradient()</p><p>​     (13) 表格：table标签来创建一个表格 colspan横向的合并单元格。table虽说是块元素，但是宽度是被内容撑开的。</p><p>​                — 以将一个表格分成三个部分: 头部 thead 主体 tbody 底部 tfoot </p><p>  （14）使用form标签来创建一个表单 单选按钮   <!--单选按钮-->   <!--多选按钮--><!--重置按钮--></p><h3 id="5-CSS选择器的优先级"><a href="#5-CSS选择器的优先级" class="headerlink" title="5.CSS选择器的优先级"></a>5.CSS选择器的优先级</h3><p><strong>不同级别</strong></p><ol><li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p></li><li><p>作为style属性写在元素内的样式（行类样式） 权值1000</p></li><li><p>id选择器 100</p></li><li><p>类选择器 10</p></li><li><p>标签选择器 1</p></li><li><p>通配符选择器</p></li><li><p>浏览器自定义或继承</p></li><li><p>贩卖人间快乐:<br>生命周期。 </p><p>贩卖人间快乐:<br>双向绑定</p></li><li><p><strong>选择器的累加不会超过其最大的数量级，类选择器在再高也不会超过id选择器</strong></p></li></ol><h3 id="6-简明说一下-CSS-link-与-import-的区别和用法？"><a href="#6-简明说一下-CSS-link-与-import-的区别和用法？" class="headerlink" title="6.简明说一下 CSS link 与 @import 的区别和用法？"></a>6.简明说一下 CSS link 与 @import 的区别和用法？</h3><pre><code>1. link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。2. link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。3. link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。</code></pre><h3 id="7-display-none和visibility-hidden的区别？"><a href="#7-display-none和visibility-hidden的区别？" class="headerlink" title="7.display:none和visibility:hidden的区别？"></a>7.display:none和visibility:hidden的区别？</h3><ul><li>display:none 元素不在页面中显示，不占据页面的位置。</li><li>visibility:hidden 元素在页面中隐藏不显示，但是依然占据页面的位置。 </li></ul><h3 id="8-rgba和opacity的透明效果有什么不同？"><a href="#8-rgba和opacity的透明效果有什么不同？" class="headerlink" title="8.rgba和opacity的透明效果有什么不同？"></a>8.rgba和opacity的透明效果有什么不同？</h3><blockquote><p>opacity 会继承父元素的 opacity 属性，而 RGBA 不会。</p></blockquote><h3 id="9-position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#9-position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="9.position的值， relative和absolute分别是相对于谁进行定位的？"></a>9.position的值， relative和absolute分别是相对于谁进行定位的？</h3><ul><li>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。</li><li>absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。</li><li>fixed: （老版本IE不支持）固定定位。</li><li>static:默认值，没有定位，元素出现在正常的文档流中。</li></ul><h3 id="10-BFC-是什么？"><a href="#10-BFC-是什么？" class="headerlink" title="10. BFC 是什么？"></a>10. BFC 是什么？</h3><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)根元素(<span class="tag">&lt;<span class="name">html</span>&gt;</span>)</span><br><span class="line">(2)浮动元素：float 除 none 以外的值  有局限性：高度不塌了但是脱离文档流了，宽度也就丢失了，对应特点的第三条 -不推荐</span><br><span class="line">(3)绝对定位元素：position (absolute、fixed)</span><br><span class="line">(4)display 为 inline-block、table-cells、flex -不推荐</span><br><span class="line">(5)overflow 除了 visible 以外的值 (hidden、auto、scroll) -推荐</span><br></pre></td></tr></table></figure><ul><li><p>之前不会塌是因为把高度写死了所以不会塌 现在父元素不设置高低 子元素高度为多少父元素就会被撑开多少</p></li><li><p>高度塌陷的问题: 在浮动布局中,父元素的高度默认是被子元素撑开的 当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离 将会无法撑起父元素的高度，导致父元素的高度丢失 父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱 所以高度塌陷是浮动布局中比较常见的一个问题。</p></li><li><p>开启BFC后的特点：</p><p>​       1.开启BFC的元素不会被浮动元素所覆盖</p><p>​       2.开启BFC的元素子元素和父元素外边距不会重叠 </p><p>​       3.开启BFC的元素可以包含浮动的子元素 </p><p> -常用的方式为元素设置 overflow:hidden 开启其BFC以使其可以包含浮动元素 高度不塌，宽度也不会丢失。</p></li></ul><h2 id="11-16"><a href="#11-16" class="headerlink" title="11.16"></a>11.16</h2><h3 id="11-doctype-的作用-声明版本"><a href="#11-doctype-的作用-声明版本" class="headerlink" title="11.doctype 的作用 声明版本"></a>11.doctype 的作用 声明版本</h3><blockquote><p>&lt;!DOCTYPE&gt;是一个用于声明当前HTMl版本，用来告知web浏览器该文档使用是哪种 HTML 或者 XHTML 规范来解析页面，以便浏览器更加准确的理解页面内容，更加良好地展现内容效果！</p></blockquote><h3 id="12-语义化标签的理解"><a href="#12-语义化标签的理解" class="headerlink" title="12.语义化标签的理解"></a>12.语义化标签的理解</h3><ol><li>即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构。</li><li>语义化标签会使HTML结构变的清晰，有利于维护代码和添加样式。</li><li>和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息</li><li>同时与计算机的编译也存在一定的联系</li></ol><h3 id="13-important-有什么不好"><a href="#13-important-有什么不好" class="headerlink" title="13.important 有什么不好"></a>13.important 有什么不好</h3><blockquote><p>css定义中的用!important样式权重是最高的，会覆盖页面内任何位置定义的元素样式，有时候程序员忘了删除，这样就会导致自己设置的样式无法显示的问题。</p></blockquote><h3 id="14-css-选择器的解析顺序，原因"><a href="#14-css-选择器的解析顺序，原因" class="headerlink" title="14. css 选择器的解析顺序，原因"></a>14. css 选择器的解析顺序，原因</h3><blockquote><p>解析顺序：从右往左，</p><p>原因：从右往左进行解析的好处那就是从右往左进行匹配的时候，匹配的全部是DOM元素的父节点，而从左往右进行匹配的时候时候，匹配的全部是DOM元素的子节点，这样就避免了HTML与CSS没有下载完需要进行等待的情形。且遍历查找的节点都会少很多</p></blockquote><h3 id="15-css-清除浮动"><a href="#15-css-清除浮动" class="headerlink" title="15.css 清除浮动"></a>15.css 清除浮动</h3><p><strong>1清除浮动的第一种方式—给父级盒子添加高度</strong></p><blockquote><p>造成高度塌陷的原因就是父元素没有高度，我们只需要给父元素添加一个高度即可，但是这种方式并不推荐使用，因为有很多局限性，况且子元素依然是脱离标准流，并没有回到父元素中，此时父元素的宽度变化了。</p></blockquote><p><strong>2添加clear属性来清除浮动元素对当前元素所产生的影响**</strong></p><ol><li><p>可选值：</p><p>​    left清除左侧浮动元素对当前元素的影响 原来浮动的元素依然浮动 </p><p>​    right清除右侧浮动元素对当前元素的影响 </p><p>​    both 清除两侧中最大影响的那侧（类似高度的问题）</p></li><li><p>原理: 设置清除浮动以后，浏览器会自动为元素添加一个上外边距， 以使其位置不受其他元素的影响。</p></li></ol><p><strong>3.清除浮动的第三种方式—给父级添加overflow属性*</strong></p><blockquote><p>原理见16题</p></blockquote><p><strong>4.清除浮动的第四种方式—给父级添加after伪元素</strong></p><ul><li><p>利用after伪元素定义一个clearfix类，浮动元素的父级元素调用此类可以实现清除浮动的效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.clearfix: : before,//内边距重叠</span><br><span class="line">.clearfix: : after&#123;//高度塌陷</span><br><span class="line">content: ''; </span><br><span class="line">display: table;//table就相当于一个物体隔开他们俩让他们的外边距不重合</span><br><span class="line">clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="16-overflow-hidden-是怎么清除浮动的"><a href="#16-overflow-hidden-是怎么清除浮动的" class="headerlink" title="16. overflow:hidden 是怎么清除浮动的"></a>16. overflow:hidden 是怎么清除浮动的</h3><blockquote><p>父块没有设置指定的高宽，当子块设置为浮动后，原本包裹子块的父块的高度塌陷消失，这时给父块设置overflow:hidden就会为父块设置一个独立的块级上下文，使这个块级元素内部的排版完全独立，从而可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，这样就达到了清除浮动的效果，，使父块重新包裹子块。</p></blockquote><h3 id="17-HTML5、CSS3-里面都新增了那些新特性？"><a href="#17-HTML5、CSS3-里面都新增了那些新特性？" class="headerlink" title="17.HTML5、CSS3 里面都新增了那些新特性？"></a>17.HTML5、CSS3 里面都新增了那些新特性？</h3><p><strong>HTML5</strong> </p><ul><li>新的语义标签<ul><li>article 独立的内容。</li><li>aside 侧边栏。</li><li>header 头部。</li><li>nav 导航。</li><li>section 文档中的节。</li><li>footer 页脚。</li></ul></li><li>画布(Canvas) API</li><li>地理(Geolocation) API</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除</li><li>拖拽释放(Drag and drop) API</li><li>音频、视频API(audio,video)</li><li>表单控件，calendar、date、time、email、url、searc</li></ul><p><strong>CSS3</strong></p><ul><li>2d，3d变换</li><li>Transition, animation</li><li>媒体查询</li><li>新的单位（rem, vw，vh 等）</li><li>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</li><li>rgba</li></ul><h3 id="18-常见兼容性问题？"><a href="#18-常见兼容性问题？" class="headerlink" title="18. 常见兼容性问题？"></a>18. 常见兼容性问题？</h3><blockquote><p> 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><h3 id="19-固定定位和绝对定位的区别"><a href="#19-固定定位和绝对定位的区别" class="headerlink" title="19.固定定位和绝对定位的区别"></a>19.固定定位和绝对定位的区别</h3><p>fixed :固定 定位 absolute :绝对 定位 区别 ： 1、<strong>没有滚动条的情况下没有差异</strong> 2、在有滚动条的情况下， fixed定位 不会随滚动条移动而移动，而 absolute 则会随滚动条移动 </p><h3 id="20-实现一个两列固定，中间自适应有哪些方法"><a href="#20-实现一个两列固定，中间自适应有哪些方法" class="headerlink" title="20.实现一个两列固定，中间自适应有哪些方法"></a>20.实现一个两列固定，中间自适应有哪些方法</h3><ol><li><p>使用flex通过改变 <code>flex-grow</code>和 <code>flex-shrink</code>实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body&#123;</span><br><span class="line">        height: 100vh;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: row;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: lightskyblue;</span><br><span class="line">        word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 左右固定长度 */</span></span></span><br><span class="line">        flex-basis: 100px;</span><br><span class="line"><span class="css">        <span class="comment">/* 将增长比和缩小比都设置为 0 ,避免宽度变化 */</span></span></span><br><span class="line">        flex-grow: 0;</span><br><span class="line">        flex-shrink: 0;</span><br><span class="line">        background-color: lightslategray;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 中间自动适应 */</span></span></span><br><span class="line">        flex-grow: 1;</span><br><span class="line">        flex-shrink: 1;</span><br><span class="line">        background-color: lightpink;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>绝对定位+CSS3新盒子 (利用新盒子 width = content + padding + border 特性 🎈)</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">     body&#123;</span><br><span class="line">         height: 100vh;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">         position: relative;</span><br><span class="line">         height: 200px;</span><br><span class="line">         background-color: lightskyblue;</span><br><span class="line">         word-break: break-all;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="comment">/* 使用绝对定位来控制元素 */</span></span></span><br><span class="line">         position: absolute;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">         height: 200px;</span><br><span class="line">         width: 100px;</span><br><span class="line">         background-color: lightslategray;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">         right: 0;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="css">     <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="comment">/* 控制padding来放置两侧元素, content宽度会自动计算 */</span></span></span><br><span class="line">         box-sizing: border-box;</span><br><span class="line">         height: 100%;</span><br><span class="line">         width: 100%;</span><br><span class="line"><span class="css">         <span class="comment">/* 两端填充100px, 用来放两侧固定元素 */</span></span></span><br><span class="line">         padding: 0 100px;</span><br><span class="line">         background-color: lightpink;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h2><h3 id="21-伪类选择器和伪元素理解以及区别-可以使用伪类选择器实现隔行变色效果"><a href="#21-伪类选择器和伪元素理解以及区别-可以使用伪类选择器实现隔行变色效果" class="headerlink" title="21.伪类选择器和伪元素理解以及区别(可以使用伪类选择器实现隔行变色效果)"></a>21.伪类选择器和伪元素理解以及区别(可以使用伪类选择器实现隔行变色效果)</h3><p>   <strong>伪类（不存在的类，特殊的类),伪类用来描述一个元素的特殊状态 比如:第一个子元素、被点击的元素、鼠标移入的元素…</strong></p><ul><li><p>: nth-child()选中第n个子元素</p></li><li><p>: nth-of-type() 同类型元素中进行排序</p><p><strong>伪元素，表示页面中一些特殊的并不真实存在的元素（特殊的位置)</strong>     </p><blockquote><p>::before元素的最开头 ::after元素的最后    - before和 after必须结合content属性来使用</p></blockquote><h3 id="22-em和rem"><a href="#22-em和rem" class="headerlink" title="22.em和rem"></a>22.em和rem</h3><p><strong>em是相对于元素的字体大小来计算的</strong></p><p><strong>rem是相对于根元素的字体大小来计算 —类似于全局变量</strong></p><h3 id="23-我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现"><a href="#23-我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现" class="headerlink" title="23.我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现"></a>23.我需要等三张图片都加载完毕之后再执行回调函数，可以怎么实现</h3></li></ul></li></ol><p><strong>使用Promise.all</strong></p><ol><li><p>当有一个ajax请求时，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</p></li><li><p>Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。</p></li></ol><p><strong>promise补充</strong></p><ol><li>现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。</li><li>Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。</li><li>then方法的执行结果也会返回一个Promise对象。因此我们可以进行then的链式执行，这也是解决回调地狱的主要方式。</li></ol><h3 id="24-setTimeout-和-Promise-哪一个先执行"><a href="#24-setTimeout-和-Promise-哪一个先执行" class="headerlink" title="24.setTimeout 和 Promise 哪一个先执行"></a>24.setTimeout 和 Promise 哪一个先执行</h3><blockquote><p> Promise比setTimeout()先执行。因为Promise定义之后便会立即执行，其后的.then()是异步里面的微任务。而setTimeout()是异步的宏任务。</p></blockquote><h3 id="25-canvas-的一些方法"><a href="#25-canvas-的一些方法" class="headerlink" title="25.canvas 的一些方法"></a>25.canvas 的一些方法</h3><ol><li>第一是以drawXXX为主的绘制方法； 例如drawColor：填充颜色</li><li>第二是以clipXXX为主的裁剪方法；    例如clipRect：当前画布裁剪为一个矩形</li><li>第三是以scale、translate和rotate组成的Canvas变换方法；</li><li>最后一类save：将当前的状态推送至栈中保存   restore：将上次保存的状态从栈中弹出；</li></ol><h3 id="26-font-face"><a href="#26-font-face" class="headerlink" title="26.@font-face"></a>26.@font-face</h3><p><strong>font-face是css3中允许使用自定义字体的一个模块。<em>@ font-face</em>的是一个CSS规则，允许你输入自己的字体出现在网站上**</strong></p><h3 id="27-transform-有哪些属性"><a href="#27-transform-有哪些属性" class="headerlink" title="27.transform 有哪些属性"></a>27.transform 有哪些属性</h3><p><strong>transform属性值：</strong></p><ul><li><p>transform: translate():  translate()的括号内包含两个值，分别为相对于元素原有位置在水平方向和垂直方向的偏移值</p></li><li><p>transform:rolate():  正值为顺时针，负值为逆时针，单位为deg。</p></li><li><p>transform:transform-origin:任何一个元素都有一个中心点，默认情况之下，其中心点是居于元素X轴和Y轴的50%处。</p></li><li><p>transform:scale():   scale(x,y):x,y 值分别为原有元素宽高的倍数。 1为不缩放，大于1放大，小于1缩小。</p></li></ul><h3 id="28-轮播图的原理"><a href="#28-轮播图的原理" class="headerlink" title="28.轮播图的原理"></a>28.轮播图的原理</h3><p><strong>图片移动实现原理：</strong></p><p>利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制left属性，实现照片的移动。</p><h3 id="29-雪碧图的使用步骤"><a href="#29-雪碧图的使用步骤" class="headerlink" title="29.雪碧图的使用步骤"></a>29.雪碧图的使用步骤</h3><ol><li>先确定要使用的图标 </li><li>测量图标的大小 </li><li>根据测量结果创建一个元素 </li><li>将雪碧图设置为元素的背景图片 </li><li>设置一个偏移量以显示正确的图片 </li></ol><h3 id="30-js基本数据类型"><a href="#30-js基本数据类型" class="headerlink" title="30.js基本数据类型"></a>30.js基本数据类型</h3><p>数据类型主要包括两部分：</p><ul><li>基本数据类型： Undefined、Null、Boolean、Number 和 String</li><li>引用数据类型： Object (包括 Object 、Array 、Function)</li></ul><h2 id="11-18"><a href="#11-18" class="headerlink" title="11.18"></a>11.18</h2><h3 id="31-判断一个值是什么类型有哪些方法？"><a href="#31-判断一个值是什么类型有哪些方法？" class="headerlink" title="31.判断一个值是什么类型有哪些方法？"></a>31.判断一个值是什么类型有哪些方法？</h3><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li>Object.prototype.toString 方法</li></ul><h3 id="32-null-和-undefined-的区别？"><a href="#32-null-和-undefined-的区别？" class="headerlink" title="32. null 和 undefined 的区别？"></a>32. null 和 undefined 的区别？</h3><p>null 表示一个对象被定义了，值为“空值”；<br>undefined 表示不存在这个值：<br>    （1）变量被声明了，但没有赋值时，就等于undefined。 </p><p>​    （2)  调用函数时，应该提供的参数没有提供，该参数等于undefined。</p><p>​    （3）对象没有赋值的属性，该属性的值为undefined。</p><p>​    （4）函数没有返回值时，默认返回undefined。</p><h3 id="33-js小知识"><a href="#33-js小知识" class="headerlink" title="33.js小知识"></a>33.js小知识</h3><ol><li><p>==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型；</p><p>===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p></li><li><p>eval是把对应的字符串解析成 JS 代码并运行；</p></li><li><p>var 存在变量提升; let 只能在块级作用域内访问; const 用来定义常量，必须初始化，不能修改（对象特殊）</p></li><li><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</p></li></ol><h3 id="34-箭头函数有哪些特点？"><a href="#34-箭头函数有哪些特点？" class="headerlink" title="34. 箭头函数有哪些特点？"></a>34. 箭头函数有哪些特点？</h3><blockquote><p>不需要function关键字来创建函数<br>省略return关键字<br>改变this指向</p></blockquote><h3 id="35-new操作符具体干了什么呢？"><a href="#35-new操作符具体干了什么呢？" class="headerlink" title="35.new操作符具体干了什么呢？"></a>35.new操作符具体干了什么呢？</h3><p>1、创建一个空对象，新创建的对象由 this 所引用，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。</p><h3 id="36-documen-write-和-innerHTML-的区别？"><a href="#36-documen-write-和-innerHTML-的区别？" class="headerlink" title="36.documen.write 和 innerHTML 的区别？"></a>36.documen.write 和 innerHTML 的区别？</h3><ul><li>document.write 只能重绘整个页面</li><li>innerHTML 可以重绘页面的一部分</li></ul><h3 id="37-ajax过程"><a href="#37-ajax过程" class="headerlink" title="37.ajax过程"></a>37.ajax过程</h3><ol><li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li><li>设置响应HTTP请求状态变化的函数.</li><li>发送HTTP请求.</li><li>获取异步调用返回的数据.</li><li>使用JavaScript和DOM实现局部刷新</li></ol><h3 id="38-请解释一下-JavaScript-的同源策略？"><a href="#38-请解释一下-JavaScript-的同源策略？" class="headerlink" title="38.请解释一下 JavaScript 的同源策略？"></a>38.请解释一下 JavaScript 的同源策略？</h3><p>同源策略指的是：协议，域名，端口相同。</p><p>同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><h3 id="39-介绍一下闭包和闭包常用场景？"><a href="#39-介绍一下闭包和闭包常用场景？" class="headerlink" title="39.介绍一下闭包和闭包常用场景？"></a>39.介绍一下闭包和闭包常用场景？</h3><ul><li>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数</li><li>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。</li><li>闭包有三个特性：<ul><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul></li><li>应用场景，设置私有变量的方法</li><li>不适用场景：返回闭包的函数是个非常大的函数</li><li>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</li></ul><h3 id="40-JavaScript原型，原型链-有什么特点？"><a href="#40-JavaScript原型，原型链-有什么特点？" class="headerlink" title="40,JavaScript原型，原型链 ? 有什么特点？"></a>40,JavaScript原型，原型链 ? 有什么特点？</h3><ul><li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br>于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li><li>关系：instance.constructor.prototype = instance.<strong>proto</strong></li><li>特点：<br>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li></ul><h2 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h2><h3 id="41-javascript的内存-垃圾-回收机制？"><a href="#41-javascript的内存-垃圾-回收机制？" class="headerlink" title="41.javascript的内存(垃圾)回收机制？"></a>41.javascript的内存(垃圾)回收机制？</h3><ul><li><p>垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存</p></li><li><p>一般使用<strong>标记清除方法(mark and sweep)</strong>, 当变量进入环境标记为进入环境，离开环境标记为离开环境<br>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p></li><li>还有<strong>引用计数方法(reference counting)</strong>, 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</li><li>在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。</li></ul><h3 id="42-如何解决-ES6-的语法兼容"><a href="#42-如何解决-ES6-的语法兼容" class="headerlink" title="42. 如何解决 ES6 的语法兼容"></a>42. 如何解决 ES6 的语法兼容</h3><blockquote><ol><li><p>对于浏览器解析不了es6的语法，需要我们使用babel工具链</p></li><li><p>对于不支持let等语法的情况下可以采用</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="comment">//严格模式</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="43-ES6的一些东西"><a href="#43-ES6的一些东西" class="headerlink" title="43.ES6的一些东西"></a>43.ES6的一些东西</h3><ol><li>新增了<code>let</code>、<code>const</code> <code>let</code>和<code>const</code>具有块级作用域，不存在变量提升的问题，<code>var</code> 声明的变量作用域为包围它的函数。</li><li>新增了箭头函数，简化了定义函数的写法，同时可以巧用箭头函数的this、（注意箭头函数本身没有this,它的this取决于外部的环境）</li><li>新增了promise解决了回调地域的问题</li><li>新增了模块化、利用import 、export来实现导入、导出</li><li>let的用法：定义变量 </li><li>箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定</li></ol><h3 id="44-如何解决js浮点数运算精度问题"><a href="#44-如何解决js浮点数运算精度问题" class="headerlink" title="44.如何解决js浮点数运算精度问题"></a>44.如何解决js浮点数运算精度问题</h3><p>问题:整数和浮点数都属于 <code>Number</code> 数据类型，所有数字都是以 64 位浮点数形式储存，即便整数也是如此。 所以我们在打印 <code>1.00</code> 这样的浮点数的结果是 <code>1</code> 而非 <code>1.00</code> 。</p><p>解决方法:</p><ol><li><p>利用toFixed() 方法用定点表示法来格式化一个数，会对结果进行四舍五入，对计算结果进行精度缩小。(不过还是存在精度问题)</p></li><li><p>或者直接用第三方帮你封装好处理浮点数的库，直接可以用。 如：number-precision</p></li></ol><h3 id="45-requestanimationframe-有用过吗？知道是干嘛的吗"><a href="#45-requestanimationframe-有用过吗？知道是干嘛的吗" class="headerlink" title="45.requestanimationframe 有用过吗？知道是干嘛的吗"></a>45.requestanimationframe 有用过吗？知道是干嘛的吗</h3><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p><h3 id="46-new操作符的过程"><a href="#46-new操作符的过程" class="headerlink" title="46.new操作符的过程"></a>46.new操作符的过程</h3><p> <strong>具体主要有4个部分</strong></p><p> 1.创建了一个新对象</p><p> 2.把这个新对象的原型属性（proto）绑定到原函数的prototype属性（就是继承原函数原型）</p><p> 3.把原函数的this指向转移到这个新对象上</p><p> 4.返回新对象，如果这个函数没有返回其他对象的话</p><h3 id="47-数组的一些方法"><a href="#47-数组的一些方法" class="headerlink" title="47.数组的一些方法"></a>47.数组的一些方法</h3><p>具体详解可以看<a href="https://blog.csdn.net/jjw_zyfx/article/details/95970780" target="_blank" rel="noopener">数组方法</a>）</p><ol><li><p>map方法的使用 相当于循环遍历每一项然后可以对每一项进行修改</p></li><li><p>filter的用法 过滤掉不符合条件的,剩下符合条件的</p></li><li>join方法的使用 数组变字符串</li><li>split方法的使用 字符串变数组</li><li>splice(1,1)删除的用法 删除下标为1的1个元素</li></ol><h3 id="48-call-apply-的区别"><a href="#48-call-apply-的区别" class="headerlink" title="48.call apply 的区别"></a>48.call apply 的区别</h3><p>相同点：</p><p>都是在特定的作用域中调用函数，使用call()和apply()方法时，就会改变this的指向，</p><p>不同点：</p><p>apply()方法接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</p><p>call()方法不一定接受两个参数，第一个参数也是函数运行的作用域（this），但是传递给函数的参数必须列举出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(obj , <span class="number">100</span> , <span class="number">200</span>);</span><br><span class="line">fn.apply(obj , [<span class="number">100</span>, <span class="number">200</span>]);</span><br></pre></td></tr></table></figure><h3 id="49-箭头函数与普通函数的区别"><a href="#49-箭头函数与普通函数的区别" class="headerlink" title="49.箭头函数与普通函数的区别"></a>49.箭头函数与普通函数的区别</h3><ul><li><p>语法更加简洁、清晰</p></li><li><p>箭头函数没有 prototype (原型)，所以箭头函数本身没有this</p></li><li><p>箭头函数不会创建自己的this</p></li><li><p>call | apply | bind 无法改变箭头函数中this的指向</p></li><li><p>箭头函数不能作为构造函数使用</p></li><li><p>如果箭头函数没有参数，</p><ul><li>直接写一个空括号即可。</li><li>如果箭头函数的参数只有一个，也可以省去包裹参数的括号。</li><li>如果箭头函数有多个参数，将参数依次用逗号(，)分隔，包裹在括号中即可。</li><li>箭头函数的函数体只有一句的话可以省略花括号和return</li></ul></li></ul><h3 id="50-手写一个函数去重"><a href="#50-手写一个函数去重" class="headerlink" title="50.手写一个函数去重"></a>50.手写一个函数去重</h3><h4 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes()"></a>1.Array.prototype.includes()</h4><p>基本思路：如果布尔值为假，则说明新数组不含有该元素。</p><ul><li><p>创建一个新数组</p></li><li><p>遍历原数组</p></li><li><p>新数组利用<code>Array.prototype.includes()</code>，返回<code>false</code>则将元素存储</p></li><li><p>不满足条件的元素不存储</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = [];</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArray.includes(item)) &#123;</span><br><span class="line">      newArray.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Array-prototype-reduce"><a href="#2-Array-prototype-reduce" class="headerlink" title="2.Array.prototype.reduce()"></a>2.Array.prototype.reduce()</h4><p>基本思路：先对原数组进行排序，然后利用<code>reduce</code>方法将不重复元素放进新数组。</p><ul><li><p>对原数组进行排序</p></li><li><p>利用<code>Array.prototype.reduce()</code>叠加功能</p></li><li><p>比较原数组和新数组元素，将不重复元素放进<code>init</code>新数组中。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(init.length === <span class="number">0</span> || init[init.length - <span class="number">1</span>] !== current)&#123;</span><br><span class="line">      init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">current就是原数组的遍历的每一个元素</span><br></pre></td></tr></table></figure><h2 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h2><h3 id="51-事件冒泡，如何阻止事件冒泡"><a href="#51-事件冒泡，如何阻止事件冒泡" class="headerlink" title="51.  事件冒泡，如何阻止事件冒泡"></a>51.  事件冒泡，如何阻止事件冒泡</h3><blockquote><p>事件冒泡指的是当前的目标元素触发事件的发生,事件再一次向祖先元素传播,在祖先元素上触发相同类型的事件。</p><p>js冒泡和捕获是事件的两种行为，使用event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用event.preventDefault()可以取消默认事件。</p></blockquote><h3 id="52-事件循环"><a href="#52-事件循环" class="headerlink" title="52.事件循环"></a>52.事件循环</h3><ol><li><p>所有同步任务都是在主线程上执行，形成一个很执行栈</p></li><li><p>主线程之外，还存在一个任务队列（task queue）只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</p></li><li><p>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，就结束等待状态，进入执行栈开始被执行。</p></li><li><p>主线程不断重复以上三步。</p></li></ol><blockquote><p>对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）。</p></blockquote><h3 id="53-什么是浏览器的同源政策"><a href="#53-什么是浏览器的同源政策" class="headerlink" title="53.什么是浏览器的同源政策"></a>53.什么是浏览器的同源政策</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个<br>域的协议、域名、端口号必须相同，否则则不属于同一个域。</p><p>同源政策主要限制了三个方面</p><p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p><p>第二个是当前域下的 js 脚本不能够操作访问其他域下的 DOM。</p><p>第三个是当前域下 ajax 无法发送跨域请求。</p><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者<br>script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><h3 id="54-浏览器如何通过jsonp跨域"><a href="#54-浏览器如何通过jsonp跨域" class="headerlink" title="54.浏览器如何通过jsonp跨域"></a>54.浏览器如何通过jsonp跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过动态创建 script 标签，通过 script 标签的 src 请求来通过jsonp跨域</span><br><span class="line">JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。<span class="built_in">document</span>.domain + iframe跨域：两个页面都通过js强制设置<span class="built_in">document</span>.domain为基础主域，就实现了同域。</span><br><span class="line">location.hash + iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name + iframe跨域：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的<span class="built_in">window</span>.name从外域传递到本地域。</span><br><span class="line"></span><br><span class="line">postMessage跨域：可以跨域操作的<span class="built_in">window</span>属性之一。</span><br><span class="line"></span><br><span class="line">CORS：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。</span><br><span class="line"></span><br><span class="line">代理跨域：启一个代理服务器，实现数据的转发</span><br></pre></td></tr></table></figure><h3 id="55-GET和-POST-的区别"><a href="#55-GET和-POST-的区别" class="headerlink" title="55.GET和 POST 的区别"></a>55.GET和 POST 的区别</h3><ol><li>GET参数通过 url 传递，POST 放在请求体 (request body) 中。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li></ol><h3 id="56-说说你知道的HTTP-状态码"><a href="#56-说说你知道的HTTP-状态码" class="headerlink" title="56.说说你知道的HTTP 状态码"></a>56.说说你知道的HTTP 状态码</h3><ol><li>1XX 信息性状态码<ul><li>100 继续</li><li>101 切换协议</li></ul></li><li>2XX 成功状态码<ul><li>200 OK 成功处理了请求</li><li>204 No Content 请求处理成功，但没有资源可返回</li><li>206 Partial Content 请求资源的某一部分</li></ul></li><li>3XX 重定向状态码<ul><li>301 永久性重定向，表示请求的资源已被分配了新的 URI</li><li>302 临时性重定向，资源的 URL 已临时定位到其他位置</li><li>303 告诉客户端应该用另一个 URL 获取资源</li><li>304 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况</li></ul></li><li>4XX 客户端错误状态码<ul><li>400 表示请求报文中存在语法错误</li><li>401 未授权</li><li>403 服务器拒绝了请求</li><li>404 服务器无法找到所请求的 URL</li></ul></li><li>5XX 服务器错误状态码<ul><li>500 内部服务器错误</li><li>502 错误网关</li><li>503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li><li>504 响应超时</li></ul></li></ol><h3 id="57-js-脚本-defer-和-async-的区别"><a href="#57-js-脚本-defer-和-async-的区别" class="headerlink" title="57.js 脚本 defer 和 async 的区别"></a>57.js 脚本 defer 和 async 的区别</h3><blockquote><p> async 是异步下载并立即执行，然后文档继续解析，defer 是异步加载后解析文档，然后再执行脚本</p></blockquote><h3 id="58-js-如何设置异步"><a href="#58-js-如何设置异步" class="headerlink" title="58.js 如何设置异步"></a>58.js 如何设置异步</h3><ol><li><p>通过回调函数</p></li><li><p>事件监听：对这个事件进行监听，利用定时器的原理去把该事件放入事件队列里，等全部执行完毕之后，才会执行事件队列里的方法</p></li><li><p>发布/订阅：存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做发布/订阅模式。</p><p>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p></li><li><p>Promises对象：每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：f1().then(f2);</p></li></ol><h3 id="59-关于js暂停执行的方法"><a href="#59-关于js暂停执行的方法" class="headerlink" title="59.关于js暂停执行的方法"></a>59.关于js暂停执行的方法</h3><ol><li>利用alert,comfirm弹窗暂停</li><li><p>二:while();方法暂停 <code>while（i&lt;50000000）</code></p><h3 id="60-异步-js-脚本在执行的时候主线程会停止吗"><a href="#60-异步-js-脚本在执行的时候主线程会停止吗" class="headerlink" title="60. 异步 js 脚本在执行的时候主线程会停止吗"></a>60. 异步 js 脚本在执行的时候主线程会停止吗</h3></li></ol><blockquote><p>不会，因为是异步的，例如：刷微博，当你刷的比较快的时候，有些图片没有加载出来图片资源的加载就是一个分线程。整个页面的刷新是主线程 又或者博客的加载，有些页面的文字显示了，而图片设置了懒加载之后显示（减轻服务器的负担，增加用户体验）</p></blockquote><h2 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h2><h3 id="61-async-await-是一个语法糖，你知道-await-后面如何用吗"><a href="#61-async-await-是一个语法糖，你知道-await-后面如何用吗" class="headerlink" title="61. async/await 是一个语法糖，你知道 await 后面如何用吗"></a>61. async/await 是一个语法糖，你知道 await 后面如何用吗</h3><p><strong>await</strong> 右侧的表达式一般为 <strong>promise</strong> 对象, 但也可以是其它的值</p><ol><li>如果表达式是 promise 对象, await 返回的是 promise 成功的值</li><li>如果表达式是其它值, 直接将此值作为 await 的返回值</li></ol><p><strong>async </strong> 使用在<strong>定义方法</strong>时修饰, 方法内部就可以使用await</p><h3 id="62-this-在-node-里全局的指向是什么"><a href="#62-this-在-node-里全局的指向是什么" class="headerlink" title="62.this 在 node 里全局的指向是什么"></a>62.this 在 node 里全局的指向是什么</h3><blockquote><p>global</p></blockquote><h3 id="63-对象的深拷贝和浅拷贝"><a href="#63-对象的深拷贝和浅拷贝" class="headerlink" title="63.对象的深拷贝和浅拷贝"></a>63.对象的深拷贝和浅拷贝</h3><p><strong>浅拷贝</strong></p><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p><strong>深拷贝</strong></p><p>浅拷贝只在根属性上在堆内存中创建了一个新的的对象，复制了基本类型的值,但是复杂数据类型也就是对象则是拷贝相同的地址，而深拷贝则是对于复杂数据类型在堆内存中开辟了一块内存地址用于存放复制的对象并且把原有的对象复制过来，这2个对象是相互独立的,也就是2个不同的地址</p><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><h3 id="64-git-rebase-和-git-merge-的区别"><a href="#64-git-rebase-和-git-merge-的区别" class="headerlink" title="64.git rebase 和 git merge 的区别"></a>64.git rebase 和 git merge 的区别</h3><p>假设有3次提交A,B,C。</p><p>在远程分支origin的基础上创建一个名为”mywork”的分支并提交了，同时有其他人在”origin”上做了一些修改并提交了。</p><p>其实这个时候E不应该提交，因为提交后会发生冲突。如何解决这些冲突呢？有以下两种方法：</p><p>1、git merge<br>用git pull命令把”origin”分支上的修改pull下来与本地提交合并（merge）成版本M，但这样会形成图中的菱形，让人很困惑。</p><p>2、git rebase<br>创建一个新的提交R，R的文件内容和上面M的一样，但我们将E提交废除，当它不存在（图中用虚线表示）。由于这种删除，小李不应该push其他的repository.rebase的好处是避免了菱形的产生，保持提交曲线为直线，让大家易于理解。</p><p>在rebase的过程中，有时也会有conflict，这时Git会停止rebase并让用户去解决冲突，解决完冲突后，用git add命令去更新这些内容，然后不用执行git-commit,直接执行git rebase —continue,这样git会继续apply余下的补丁。<br>在任何时候，都可以用git rebase —abort参数来终止rebase的行动，并且mywork分支会回到rebase开始前的状态。</p><h3 id="65-DOM事件流包括哪些阶段"><a href="#65-DOM事件流包括哪些阶段" class="headerlink" title="65.DOM事件流包括哪些阶段"></a>65.DOM事件流包括哪些阶段</h3><ul><li>事件捕获阶段： 事件对象从Window对象开始沿传播路径向下，依次经过各元素传播至目标元素的父元素；</li><li>处于目标阶段 ：事件对象到达目标元素；</li><li>事件冒泡阶段： 事件对象从目标元素的父元素开始沿传播路径向上，依次经过各元素传播至Window对象。</li></ul><p>先捕获再冒泡</p><h3 id="66-什么是监听事件，监视事件的方式"><a href="#66-什么是监听事件，监视事件的方式" class="headerlink" title="66.什么是监听事件，监视事件的方式"></a>66.什么是监听事件，监视事件的方式</h3><blockquote><p>监听事件就是等待某个事件的发生，当这个事件发生之后，对其做出一个响应。如：鼠标单击一个按钮，单击按钮时打开一个新的页面，或者双击桌面的应用图标，运行一个程序，这都是监听事件的应用。</p></blockquote><p><strong>监听三要素</strong></p><ol><li>Event Source(事件源)：监听的目标，假如我们给Button设置一个点击事件，那么Button就为事件源</li><li>Event(事件)：发生的事件，不同的事件需要相应的事件监听器进行处理，点击、触摸、按下等都是事件</li><li>Event Listener(事件监听器)：不同的事件监听器处理不同的监听事件</li></ol><p><strong>实现方式</strong></p><ol><li><p>常用的五种监听方式的实现方式 ：内部类、匿名内部类、外部类、事件源所在类、onClick属性</p></li><li><p>通过onClick属性实现：在Button控件中有一个”onClick”属性，用于给Button控件设置监听事件，创建一个监听事件作为属性值传入</p></li></ol><h3 id="67-addEventListener-的参数有哪些"><a href="#67-addEventListener-的参数有哪些" class="headerlink" title="67. addEventListener 的参数有哪些"></a>67. addEventListener 的参数有哪些</h3><blockquote><p> addEventListener 有三个参数：第一个参数表示事件名称（不含 on，如 “click”）；第二个参数表示要接收事件处理的函数；第三个参数为 useCapture</p><p>简明说：事件名称；事件处理函数；捕获还是冒泡。</p></blockquote><h3 id="68-浏览器输入-URL-之后发生了什么"><a href="#68-浏览器输入-URL-之后发生了什么" class="headerlink" title="68. 浏览器输入 URL 之后发生了什么"></a>68. 浏览器输入 URL 之后发生了什么</h3><p>参考链接：<a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="69-flex-有哪些属性，flex-basis-属性是干嘛的"><a href="#69-flex-有哪些属性，flex-basis-属性是干嘛的" class="headerlink" title="69.flex 有哪些属性，flex-basis 属性是干嘛的"></a>69.flex 有哪些属性，flex-basis 属性是干嘛的</h3><ol><li><p>flex-direction属性：flex-direction属性决定主轴的方向（即项目的排列方向）。</p></li><li><p>flex-wrap属性：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，应该如何换行。</p></li><li><p>flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p></li><li><p>.justify-content属性：justify-content属性定义了项目在主轴上(即横向)的对齐方式。</p></li><li><p>align-items属性：align-items属性定义项目在交叉轴上(即纵向,垂直)如何对齐。</p></li></ol><p>flex-basis属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</span><br><span class="line">浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line">.item &#123;</span><br><span class="line">    flex-basis: <span class="xml"><span class="tag">&lt;<span class="name">length</span>&gt;</span> | auto; /* default auto */</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</span></span><br></pre></td></tr></table></figure><h3 id="70-线程与进程的区别"><a href="#70-线程与进程的区别" class="headerlink" title="70.线程与进程的区别"></a>70.线程与进程的区别</h3><p>官网定义：<br>进程是系统进行资源分配和调度的基本单位</p><p>线程是操作系统能够进行运算调度的最小单位</p><p>简单理解：<br>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p><p>借助阮一峰老师的解释<br>1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>4.一个车间里，可以有很多工人。他们协同完成一个任务。<br>5.线程就好比车间里的工人。一个进程可以包括多个线程。<br>6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。<br>  这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。<br>  这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。<br>10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。<br>  这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</p><p>操作系统的设计，因此可以归结为三点：</p><p>（1）以多进程形式，允许多个任务同时运行；</p><p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p><p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p><h2 id="11-22"><a href="#11-22" class="headerlink" title="11.22"></a>11.22</h2><h3 id="71-区分-‘123’-和-123-的方法"><a href="#71-区分-‘123’-和-123-的方法" class="headerlink" title="71. 区分 ‘123’ 和 123 的方法"></a>71. 区分 ‘123’ 和 123 的方法</h3><ol><li><p><strong>typeof</strong></p></li><li><p><strong>instanceof</strong></p></li><li><p><strong>toString.call() 最靠谱</strong>  </p><ul><li><p>toString.call(‘aaa’) <em>// “[object String]”</em></p></li><li><p>toString.call(123) <em>// “[object Number]”</em></p></li></ul></li></ol><h3 id="72-Object-defineProperty-是干嘛的，参数有哪些"><a href="#72-Object-defineProperty-是干嘛的，参数有哪些" class="headerlink" title="72.Object.defineProperty 是干嘛的，参数有哪些"></a>72.Object.defineProperty 是干嘛的，参数有哪些</h3><blockquote><p>Object.defineProperty 需要三个参数（object , prop, descriptor）</p></blockquote><p>　    1 object 对象 =&gt;要定义属性的对象。 给谁加<br>　　2 propName 属性名 =&gt; 要定义或修改的属性的名称或 Symbol，要加的属性的名字 【类型：String】<br>　　3 descriptor 属性描述 =&gt; 要定义或修改的属性描述符，加的这个属性有什么样的特性【类型：Object】</p><h3 id="73-TCP-IP五层模型-OSI七层模型"><a href="#73-TCP-IP五层模型-OSI七层模型" class="headerlink" title="73. TCP/IP五层模型  OSI七层模型"></a>73. TCP/IP五层模型  OSI七层模型</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*<span class="strong">*五层模型*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">应用层</span></span><br><span class="line"><span class="strong">传输层</span></span><br><span class="line"><span class="strong">网络层</span></span><br><span class="line"><span class="strong">数据链路层</span></span><br><span class="line"><span class="strong">物理层</span></span><br><span class="line"><span class="strong">*</span><span class="strong">*七层模型*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">应用层</span></span><br><span class="line"><span class="strong">表示层</span></span><br><span class="line"><span class="strong">会话层</span></span><br><span class="line"><span class="strong">传输层</span></span><br><span class="line"><span class="strong">网络层</span></span><br><span class="line"><span class="strong">数据链路层</span></span><br><span class="line"><span class="strong">物理层</span></span><br></pre></td></tr></table></figure><h3 id="74-应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的"><a href="#74-应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的" class="headerlink" title="74.应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的"></a>74.应用层的协议哪些是基于TCP协议的，哪些是基于UDP协议的</h3><p><strong>基于TCP协议的</strong></p><ul><li>FTP（文件传输协议）：定义了文件传输协议，使用21端口。</li><li>TELNET（远程登陆协议）：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</li><li>SMTP（简单邮件传输协议）：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</li><li>POP3（邮件读取协议）：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</li><li>HTTP（超文本传输协议）：是从Web服务器传输超文本到本地浏览器的传送协议。</li><li>HTTPS（超文本传输安全协议）</li></ul><p><strong>基于UDP协议的</strong></p><ul><li>TFTP（简单文件传输协议）：该协议在熟知端口69上使用UDP服务。</li><li>SNMP（简单网络管理协议）：使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li><li>BOOTP（引导程序协议，DHCP的前身）：应用于无盘设备</li><li>DHCP（动态主机配置协议）：是一个局域网的网络协议</li><li>RIP（路由信息协议）：基于距离矢量算法的路由协议，利用跳数来作为计量标准。</li><li>IGMP（Internet组管理协议）</li></ul><p><strong>基于TCP和UDP协议的</strong></p><ul><li>DNS（域名系统）：DNS区域传输的时候使用TCP协议。域名解析时使用UDP协议。DNS用的是53号端口。</li><li>ECHO（回绕协议）</li></ul><h3 id="75-HTTP-与-HTTPS-的区别"><a href="#75-HTTP-与-HTTPS-的区别" class="headerlink" title="75.HTTP 与 HTTPS 的区别"></a>75.HTTP 与 HTTPS 的区别</h3><ol><li>HTTP 传输的数据都是未加密的，也就是明文的，HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</li><li>HTTPS 协议需要 CA 证书，费用较高；</li><li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443；</li></ol><h3 id="76-HTTPS-协议的工作原理"><a href="#76-HTTPS-协议的工作原理" class="headerlink" title="76.HTTPS 协议的工作原理"></a>76.HTTPS 协议的工作原理</h3><ol><li>客户使用 HTTPS URL 访问服务器，则要求 web 服务器建立 SSL 链接。</li><li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回给客户端。</li><li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器通过自己的私钥解密出会话密钥。</li><li>web 服务器通过会话密钥加密与客户端之间进行通信。</li></ol><h3 id="77-HTTP-2-0-特性（相比于1-0）"><a href="#77-HTTP-2-0-特性（相比于1-0）" class="headerlink" title="77.HTTP/2.0 特性（相比于1.0）"></a>77.HTTP/2.0 特性（相比于1.0）</h3><ol><li>首部压缩</li><li>多路复用</li><li>二进制分帧</li><li>服务端推送</li></ol><h3 id="78-TCP-和-UDP-之间的区别"><a href="#78-TCP-和-UDP-之间的区别" class="headerlink" title="78.TCP 和 UDP 之间的区别"></a>78.TCP 和 UDP 之间的区别</h3><p><strong>TCP：传输控制协议 UDP：用户数据报协议</strong></p><ol><li>TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接；</li><li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。</li><li>TCP 是面向字节流，UDP 面向报文；</li><li>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多；</li><li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节；</li></ol><h3 id="79-三次握手相关内容"><a href="#79-三次握手相关内容" class="headerlink" title="79.三次握手相关内容"></a>79.三次握手相关内容</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222040742.png" alt="image-20211122204020581"></p><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</p><h5 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第一种回答-2" target="_blank" rel="noopener">第一种回答</a></h5><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li></ul><h5 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第二种回答-2" target="_blank" rel="noopener">第二种回答</a></h5><ul><li><strong>初始状态</strong>：客户端处于 <code>closed(关闭)</code>状态，服务器处于 <code>listen(监听)</code> 状态。</li><li><strong>第一次握手</strong>：客户端发送请求报文将 <code>SYN = 1</code>同步序列号和初始化序列号<code>seq = x</code>发送给服务端，发送完之后客户端处于发送等待状态<code>SYN_Send</code>状态。（验证了客户端的发送能力和服务端的接收能力)</li><li><strong>第二次握手</strong>：服务端受到 <code>SYN</code> 请求报文之后，如果同意连接，会以自己的同步序列号<code>SYN(服务端) = 1</code>、初始化序列号 <code>seq = y</code>和确认序列号（期望下次收到的数据包）<code>ack = x+ 1</code> 以及确认号<code>ACK = 1</code>报文作为应答，服务器为<code>SYN_Receive</code>状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li><li><strong>第三次握手</strong>： 客户端接收到服务端的 <code>SYN + ACK</code>之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 <code>ack = y + 1</code>和数据包的序列号 <code>seq = x + 1</code>以及确认号<code>ACK = 1</code>确认包作为应答，客户端转为确认连接<code>established</code>状态。（分别站在双方的角度上思考，各自ok）</li></ul><h3 id="79-为什么需要三次握手，两次不行吗？"><a href="#79-为什么需要三次握手，两次不行吗？" class="headerlink" title="79.为什么需要三次握手，两次不行吗？"></a>79.为什么需要三次握手，两次不行吗？</h3><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><ul><li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><p>为什么要进行三次握手的情况：</p><blockquote><p>当进行第一次握手，网络不好可能会堵塞，所以连接的请求并没有到达服务器端;但是tcp连接有超时重传的机制，所以再一次发送请求，这时候服务器端接收到了你的请求，他也会返回一个请求给你，这是第二次握手;<br>但是这时候网络环境突然又好了起来，那个堵塞的请求到达了服务器端，服务器端又给你回了一个请求，但是你又不想给服务器发送请求，这时候服务器的资源会进行占用等待你的请求，为了不使服务器的资源继续占用，你又必须发送一个请求给服务器;<br>所以要进行3次握手</p></blockquote><h3 id="80-四次挥手相关内容"><a href="#80-四次挥手相关内容" class="headerlink" title="80.四次挥手相关内容"></a>80.四次挥手相关内容</h3><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111222044207.png" alt="image-20211122204409801"></p><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<strong>半关闭</strong>（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><h5 id="第一种回答-1"><a href="#第一种回答-1" class="headerlink" title="第一种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第一种回答-3" target="_blank" rel="noopener">第一种回答</a></h5><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ul><p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><h5 id="第二种回答-1"><a href="#第二种回答-1" class="headerlink" title="第二种回答"></a><a href="https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=第二种回答-3" target="_blank" rel="noopener">第二种回答</a></h5><ul><li><strong>初始化状态</strong>：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。</li><li><strong>第一次分手</strong>：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。</li></ul><blockquote><p>假如客户端发送的数据已经发送完毕，发送FIN = 1 <strong>告诉服务端，客户端所有数据已经全发完了</strong>，<strong>服务端你可以关闭接收了</strong>，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN = 1等待服务端确认释放连接状态。</p></blockquote><ul><li><strong>第二次分手</strong>：服务端接收到客户端的释放请求连接之后，<strong>知道客户端没有数据要发给自己了</strong>，<strong>然后服务端发送ACK = 1告诉客户端收到你发给我的信息</strong>，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）</li><li><strong>第三次分手</strong>：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，<strong>用于告诉客户端，服务端的所有数据发送完毕</strong>，<strong>客户端你也可以关闭接收数据连接了</strong>。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）</li><li><strong>第四次分手</strong>：此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息。<strong>有一个 2 MSL 的延迟等待</strong>。</li></ul><h3 id="81-React-页面路由参数传递的两种方法-对应实战第11天的一个大坑"><a href="#81-React-页面路由参数传递的两种方法-对应实战第11天的一个大坑" class="headerlink" title="81. React-页面路由参数传递的两种方法(对应实战第11天的一个大坑)"></a>81. React-页面路由参数传递的两种方法(对应实战第11天的一个大坑)</h3><p>list页-&gt;detail页</p><p><strong>方法一：路由参数</strong></p><p><strong>路由导航：</strong></p><p>用“/”</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link <span class="keyword">to</span>=&#123;<span class="string">'/detail/'</span>+item.<span class="keyword">get</span>(<span class="string">'id'</span>)&#125; key=&#123;<span class="keyword">index</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p><strong>路由map：</strong></p><p>加”/：id”</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/detail/:id"</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>detail页获取参数：</strong></p><p>准确的获取到id，不需要做处理</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.props</span><span class="selector-class">.match</span><span class="selector-class">.params</span><span class="selector-class">.id</span></span><br></pre></td></tr></table></figure><p><strong>方法二：查询参数</strong></p><p><strong>路由导航：</strong></p><p>用“？”</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link <span class="keyword">to</span>=&#123;<span class="string">'/detail?'</span>+item.<span class="keyword">get</span>(<span class="string">'id'</span>)&#125; key=&#123;<span class="keyword">index</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p><strong>路由map：</strong></p><p>不加”/：id”</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">"/detail"</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>detail页获取参数：</strong></p><p>不能准确的获取到id，需要做处理</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.props</span><span class="selector-class">.location</span><span class="selector-class">.search</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端面试题（每日10道）&quot;&gt;&lt;a href=&quot;#前端面试题（每日10道）&quot; class=&quot;headerlink&quot; title=&quot;前端面试题（每日10道）&quot;&gt;&lt;/a&gt;前端面试题（每日10道）&lt;/h1&gt;&lt;h2 id=&quot;11-15&quot;&gt;&lt;a href=&quot;#11-15&quot; c</summary>
      
    
    
    
    <category term="面试" scheme="https://wzt2022.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端面试题" scheme="https://wzt2022.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Git教程</title>
    <link href="https://wzt2022.github.io/2021/11/13/Git%E6%95%99%E7%A8%8B%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    <id>https://wzt2022.github.io/2021/11/13/Git%E6%95%99%E7%A8%8B%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/</id>
    <published>2021-11-12T16:00:00.000Z</published>
    <updated>2021-11-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><blockquote><p>什么是版本控制</p></blockquote><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><blockquote><p>Github 和 Git区别。</p></blockquote><p>Git是版本控制系统，Github是在线的基于Git的代码托管服务。GitHub是2008年由Ruby on Rails编写而成。 GitHub同时提供付费账户和免费账户。 这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。 为什么现在Github这么火，以至于世界顶级公司和项目的源码很多都托管在Github上——颜值高！ 现在这世代还是得看看颜值的。 你说Sourceforge等代码托管网站也年岁很久了，为什么没有Github那么火呢？ 关键是Github长得好看（你长这么好看，说什么都是对的）。 Linus Torvalds的Github页面,打开看看吧，Linux的源码就在上面，随时在更新！</p><blockquote><p>常见的版本控制工具</p></blockquote><ul><li>Git</li><li>SVN</li><li>CVS</li><li>VSS</li><li><p>TFS<br>版本控制的产品非常多，现在影响力最大且使用最广泛的是Git与SVN</p><a id="more"></a><blockquote><p>版本控制分类</p></blockquote></li><li><p>本地版本控制:记录文件每次的更新,适合个人用。</p></li><li><p>集中版本控制 SVN:所有的版本数据都保存在服务器上。</p></li><li><p>分布式版本控制 Git: 每个人都拥有全部的代码，不会因为服务器或者网络问题，造成不能工作的情况，但是存在安全隐患就是跑路的时候可以将公司所有代码带走。</p></li></ul><blockquote><p>Git与SVN的主要区别</p></blockquote><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h2 id="聊聊Git的历史"><a href="#聊聊Git的历史" class="headerlink" title="聊聊Git的历史"></a>聊聊Git的历史</h2><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><p><strong><em>Git是目前世界上最先进的分布式版本控制系统</em></strong></p><p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p><h2 id="Git的环境配置"><a href="#Git的环境配置" class="headerlink" title="Git的环境配置"></a>Git的环境配置</h2><ol><li><p>首先打开git官网[git官网]  <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载Git对应操作系统的版本</p><p> <img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131426896.png" alt="image-20211113142605414"><br> 安装过程无脑下一步即可，安装完毕就可以使用了</p></li><li><p>安装成功后右击桌面就会有相应的图标显示</p><p> <img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131431838.png" alt="image-20211113143120394"></p></li><li><p>如果要卸载就要先将环境变量有关Git的pash删除了再进行卸载<br>win10的环境变量: 右击鼠标-&gt;显示设置-&gt;最后一项关于<br> <img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131435734.png" alt="image-20211113143514018"></p></li></ol><blockquote><p>常用的Linux命令</p></blockquote><ul><li><p>cd : 改变目录。</p></li><li><p>cd . . 回退到上一个目录，直接cd进入默认目录</p></li><li><p>pwd : 显示当前所在的目录路径。</p></li><li><p>ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p></li><li><p>touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p></li><li><p>rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p></li><li><p>mkdir:  新建一个目录,就是新建一个文件夹。</p></li><li><p>rm -r :  删除一个文件夹, rm -r src 删除src目录，<br>rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</p></li><li><p>mv 移动文件, mv index.html src ，index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p></li><li><p>reset 重新初始化终端/清屏。</p></li><li><p>clear 清屏。</p></li><li><p>history 查看命令历史。</p></li><li><p>help 帮助。</p></li><li><p>exit 退出。</p></li><li><p>表示注释</p></li></ul><blockquote><p>Git 配置</p></blockquote><ol><li><p>所有的配置文件，其实都保存在本地！查看配置 git config -l</p></li><li><p>查看不同级别的配置文件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看当前系统配置 : git config --system --list  </span><br><span class="line">查看当前用户配置 : git config --global --list</span><br></pre></td></tr></table></figure></li><li><p>设置用户名与邮箱</p><p> 当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;XXX&quot;  #名称</span><br><span class="line">git config --global user.email 邮箱@qq.com 邮箱</span><br></pre></td></tr></table></figure></li></ol><h2 id="Git基本原理"><a href="#Git基本原理" class="headerlink" title="Git基本原理"></a>Git基本原理</h2><blockquote><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p></blockquote><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131511624.png" alt="image-20211113151110294"></p><ul><li><p>Workspace：工作区，就是你平时存放项目代码的地方</p></li><li><p>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p></li></ul><blockquote><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本</p></blockquote><ul><li><p>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</p></li><li><p>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</p></li><li><p>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</p></li><li><p>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</p></li><li><p>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</p></li><li><p>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</p></li></ul><blockquote><p>工作流程</p></blockquote><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131515371.png" alt="image-20211113151502567"></p><h2 id="Git-项目搭建"><a href="#Git-项目搭建" class="headerlink" title="Git 项目搭建"></a>Git 项目搭建</h2><ol><li><p>创建工作目录与常用指令<br> 工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p></li><li><p>本地仓库搭建<br> 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><ul><li><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><ul><li>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</li></ul></li></ul></li><li><p>克隆远程仓库</p><ul><li><p>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]https:&#x2F;&#x2F;gitee.com&#x2F;kuangstudy&#x2F;openclass.git</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Git-文件"><a href="#Git-文件" class="headerlink" title="Git 文件"></a>Git 文件</h2><blockquote><p>文件的四种状态</p></blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p></li></ul><blockquote><p>查看文件状态</p></blockquote><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line">#查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"># git add .                  添加所有文件到暂存区</span><br><span class="line"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>忽略文件</p></blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p><ol><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class="line">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>使用码云或者github作为仓库</p></blockquote><h2 id="VScode集成Git"><a href="#VScode集成Git" class="headerlink" title="VScode集成Git"></a>VScode集成Git</h2><blockquote><p>实例</p></blockquote><ol><li><p>假设你从github或者gitee下载一个开源项目，当然我们也可以使用git 的clone命令，从远程克隆一个项目，然后直接用vscode打开文件夹， VSCode会自动识别各项配置。</p><p> 举个例子:<br> <img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131836665.png" alt="image-20211113183633639"><br> 这里复制的地址最好是采用SSH协议的地址,因为在vscode集成的git在经过修改push到仓库的时候都会要求设置输入密码才能上传至仓库因此这里需要做一个免密登陆的操作</p></li><li><p>免密登陆操作如下</p><p> 设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入 C:\Users\Administrator\.ssh 目录</span><br><span class="line"># 生成公钥</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p> 随即打开 <code>C:\Users\Administrator\.ssh</code> 该目录下的id_rsa.pub文件，将里面的内容复制粘贴至空白处 粘贴完随即标题也就产生，公钥也就产生了。</p><p> <img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131847183.png" alt="image-20211113184659623"></p></li><li><p>将上述克隆下来的文件用vscode打开对文件进行修改的操作相应的源代码管理也会显示更改的次数 随即就是上传暂存区-&gt;仓库区-&gt;远程仓库</p><p><img data-src="/images/loading.gif" data-original="https://gitee.com/letter-from-berlin/PictureBed/raw/master/202111131858622.png" alt="image-20211113185840209"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;什么是版本控制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Github 和 Git区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git是版本控制系统，Github是在线的基于Git的代码托管服务。GitHub是2008年由Ruby on Rails编写而成。 GitHub同时提供付费账户和免费账户。 这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。 为什么现在Github这么火，以至于世界顶级公司和项目的源码很多都托管在Github上——颜值高！ 现在这世代还是得看看颜值的。 你说Sourceforge等代码托管网站也年岁很久了，为什么没有Github那么火呢？ 关键是Github长得好看（你长这么好看，说什么都是对的）。 Linus Torvalds的Github页面,打开看看吧，Linux的源码就在上面，随时在更新！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见的版本控制工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;SVN&lt;/li&gt;
&lt;li&gt;CVS&lt;/li&gt;
&lt;li&gt;VSS&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TFS&lt;br&gt;版本控制的产品非常多，现在影响力最大且使用最广泛的是Git与SVN&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://wzt2022.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://wzt2022.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wzt2022.github.io/2021/11/12/hello-world/"/>
    <id>https://wzt2022.github.io/2021/11/12/hello-world/</id>
    <published>2021-11-12T02:07:22.071Z</published>
    <updated>2021-11-12T02:07:22.071Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>React自定义主题配置</title>
    <link href="https://wzt2022.github.io/2021/11/11/2021.3.7React%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>https://wzt2022.github.io/2021/11/11/2021.3.7React%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</id>
    <published>2021-11-10T16:00:00.000Z</published>
    <updated>2021-11-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-自定义-antd-主题方法编译失败与解决办法"><a href="#React-自定义-antd-主题方法编译失败与解决办法" class="headerlink" title="React 自定义 antd 主题方法编译失败与解决办法"></a>React 自定义 antd 主题方法编译失败与解决办法</h2><h3 id="一、按照官网操作"><a href="#一、按照官网操作" class="headerlink" title="一、按照官网操作"></a>一、按照官网操作</h3><p>首先我是按照<a href="https://3x.ant.design/docs/react/use-with-create-react-app-cn" target="_blank" rel="noopener"><strong>官网的步骤</strong></a>一步一步操作下来的：</p><ol><li><p>安装 <code>less</code> 和 <code>less-loader</code></p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader</span><br></pre></td></tr></table></figure></li><li><p>引入 <code>customize-cra</code> 中提供的 <code>less</code> 相关的函数 <code>addLessLoader</code> 来帮助加载 <code>less</code> 样式，同时修改 <code>config-overrides.js</code> 文件如下:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置具体的修改规则</span></span><br><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports,addLessLoader&#125; = <span class="built_in">require</span>(<span class="string">'customize-cra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">    libraryName: <span class="string">'antd'</span>,</span><br><span class="line">    libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">    style: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  addLessLoader(&#123;</span><br><span class="line">    javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    modifyVars: &#123; <span class="string">'@primary-color'</span>: <span class="string">'green'</span> &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><a id="more"></a></li></ol><h3 id="二、出现的问题"><a href="#二、出现的问题" class="headerlink" title="二、出现的问题"></a>二、出现的问题</h3><ol><li><p><code>addLessLoader</code> 这块出现以下问题</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ValidationError: <span class="title">Invalid</span> <span class="title">options</span> <span class="title">object</span>. <span class="title">Less</span> <span class="title">Loader</span> <span class="title">has</span> <span class="title">been</span> <span class="title">initialized</span> <span class="title">using</span> <span class="title">an</span> <span class="title">options</span> <span class="title">object</span></span></span><br><span class="line"><span class="function"><span class="title">that</span> <span class="title">does</span> <span class="title">not</span> <span class="title">match</span> <span class="title">the</span> <span class="title">API</span> <span class="title">schema</span>.</span></span><br><span class="line"><span class="function">- <span class="title">options</span> <span class="title">has</span> <span class="title">a</span> <span class="title">unknown</span> <span class="title">property</span> '<span class="title">modifyVars</span>'. <span class="title">These</span> <span class="title">properties</span> <span class="title">are</span> <span class="title">valid</span>: </span></span><br><span class="line"><span class="function"><span class="title">object</span> &#123; <span class="title">lessOptions</span>?, <span class="title">additonalData</span>?, <span class="title">sourceMap</span>?, <span class="title">webpackImporter</span>? &#125;</span></span><br></pre></td></tr></table></figure><p> 这是由于 <code>less</code> 更新了导致的，解决办法：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addLessLoader(&#123;</span><br><span class="line">  lessOptions:&#123;  </span><br><span class="line">    javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    modifyVars: &#123; <span class="string">'@primary-color'</span>: <span class="string">'green'</span> &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>编译出错如下</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TypeError: <span class="title">this.getOptions</span> <span class="title">is</span> <span class="title">not</span> <span class="title">a</span> <span class="title">function</span></span></span><br></pre></td></tr></table></figure><p> 解决方案：我装的都是最新版本<code>less@4.1.1</code> <code>less-loader@8.0.0</code> ，我们需要降低版本，亲测以下两个版本可以。</p><ul><li><p>先卸载 <code>less</code> 和 <code>less-loader</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall less less-loader</span><br></pre></td></tr></table></figure></li><li><p>再安装指定版本</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less@<span class="number">3</span>.<span class="number">12</span>.<span class="number">2</span> less-loader@<span class="number">7</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>前端技术更新太快的同时就会带来不兼容的问题，我们能做的就是<strong>乐在其中</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;React-自定义-antd-主题方法编译失败与解决办法&quot;&gt;&lt;a href=&quot;#React-自定义-antd-主题方法编译失败与解决办法&quot; class=&quot;headerlink&quot; title=&quot;React 自定义 antd 主题方法编译失败与解决办法&quot;&gt;&lt;/a&gt;React 自定义 antd 主题方法编译失败与解决办法&lt;/h2&gt;&lt;h3 id=&quot;一、按照官网操作&quot;&gt;&lt;a href=&quot;#一、按照官网操作&quot; class=&quot;headerlink&quot; title=&quot;一、按照官网操作&quot;&gt;&lt;/a&gt;一、按照官网操作&lt;/h3&gt;&lt;p&gt;首先我是按照&lt;a href=&quot;https://3x.ant.design/docs/react/use-with-create-react-app-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;官网的步骤&lt;/strong&gt;&lt;/a&gt;一步一步操作下来的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 &lt;code&gt;less&lt;/code&gt; 和 &lt;code&gt;less-loader&lt;/code&gt;&lt;/p&gt;
 &lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install less less-loader&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引入 &lt;code&gt;customize-cra&lt;/code&gt; 中提供的 &lt;code&gt;less&lt;/code&gt; 相关的函数 &lt;code&gt;addLessLoader&lt;/code&gt; 来帮助加载 &lt;code&gt;less&lt;/code&gt; 样式，同时修改 &lt;code&gt;config-overrides.js&lt;/code&gt; 文件如下:&lt;/p&gt;
 &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//配置具体的修改规则&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; override, fixBabelImports,addLessLoader&amp;#125; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;customize-cra&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = override(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fixBabelImports(&lt;span class=&quot;string&quot;&gt;&#39;import&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    libraryName: &lt;span class=&quot;string&quot;&gt;&#39;antd&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    libraryDirectory: &lt;span class=&quot;string&quot;&gt;&#39;es&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    style: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  addLessLoader(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    javascriptEnabled: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    modifyVars: &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;@primary-color&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="React" scheme="https://wzt2022.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://wzt2022.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 搭建博客填坑</title>
    <link href="https://wzt2022.github.io/2021/11/11/Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%A1%AB%E5%9D%91/"/>
    <id>https://wzt2022.github.io/2021/11/11/Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%A1%AB%E5%9D%91/</id>
    <published>2021-11-10T16:00:00.000Z</published>
    <updated>2021-11-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切换-Next-主题"><a href="#切换-Next-主题" class="headerlink" title="切换 Next 主题"></a>切换 Next 主题</h2><ol><li>找到这个 next 主题的 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">GitHub 网站</a></li><li><p>进入你的博客本地路径，例如我的是放在 D 盘下，然后将主题 clone 到本地</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd D:\myblog\blog</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure> <a id="more"></a></li><li><p>修改配置文件<br>打开根目录下的·<code>_config.yml</code> 的站点配置文件，找到themes的配置项，修改为next</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li><li><p>调试、发布</p><p> 输入调试指令，在浏览器中输入localhost:4000查看</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --debug</span><br></pre></td></tr></table></figure><p> 在本地查看无误之后，输入生成和发布命令,就可已将新主题发布到自己的博客网站上了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p> 如出现缓存引起的异常，可以在生成命令前执行清除缓存命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="Hexo-部署-Next-主题网页字体不生效"><a href="#Hexo-部署-Next-主题网页字体不生效" class="headerlink" title="Hexo 部署 Next 主题网页字体不生效"></a>Hexo 部署 Next 主题网页字体不生效</h2><ul><li><p>说明：</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo 下的 _config.yml 称为站点配置文件</span><br><span class="line">themes/next 中的_config.yml 称为主题配置文件</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>按照hexo 的官方文档，在站点配置文件设置语言（第7行）</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Lee</span> <span class="string">的个人博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">'进击的技术客'</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'Everything will be ok!'</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">'努力一片天'</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Lee</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure></li><li><p>这样还是不起作用的话,请查看 <code>theme/next/languages/</code> 目录下是否有 <code>zh-Hans.yml</code> 文件.一般是有 <code>zh-CN.yml</code> ，所以要把 <code>zh-CN.yml</code> 文件改成名字为 <code>zh-Hans.yml</code> 就可以了</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;切换-Next-主题&quot;&gt;&lt;a href=&quot;#切换-Next-主题&quot; class=&quot;headerlink&quot; title=&quot;切换 Next 主题&quot;&gt;&lt;/a&gt;切换 Next 主题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;找到这个 next 主题的 &lt;a href=&quot;https://github.com/theme-next/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入你的博客本地路径，例如我的是放在 D 盘下，然后将主题 clone 到本地&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd D:\myblog\blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;theme-next&amp;#x2F;hexo-theme-next themes&amp;#x2F;next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://wzt2022.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo爬坑" scheme="https://wzt2022.github.io/tags/Hexo%E7%88%AC%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>title</title>
    <link href="https://wzt2022.github.io/2021/11/08/title/"/>
    <id>https://wzt2022.github.io/2021/11/08/title/</id>
    <published>2021-11-08T15:11:25.000Z</published>
    <updated>2021-11-08T15:11:25.000Z</updated>
    
    
    
    
    
    <category term="暂无" scheme="https://wzt2022.github.io/tags/%E6%9A%82%E6%97%A0/"/>
    
  </entry>
  
</feed>
